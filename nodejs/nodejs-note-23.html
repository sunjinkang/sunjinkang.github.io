<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"sunjinkang.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="process 进程‘beforeExit’ 事件当 Node.js 清空其事件循环并且没有额外的工作要安排时，则会触发 ‘beforeExit’ 事件。 通常情况下，当没有工作要调度时，Node.js 进程会退出，但是注册在 ‘beforeExit’ 事件上的监听器可以进行异步的调用，从而使 Node.js 进程继续。 调用监听器回调函数时将 process.exitCode 的值作为唯一的参数">
<meta property="og:type" content="blog">
<meta property="og:title" content="nodejs基础知识(13)">
<meta property="og:url" content="https://sunjinkang.github.io/nodejs/nodejs-note-23.html">
<meta property="og:site_name" content="Sun with no word">
<meta property="og:description" content="process 进程‘beforeExit’ 事件当 Node.js 清空其事件循环并且没有额外的工作要安排时，则会触发 ‘beforeExit’ 事件。 通常情况下，当没有工作要调度时，Node.js 进程会退出，但是注册在 ‘beforeExit’ 事件上的监听器可以进行异步的调用，从而使 Node.js 进程继续。 调用监听器回调函数时将 process.exitCode 的值作为唯一的参数">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-28T13:09:20.000Z">
<meta property="article:modified_time" content="2023-07-24T09:24:46.501Z">
<meta property="article:author" content="Sun Jinkang">
<meta property="article:tag" content="node">
<meta property="article:tag" content="process 进程">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://sunjinkang.github.io/nodejs/nodejs-note-23">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":false,"lang":"zh-CN","comments":true,"permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-23.html","path":"nodejs/nodejs-note-23.html","title":"nodejs基础知识(13)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>nodejs基础知识(13) | Sun with no word
</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Sun with no word" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Sun with no word</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">something about what I have learned and some interesting things</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-vue"><a href="/vue" rel="section"><i class="fa fa-archive fa-fw"></i>vue</a></li><li class="menu-item menu-item-commonweal"><a href="/404.html" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#process-%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">process 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B-I-O-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.0.1.</span> <span class="nav-text">进程 I&#x2F;O 的注意事项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E7%A0%81"><span class="nav-number">1.0.2.</span> <span class="nav-text">退出码</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sun Jinkang"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Sun Jinkang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives">
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sunjinkang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sunjinkang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2060037942@qq.com" title="E-Mail → mailto:2060037942@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <img src="/images/backToTop.png" />
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/sunjinkang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner page posts-expand">


    
    
    
    <div class="post-block" lang="zh-CN"><header class="post-header post-top-background" id="id-post-top">

<h1 class="post-title" itemprop="name headline">nodejs基础知识(13)
</h1>

<div class="post-meta-container">
</div>

</header>

      
      
      <div class="post-body">
          <h4 id="process-进程"><a href="#process-进程" class="headerlink" title="process 进程"></a>process 进程</h4><p>‘beforeExit’ 事件<br>当 Node.js 清空其事件循环并且没有额外的工作要安排时，则会触发 ‘beforeExit’ 事件。 通常情况下，当没有工作要调度时，Node.js 进程会退出，但是注册在 ‘beforeExit’ 事件上的监听器可以进行异步的调用，从而使 Node.js 进程继续。</p>
<p>调用监听器回调函数时将 process.exitCode 的值作为唯一的参数传入。</p>
<p>对于导致显式终止的条件，例如调用 process.exit() 或未捕获的异常，则不会触发 ‘beforeExit’ 事件。</p>
<p>‘beforeExit’ 不应用作 ‘exit’ 事件的替代，除非打算安排额外的工作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;beforeExit&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Process beforeExit event with code: &#x27;</span>, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Process exit event with code: &#x27;</span>, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This message is displayed first.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印:</span></span><br><span class="line"><span class="comment">// This message is displayed first.</span></span><br><span class="line"><span class="comment">// Process beforeExit event with code: 0</span></span><br><span class="line"><span class="comment">// Process exit event with code: 0</span></span><br></pre></td></tr></table></figure>

<p>‘disconnect’ 事件#<br>如果 Node.js 进程是使用 IPC 通道衍生（参见子进程和集群文档），则在 IPC 通道关闭时将触发 ‘disconnect’ 事件。</p>
<p>‘exit’ 事件<br>code <integer><br>当 Node.js 进程由于以下任一原因即将退出时，则会触发 ‘exit’ 事件：</integer></p>
<ul>
<li>process.exit() 方法被显式调用；</li>
<li>Node.js 事件循环不再需要执行任何额外的工作。<br>此时没有办法阻止事件循环的退出，一旦所有 ‘exit’ 监听器都运行完毕，则 Node.js 进程将终止。<br>监听器回调函数使用 process.exitCode 属性指定的退出码或传给 process.exit() 方法的 exitCode 参数调用。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`About to exit with code: <span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
监听器函数必须只执行同步的操作。 Node.js 进程将在调用 ‘exit’ 事件监听器之后立即退出，从而使任何仍在事件循环中排队的其他工作被丢弃。 例如，在以下示例中，超时永远不会发生：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;exit&#x27;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This will not run&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>‘message’ 事件<br>message <Object> | <boolean> | <number> | <string> | <null> 解析的 JSON 对象或可序列化的原始值。<br>sendHandle &lt;net.Server&gt; | &lt;net.Socket&gt; net.Server 或 net.Socket 对象、或未定义。<br>如果 Node.js 进程是使用 IPC 通道衍生（参见子进程和集群文档），则每当子进程收到父进程使用 childprocess.send() 发送的消息时，就会触发 ‘message’ 事件。<br><em>消息经过序列化和解析。 结果消息可能与最初发送的消息不同。</em><br><em>如果在衍生进程时将 serialization 选项设置为 advanced，则 message 参数可以包含 JSON 无法表示的数据。</em></null></string></number></boolean></Object></p>
<p>‘rejectionHandled’ 事件<br>promise <Promise> 最近处理的 promise。<br>每当 Promise 被拒绝并且错误句柄被附加到它（例如使用 promise.catch()）晚于一轮 Node.js 事件循环时，则 ‘rejectionHandled’ 事件就会触发。</Promise></p>
<p>Promise 对象会在 ‘unhandledRejection’ 事件中先处理，但在处理过程中获得了拒绝句柄。<br>对于 Promise 链，没有始终可以处理拒绝的顶层概念。 由于本质上是异步的，Promise 拒绝可以在未来的某个时间点处理，可能比触发 ‘unhandledRejection’ 事件所需的事件循环轮询要晚得多。</p>
<p>另一种表述方式是，与同步代码中未处理的异常列表不断增长不同，promise 中未处理的拒绝列表可能会不断增长和缩小。</p>
<p>在同步代码中，当未处理的异常列表增长时，会触发 ‘uncaughtException’ 事件。<br>在异步代码中，当未处理的拒绝列表增长时，会触发 ‘unhandledRejection’ 事件，当未处理的拒绝列表缩小时，会触发 ‘rejectionHandled’ 事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unhandledRejections = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function">(<span class="params">reason, promise</span>) =&gt;</span> &#123;</span><br><span class="line">  unhandledRejections.<span class="title function_">set</span>(promise, reason);</span><br><span class="line">&#125;);</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;rejectionHandled&#x27;</span>, <span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">  unhandledRejections.<span class="title function_">delete</span>(promise);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，unhandledRejections Map 将随着时间的推移而增长和缩小，反映了开始未处理然后变成处理的拒绝。 可以定期在错误日志中记录此类错误（这可能最适合长时间运行的应用程序）或在进程退出时（这可能对脚本最方便）。</p>
<p>‘uncaughtException’ 事件<br>err <Error> 未捕获的异常。<br>origin <string> 指示异常是源自未处理的拒绝还是源自同步错误。 可以是 ‘uncaughtException’ 或 ‘unhandledRejection’。 后者用于在基于 Promise 的异步上下文中发生异常（或者如果 Promise 被拒绝）并且 –unhandled-rejections 标志设置为 strict 或 throw（这是默认值）并且拒绝未被处理，或者当拒绝发生在命令行入口点的 ES 模块静态加载阶段。<br>当未捕获的 JavaScript 异常一直冒泡回到事件循环时，则会触发 ‘uncaughtException’ 事件。 默认情况下，Node.js 通过将堆栈跟踪打印到 stderr 并以代码 1 退出，覆盖任何先前设置的 process.exitCode 来处理此类异常。 为 ‘uncaughtException’ 事件添加句柄会覆盖此默认行为。 或者，更改 ‘uncaughtException’ 处理程序中的 process.exitCode，这将导致进程以提供的退出码退出。 否则，在存在此类句柄的情况下，进程将以 0 退出。</string></Error></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtException&#x27;</span>, <span class="function">(<span class="params">err, origin</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.<span class="title function_">writeSync</span>(</span><br><span class="line">    process.<span class="property">stderr</span>.<span class="property">fd</span>,</span><br><span class="line">    <span class="string">`Caught exception: <span class="subst">$&#123;err&#125;</span>\n`</span> +</span><br><span class="line">    <span class="string">`Exception origin: <span class="subst">$&#123;origin&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This will still run.&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 故意引发异常，但不捕获。</span></span><br><span class="line"><span class="title function_">nonexistentFunc</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This will not run.&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>通过安装 ‘uncaughtExceptionMonitor’ 监听器，可以在不覆盖退出进程的默认行为的情况下监视 ‘uncaughtException’ 事件。</p>
<p>注意: 正确使用 ‘uncaughtException’<br>‘uncaughtException’ 是用于异常处理的粗略机制，仅用作最后的手段。 事件_不应该_用作 On Error Resume Next 的等价物。 未处理的异常本质上意味着应用程序处于未定义状态。 在没有从异常中正确恢复的情况下尝试恢复应用程序代码可能会导致其他不可预见和不可预测的问题。</p>
<p>从事件句柄中抛出的异常将不会被捕获。 而是，该进程将以非零退出码退出，并将打印堆栈跟踪。 这是为了避免无限递归。</p>
<p>尝试在未捕获异常后正常恢复类似于升级计算机时拔掉电源线。 十有八九，什么都没有发生。 但是第十次，系统损坏了。</p>
<p>‘uncaughtException’ 的正确用法是在关闭进程之前对分配的资源（例如文件描述符、句柄等）执行同步清理。 在 ‘uncaughtException’ 之后恢复正常操作是不安全的。</p>
<p>为了以更可靠的方式重新启动崩溃的应用程序，无论 ‘uncaughtException’ 是否触发，都应该在单独的进程中使用外部监视器来检测应用程序故障并根据需要恢复或重新启动。</p>
<p>‘uncaughtExceptionMonitor’ 事件<br>err <Error> 未捕获的异常。<br>origin <string> 指示异常是源自未处理的拒绝还是源自同步错误。 可以是 ‘uncaughtException’ 或 ‘unhandledRejection’。 后者用于在基于 Promise 的异步上下文中发生异常（或者如果 Promise 被拒绝）并且 –unhandled-rejections 标志设置为 strict 或 throw（这是默认值）并且拒绝未被处理，或者当拒绝发生在命令行入口点的 ES 模块静态加载阶段。<br>‘uncaughtExceptionMonitor’ 事件在 ‘uncaughtException’ 事件触发或通过 process.setUncaughtExceptionCaptureCallback() 安装的钩子被调用之前触发。</string></Error></p>
<p>一旦触发 ‘uncaughtException’ 事件，则安装 ‘uncaughtExceptionMonitor’ 监听器不会更改行为。 如果没有安装 ‘uncaughtException’ 监听器，则进程仍然会崩溃。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;uncaughtExceptionMonitor&#x27;</span>, <span class="function">(<span class="params">err, origin</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title class_">MyMonitoringTool</span>.<span class="title function_">logSync</span>(err, origin);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 故意引发异常，但不捕获。</span></span><br><span class="line"><span class="title function_">nonexistentFunc</span>();</span><br><span class="line"><span class="comment">// 仍然崩溃 Node.js</span></span><br></pre></td></tr></table></figure>

<p>‘unhandledRejection’ 事件<br>reason <Error> | <any> Promise 被拒绝的对象（通常是 Error 对象）。<br>promise <Promise> 被拒绝的 promise。<br>每当 Promise 被拒绝并且在事件循环的一个轮询内没有错误句柄附加到承诺时，则会触发 ‘unhandledRejection’ 事件。 使用 Promise 进行编程时，异常被封装为“被拒绝的 promise”。 拒绝可以使用 promise.catch() 捕获和处理，并通过 Promise 链传播。 ‘unhandledRejection’ 事件对于检测和跟踪尚未处理的被拒绝的 promise 很有用。</Promise></any></Error></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;unhandledRejection&#x27;</span>, <span class="function">(<span class="params">reason, promise</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Unhandled Rejection at:&#x27;</span>, promise, <span class="string">&#x27;reason:&#x27;</span>, reason);</span><br><span class="line">  <span class="comment">// 应用程序特定的日志记录，在此处抛出错误或其他逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reportToUser</span>(<span class="title class_">JSON</span>.<span class="title function_">pasre</span>(res)); <span class="comment">// 注意错别字 (`pasre`)</span></span><br><span class="line">&#125;); <span class="comment">// 无 `.catch()` 或 `.then()`</span></span><br><span class="line"><span class="comment">// 以下也将触发 &#x27;unhandledRejection&#x27; 事件被触发：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SomeResource</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 最初将加载状态设置为被拒绝的 promise</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">loaded</span> = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Resource not yet loaded!&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resource = <span class="keyword">new</span> <span class="title class_">SomeResource</span>();</span><br><span class="line"><span class="comment">// resource.loaded 上没有 .catch 或 .then</span></span><br></pre></td></tr></table></figure>
<p>在此示例情况下，可以将拒绝作为开发人员错误进行跟踪，这通常是其他 ‘unhandledRejection’ 事件的情况。 为了解决此类故障，可以将非操作 .catch(() =&gt; { }) 句柄附加到 resource.loaded，这将阻止触发 ‘unhandledRejection’ 事件。</p>
<p>‘warning’ 事件<br>warning <Error> 警告的主要属性是：</Error></p>
<ul>
<li>name <string> 警告的名称。 默认值: ‘Warning’。</string></li>
<li>message <string> 系统提供的警告描述。</string></li>
<li>stack <string> 代码中发出警告的位置的堆栈跟踪。<br>每当 Node.js 触发进程警告时，则会触发 ‘warning’ 事件。</string></li>
</ul>
<p>进程警告类似于错误，因为其描述了引起用户注意的异常情况。 但是，警告不是正常 Node.js 和 JavaScript 错误处理流程的一部分。 Node.js 可以在检测到可能导致次优应用程序性能、错误或安全漏洞的不良编码实践时触发警告。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;warning&#x27;</span>, <span class="function">(<span class="params">warning</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">name</span>);    <span class="comment">// 打印警告名称</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">message</span>); <span class="comment">// 打印警告信息</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">stack</span>);   <span class="comment">// 打印堆栈跟踪</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>默认情况下，Node.js 会将进程警告打印到 stderr。 –no-warnings 命令行选项可用于抑制默认控制台输出，但 ‘warning’ 事件仍将由 process 对象触发。</p>
<p>以下示例说明了在向事件添加过多监听器时打印到 stderr 的警告：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; events.<span class="property">defaultMaxListeners</span> = <span class="number">1</span>;</span><br><span class="line">&gt; process.<span class="title function_">on</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&gt; process.<span class="title function_">on</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&gt; (<span class="attr">node</span>:<span class="number">38638</span>) <span class="title class_">MaxListenersExceededWarning</span>: <span class="title class_">Possible</span> <span class="title class_">EventEmitter</span> memory leak</span><br><span class="line"><span class="comment">// detected. 2 foo listeners added. Use emitter.setMaxListeners() to increase limit</span></span><br></pre></td></tr></table></figure>
<p>相比之下，以下示例关闭默认警告输出并向 ‘warning’ 事件添加自定义句柄：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node --no-warnings</span><br><span class="line">&gt; <span class="keyword">const</span> p = process.<span class="title function_">on</span>(<span class="string">&#x27;warning&#x27;</span>, <span class="function">(<span class="params">warning</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Do not do that!&#x27;</span>));</span><br><span class="line">&gt; events.<span class="property">defaultMaxListeners</span> = <span class="number">1</span>;</span><br><span class="line">&gt; process.<span class="title function_">on</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&gt; process.<span class="title function_">on</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&gt; <span class="title class_">Do</span> not <span class="keyword">do</span> that!</span><br></pre></td></tr></table></figure>

<p>–trace-warnings 命令行选项可用于使警告的默认控制台输出包括警告的完整堆栈跟踪。<br>使用 –throw-deprecation 命令行标志启动 Node.js 将导致自定义弃用警告作为异常抛出。<br>使用 –trace-deprecation 命令行标志将导致自定义弃用与堆栈跟踪一起打印到 stderr。<br>使用 –no-deprecation 命令行标志将抑制自定义弃用的所有报告。<br>*-deprecation 命令行标志仅影响使用名称 ‘DeprecationWarning’ 的警告。</p>
<p>‘worker’ 事件<br>worker <Worker> 创建的 <Worker>。<br>创建新的 <Worker> 线程后会触发 ‘worker’ 事件。</Worker></Worker></Worker></p>
<p>触发自定义的告警<br>请参阅 process.emitWarning() 方法以发出自定义或特定于应用程序的警告。</p>
<p>Node.js 警告的名称<br>Node.js 触发的警告类型（由 name 属性标识）没有严格的指导方针。 可以随时添加新类型的警告。 一些最常见的警告类型包括：</p>
<p>‘DeprecationWarning’ - 表示使用已弃用的 Node.js API 或功能。 此类警告必须包含标识弃用代码的 ‘code’ 属性。<br>‘ExperimentalWarning’ - 表示使用实验的 Node.js API 或功能。 必须谨慎使用此类功能，因为它们可能随时更改，并且不受与受支持功能相同的严格语义版本控制和长期支持政策的约束。<br>‘MaxListenersExceededWarning’ - 表示在 EventEmitter 或 EventTarget 上注册了太多给定事件的监听器。 这通常表示内存泄漏。<br>‘TimeoutOverflowWarning’ - 表示已向 setTimeout() 或 setInterval() 函数提供了无法容纳在 32 位有符号整数内的数值。<br>‘UnsupportedWarning’ - 表示使用不受支持的选项或功能，这些选项或功能将被忽略而不是被视为错误。 一个示例是在使用 HTTP/2 兼容性 API 时使用 HTTP 响应状态消息。</p>
<p>信号事件<br>当 Node.js 进程收到信号时，则将触发信号事件。 有关标准 POSIX 信号名称（例如 ‘SIGINT’、’SIGHUP’ 等）的列表，请参阅 signal(7)。</p>
<p>信号在 Worker 线程上不可用。<br>信号句柄将接收信号的名称（’SIGINT’、’SIGTERM’ 等）作为第一个参数。<br>每个事件的名称将是信号的大写通用名称（例如 ‘SIGINT’ 表示 SIGINT 信号）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从标准输入开始读取，因此进程不会退出。</span></span><br><span class="line">process.<span class="property">stdin</span>.<span class="title function_">resume</span>();</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;SIGINT&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received SIGINT. Press Control-D to exit.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单个函数处理多个信号</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handle</span>(<span class="params">signal</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received <span class="subst">$&#123;signal&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;SIGINT&#x27;</span>, handle);</span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;SIGTERM&#x27;</span>, handle);</span><br></pre></td></tr></table></figure>
<p>‘SIGUSR1’ 由 Node.js 预留以启动调试器。 可以安装监听器，但这样做可能会干扰调试器。<br>‘SIGTERM’ 和 ‘SIGINT’ 在非 Windows 平台上具有默认的句柄，其在使用代码 128 + signal number 退出之前重置终端模式。 如果这些信号之一安装了监听器，则其默认行为将被删除（Node.js 将不再退出）。<br>‘SIGPIPE’ 默认情况下忽略。 它可以安装监听器。<br>‘SIGHUP’ 在 Windows 上是在关闭控制台窗口时生成，在其他平台上是在各种类似条件下生成。 参见 signal(7)。 它可以安装监听器，但是 Node.js 将在大约 10 秒后被 Windows 无条件地终止。 在非 Windows 平台上，SIGHUP 的默认行为是终止 Node.js，但一旦安装了监听器，则其默认行为将被删除。<br>‘SIGTERM’ Windows 上不支持，可以监听。<br>所有平台都支持来自终端的 ‘SIGINT’，通常可以使用 Ctrl+C 生成（但是这是可配置的）。 当启用终端原始模式并使用 Ctrl+C 时不会生成它。<br>‘SIGBREAK’ 在 Windows 上，当按下 Ctrl+Break 时会发送。 在非 Windows 平台上，它可以被监听，但无法发送或生成它。<br>‘SIGWINCH’ 当调整控制台大小时会发送。 在 Windows 上，这只会发生在当光标移动时写入控制台，或者当在原始模式下使用可读的终端时。<br>‘SIGKILL’ 不能安装监听器，它会无条件地终止所有平台上的 Node.js。<br>‘SIGSTOP’ 不能安装监听器。<br>‘SIGBUS’、’SIGFPE’、’SIGSEGV’ 和 ‘SIGILL’，当不使用 kill(2) 人为引发时，本质上会使进程处于调用 JS 监听器不安全的状态。 这样做可能会导致进程停止响应。<br>0 可以发送来测试进程是否存在，如果进程存在则没影响，如果进程不存在则抛出错误。<br>Windows 不支持信号，因此没有等价的使用信号来终止，但 Node.js 提供了一些对 process.kill() 和 subprocess.kill() 的模拟：<br>发送 SIGINT、SIGTERM、和 SIGKILL 会导致目标进程无条件的终止，之后子进程会报告进程被信号终止。<br>发送信号 0 可以作为独立于平台的方式来测试进程是否存在。</p>
<p>process.abort()<br>process.abort() 方法会导致 Node.js 进程立即退出并生成一个核心文件。<br><em>此特性在 Worker 线程中不可用。</em></p>
<p>process.allowedNodeEnvironmentFlags<br>process.allowedNodeEnvironmentFlags 属性是 NODE_OPTIONS 环境变量中允许的特殊的只读 Set 标志。</p>
<p>process.allowedNodeEnvironmentFlags 继承了 Set，但覆盖了 Set.prototype.has 以识别几种不同的可能标志表示。 在以下情况下，process.allowedNodeEnvironmentFlags.has() 将返回 true：</p>
<ul>
<li>标志可以省略前导单（-）或双（–）破折号；例如，inspect-brk 代表 –inspect-brk，或 r 代表 -r。</li>
<li>传给 V8 的标志（如 –v8-options 中所列）可能会替换一个或多个_非前导_破折号作为下划线，反之亦然；例如，–perf_basic_prof、–perf-basic-prof、–perf_basic-prof 等。</li>
<li>标志可能包含一个或多个等于 (=) 字符；在第一个等号之后并包括在内的所有字符都将被忽略；例如，–stack-trace-limit=100。</li>
<li>标志_必须_在 NODE_OPTIONS 中是允许的。</li>
</ul>
<p>在 process.allowedNodeEnvironmentFlags 上迭代时，标志只会出现_一次_；每个都以一个或多个破折号开头。 传给 V8 的标志将包含下划线而不是非前导破折号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; allowedNodeEnvironmentFlags &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">allowedNodeEnvironmentFlags.<span class="title function_">forEach</span>(<span class="function">(<span class="params">flag</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// -r</span></span><br><span class="line">  <span class="comment">// --inspect-brk</span></span><br><span class="line">  <span class="comment">// --abort_on_uncaught_exception</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// process.allowedNodeEnvironmentFlags 的方法 add()、clear() 和 delete() 什么都不做，会静默失败。</span></span><br></pre></td></tr></table></figure>
<p>如果 Node.js 编译时_没有_ NODE_OPTIONS 支持（显示在 process.config 中），那么 process.allowedNodeEnvironmentFlags 将包含_本来_允许的内容。</p>
<p>process.arch<br>为其编译 Node.js 二进制文件的操作系统 CPU 架构。 可能的值为：’arm’、’arm64’、’ia32’、’mips’、’mipsel’、’ppc’、’ppc64’、’s390’、’s390x’、以及 ‘x64’。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; arch &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`This processor architecture is <span class="subst">$&#123;arch&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>process.argv<br>process.argv 属性返回数组，其中包含启动 Node.js 进程时传入的命令行参数。 第一个元素将是 process.execPath。 如果需要访问 argv[0] 的原始值，请参阅 process.argv0。 第二个元素将是正在执行的 JavaScript 文件的路径。 其余元素将是任何其他命令行参数。</p>
<p>例如，假设 process-args.js 有以下脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; argv &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 process.argv</span></span><br><span class="line">argv.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;index&#125;</span>: <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以如下方式启动 Node.js 进程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ node process-args.<span class="property">js</span> one two=three four</span><br><span class="line">将生成输出：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: <span class="regexp">/usr/</span>local/bin/node</span><br><span class="line"><span class="number">1</span>: <span class="regexp">/Users/m</span>jr/work/node/process-args.<span class="property">js</span></span><br><span class="line"><span class="number">2</span>: one</span><br><span class="line"><span class="number">3</span>: two=three</span><br><span class="line"><span class="number">4</span>: four</span><br></pre></td></tr></table></figure>

<p>process.argv0<br>process.argv0 属性存储了 Node.js 启动时传入的 argv[0] 原始值的只读副本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ bash -c <span class="string">&#x27;exec -a customArgv0 ./node&#x27;</span></span><br><span class="line">&gt; process.<span class="property">argv</span>[<span class="number">0</span>]</span><br><span class="line"><span class="string">&#x27;/Volumes/code/external/node/out/Release/node&#x27;</span></span><br><span class="line">&gt; process.<span class="property">argv0</span></span><br><span class="line"><span class="string">&#x27;customArgv0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>process.channel<br>如果 Node.js 进程是使用 IPC 通道衍生（参见子进程文档），则 process.channel 属性是对 IPC 通道的引用。 如果不存在 IPC 通道，则此属性为 undefined。</p>
<p>process.channel.ref()<br>如果之前已调用过 .unref()，则此方法使 IPC 通道保持进程的事件循环运行。<br>通常，这是通过 process 对象上的 ‘disconnect’ 和 ‘message’ 监听器的数量来管理的。 但是，此方法可用于显式请求特定行为。</p>
<p>process.channel.unref()<br>此方法使 IPC 通道不会保持进程的事件循环运行，并且即使在通道打开时也让它完成。<br>通常，这是通过 process 对象上的 ‘disconnect’ 和 ‘message’ 监听器的数量来管理的。 但是，此方法可用于显式请求特定行为。</p>
<p>process.chdir(directory)<br>directory <string><br>process.chdir() 方法更改 Node.js 进程的当前工作目录，如果失败则抛出异常（例如，如果指定的 directory 不存在）。</string></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; chdir, cwd &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Starting directory: <span class="subst">$&#123;cwd()&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="title function_">chdir</span>(<span class="string">&#x27;/tmp&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`New directory: <span class="subst">$&#123;cwd()&#125;</span>`</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`chdir: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此特性在 Worker 线程中不可用。</p>
<p>process.config<br>process.config 属性返回 Object，其中包含用于编译当前 Node.js 可执行文件的配置选项的 JavaScript 表示。 这与运行 ./configure 脚本时生成的 config.gypi 文件相同。<br>可能的输出示例如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">target_defaults</span>:</span><br><span class="line">   &#123; <span class="attr">cflags</span>: [],</span><br><span class="line">     <span class="attr">default_configuration</span>: <span class="string">&#x27;Release&#x27;</span>,</span><br><span class="line">     <span class="attr">defines</span>: [],</span><br><span class="line">     <span class="attr">include_dirs</span>: [],</span><br><span class="line">     <span class="attr">libraries</span>: [] &#125;,</span><br><span class="line">  <span class="attr">variables</span>:</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">host_arch</span>: <span class="string">&#x27;x64&#x27;</span>,</span><br><span class="line">     <span class="attr">napi_build_version</span>: <span class="number">5</span>,</span><br><span class="line">     <span class="attr">node_install_npm</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">     <span class="attr">node_prefix</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">     <span class="attr">node_shared_cares</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">     <span class="attr">node_shared_http_parser</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">     <span class="attr">node_shared_libuv</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">     <span class="attr">node_shared_zlib</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">     <span class="attr">node_use_dtrace</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">     <span class="attr">node_use_openssl</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">     <span class="attr">node_shared_openssl</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">     <span class="attr">strict_aliasing</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">     <span class="attr">target_arch</span>: <span class="string">&#x27;x64&#x27;</span>,</span><br><span class="line">     <span class="attr">v8_use_snapshot</span>: <span class="number">1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>process.config 属性是非只读的，并且生态系统中存在已知扩展、修改或完全替换 process.config 值的现有模块。<br><em>修改 process.config 属性或 process.config 对象的任何子属性已被弃用。 在未来的版本中，process.config 将变为只读。</em></p>
<p>process.connected<br>如果 Node.js 进程使用 IPC 通道衍生（参见子进程和集群文档），则只要 IPC 通道连接，process.connected 属性将返回 true，并在调用 process.disconnect() 后返回 false。<br>一旦 process.connected 为 false，就不能再使用 process.send() 通过 IPC 通道发送消息。</p>
<p>process.cpuUsage([previousValue])#<br>previousValue <Object> 先前调用 process.cpuUsage() 的返回值<br>返回: <Object></Object></Object></p>
<ul>
<li>user <integer></integer></li>
<li>system <integer><br>process.cpuUsage() 方法在具有属性 user 和 system 的对象中返回当前进程的用户和系统 CPU 时间使用情况，其值为微秒值（百万分之一秒）。 这些值分别测量在用户和系统代码中花费的时间，如果多个 CPU 内核为此进程执行工作，则最终可能会大于实际经过的时间。</integer></li>
</ul>
<p>先前调用 process.cpuUsage() 的结果可以作为参数传给函数，以获取差异读数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cpuUsage &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startUsage = <span class="title function_">cpuUsage</span>();</span><br><span class="line"><span class="comment">// &#123; user: 38579, system: 6986 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 CPU 旋转 500 毫秒</span></span><br><span class="line"><span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - now &lt; <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cpuUsage</span>(startUsage));</span><br><span class="line"><span class="comment">// &#123; user: 514883, system: 11226 &#125;</span></span><br></pre></td></tr></table></figure>

<p>process.cwd()<br>process.cwd() 方法返回 Node.js 进程的当前工作目录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cwd &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Current directory: <span class="subst">$&#123;cwd()&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>process.debugPort<br>启用时 Node.js 调试器使用的端口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="property">debugPort</span> = <span class="number">5858</span>;</span><br></pre></td></tr></table></figure>

<p>process.disconnect()<br>如果 Node.js 进程是使用 IPC 通道衍生（参见子进程和集群文档），则 process.disconnect() 方法将关闭通往父进程的 IPC 通道，一旦没有其他连接使其保持活动状态，则允许子进程正常退出。<br>调用 process.disconnect() 的效果和从父进程调用 ChildProcess.disconnect() 是一样的。<br>如果 Node.js 进程不是使用 IPC 通道衍生，则 process.disconnect() 将是 undefined。</p>
<p>process.dlopen(module, filename[, flags])</p>
<ul>
<li>module <Object></Object></li>
<li>filename <string></string></li>
<li>flags &lt;os.constants.dlopen&gt; 默认值: os.constants.dlopen.RTLD_LAZY<br>process.dlopen() 方法允许动态加载共享对象。 require() 主要用于加载 C++ 插件，除非特殊情况，否则不应直接使用。 换句话说，require() 应该优先于 process.dlopen()，除非有特定的原因，例如自定义 dlopen 标志或从 ES 模块加载。</li>
</ul>
<p>flags 参数是整数，允许指定 dlopen 行为。 有关详细信息，请参阅 os.constants.dlopen 文档。<br>调用 process.dlopen() 时的一个重要要求是必须传入 module 实例。 然后可以通过 module.exports 访问由 C++ 插件导出的函数。</p>
<p>下面的示例显示了如何加载名为 local.node 的 C++ 插件，该插件导出 foo 函数。 通过传入 RTLD_NOW 常量，在调用返回之前加载所有符号。 在此示例中，假定常量可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dlopen &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; constants &#125; <span class="keyword">from</span> <span class="string">&#x27;node:os&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;node:url&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;;</span><br><span class="line"><span class="title function_">dlopen</span>(<span class="variable language_">module</span>, <span class="title function_">fileURLToPath</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;local.node&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>)),</span><br><span class="line">       constants.<span class="property">dlopen</span>.<span class="property">RTLD_NOW</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>process.emitWarning(warning[, options])<br>warning <string> | <Error> 要触发的警告。<br>options <Object></Object></Error></string></p>
<ul>
<li>type <string> 当 warning 是 String 时，type 是用于触发警告的 type 的名称。 默认值: ‘Warning’。</string></li>
<li>code <string> 触发的警告实例的唯一标识符。</string></li>
<li>ctor <Function> 当 warning 为 String 时，ctor 是可选函数，用于限制生成的堆栈跟踪。 默认值: process.emitWarning。</Function></li>
<li>detail <string> 要包含在错误中的额外文本。<br>process.emitWarning() 方法可用于触发自定义或特定于应用程序的进程警告。 这些可以通过向 ‘warning’ 事件添加句柄来监听。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; emitWarning &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发带有代码和其他详细信息的警告。</span></span><br><span class="line"><span class="title function_">emitWarning</span>(<span class="string">&#x27;Something happened!&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="string">&#x27;MY_WARNING&#x27;</span>,</span><br><span class="line">  <span class="attr">detail</span>: <span class="string">&#x27;This is some additional information&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 触发:</span></span><br><span class="line"><span class="comment">// (node:56338) [MY_WARNING] Warning: Something happened!</span></span><br><span class="line"><span class="comment">// This is some additional information</span></span><br></pre></td></tr></table></figure>
在此示例中，Error 对象由 process.emitWarning() 在内部生成并传给 ‘warning’ 句柄。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;warning&#x27;</span>, <span class="function">(<span class="params">warning</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">name</span>);    <span class="comment">// &#x27;Warning&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">message</span>); <span class="comment">// &#x27;Something happened!&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">code</span>);    <span class="comment">// &#x27;MY_WARNING&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">stack</span>);   <span class="comment">// Stack trace</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">detail</span>);  <span class="comment">// &#x27;This is some additional information&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
如果 warning 作为 Error 对象传入，则忽略 options 参数。</string></li>
</ul>
<p>process.emitWarning(warning[, type[, code]][, ctor])</p>
<ul>
<li>warning <string> | <Error> 要触发的警告。</Error></string></li>
<li>type <string> 当 warning 是 String 时，type 是用于触发警告的 type 的名称。 默认值: ‘Warning’。</string></li>
<li>code <string> 触发的警告实例的唯一标识符。</string></li>
<li>ctor <Function> 当 warning 为 String 时，ctor 是可选函数，用于限制生成的堆栈跟踪。 默认值: process.emitWarning。<br>process.emitWarning() 方法可用于触发自定义或特定于应用程序的进程警告。 这些可以通过向 ‘warning’ 事件添加句柄来监听。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; emitWarning &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字符串触发警告。</span></span><br><span class="line"><span class="title function_">emitWarning</span>(<span class="string">&#x27;Something happened!&#x27;</span>);</span><br><span class="line"><span class="comment">// 触发: (node: 56338) Warning: Something happened!</span></span><br><span class="line"><span class="keyword">import</span> &#123; emitWarning &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用字符串和类型触发警告。</span></span><br><span class="line"><span class="title function_">emitWarning</span>(<span class="string">&#x27;Something Happened!&#x27;</span>, <span class="string">&#x27;CustomWarning&#x27;</span>);</span><br><span class="line"><span class="comment">// 触发: (node:56338) CustomWarning: Something Happened!</span></span><br><span class="line"><span class="keyword">import</span> &#123; emitWarning &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">emitWarning</span>(<span class="string">&#x27;Something happened!&#x27;</span>, <span class="string">&#x27;CustomWarning&#x27;</span>, <span class="string">&#x27;WARN001&#x27;</span>);</span><br><span class="line"><span class="comment">// 触发: (node:56338) [WARN001] CustomWarning: Something happened!</span></span><br></pre></td></tr></table></figure>
在前面的每个示例中，Error 对象由 process.emitWarning() 在内部生成并传给 ‘warning’ 句柄。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;warning&#x27;</span>, <span class="function">(<span class="params">warning</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">message</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">code</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(warning.<span class="property">stack</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
如果 warning 作为 Error 对象传入，则它将被不加修改地传给 ‘warning’ 事件句柄（并且可选的 type、code 和 ctor 参数将被忽略）：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; emitWarning &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Error 对象触发警告。</span></span><br><span class="line"><span class="keyword">const</span> myWarning = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Something happened!&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用错误名称属性指定类型名称</span></span><br><span class="line">myWarning.<span class="property">name</span> = <span class="string">&#x27;CustomWarning&#x27;</span>;</span><br><span class="line">myWarning.<span class="property">code</span> = <span class="string">&#x27;WARN001&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">emitWarning</span>(myWarning);</span><br><span class="line"><span class="comment">// 触发: (node:56338) [WARN001] CustomWarning: Something happened!</span></span><br></pre></td></tr></table></figure>
如果 warning 不是字符串或 Error 对象，则抛出 TypeError。<br>虽然进程警告使用 Error 对象，但进程警告机制不是替代正常错误处理机制。<br>如果警告 type 为 ‘DeprecationWarning’，则执行以下额外处理：</Function></li>
<li>如果使用 –throw-deprecation 命令行标志，则弃用警告将作为异常抛出，而不是作为事件触发。</li>
<li>如果使用 –no-deprecation 命令行标志，则会取消弃用警告。</li>
<li>如果使用 –trace-deprecation 命令行标志，则弃用警告将与完整堆栈跟踪一起打印到 stderr。</li>
</ul>
<p>避免重复警告<br>作为最佳实践，每个进程只应触发一次警告。 为此，则将 emitWarning() 放在布尔值后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; emitWarning &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">emitMyWarning</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!emitMyWarning.<span class="property">warned</span>) &#123;</span><br><span class="line">    emitMyWarning.<span class="property">warned</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="title function_">emitWarning</span>(<span class="string">&#x27;Only warn once!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">emitMyWarning</span>();</span><br><span class="line"><span class="comment">// 触发: (node: 56339) Warning: Only warn once!</span></span><br><span class="line"><span class="title function_">emitMyWarning</span>();</span><br><span class="line"><span class="comment">// 什么都不触发</span></span><br></pre></td></tr></table></figure>

<p>process.env<br>process.env 属性返回包含用户环境的对象。 参见 environ(7)。</p>
<p>此对象的示例如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">TERM</span>: <span class="string">&#x27;xterm-256color&#x27;</span>,</span><br><span class="line">  <span class="attr">SHELL</span>: <span class="string">&#x27;/usr/local/bin/bash&#x27;</span>,</span><br><span class="line">  <span class="attr">USER</span>: <span class="string">&#x27;maciej&#x27;</span>,</span><br><span class="line">  <span class="attr">PATH</span>: <span class="string">&#x27;~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&#x27;</span>,</span><br><span class="line">  <span class="attr">PWD</span>: <span class="string">&#x27;/Users/maciej&#x27;</span>,</span><br><span class="line">  <span class="attr">EDITOR</span>: <span class="string">&#x27;vim&#x27;</span>,</span><br><span class="line">  <span class="attr">SHLVL</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  <span class="attr">HOME</span>: <span class="string">&#x27;/Users/maciej&#x27;</span>,</span><br><span class="line">  <span class="attr">LOGNAME</span>: <span class="string">&#x27;maciej&#x27;</span>,</span><br><span class="line">  <span class="attr">_</span>: <span class="string">&#x27;/usr/local/bin/node&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以修改此对象，但此类修改不会反映在 Node.js 进程之外，或反映到其他 Worker 线程（除非显示请求）。 换句话说，以下示例将不起作用：</p>
<p>$ node -e ‘process.env.foo = “bar”‘ &amp;&amp; echo $foo<br>但是以下示例则将起作用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; env &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">env.<span class="property">foo</span> = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(env.<span class="property">foo</span>);</span><br></pre></td></tr></table></figure>
<p>在 process.env 上分配属性会将值隐式转换为字符串。 此行为已弃用。 当值不是字符串、数字或布尔值时，Node.js 的未来版本可能会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; env &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">env.<span class="property">test</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(env.<span class="property">test</span>);</span><br><span class="line"><span class="comment">// =&gt; &#x27;null&#x27;</span></span><br><span class="line">env.<span class="property">test</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(env.<span class="property">test</span>);</span><br><span class="line"><span class="comment">// =&gt; &#x27;undefined&#x27;</span></span><br><span class="line"><span class="comment">// 使用 delete 从 process.env 中删除属性。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; env &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">env.<span class="property">TEST</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> env.<span class="property">TEST</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(env.<span class="property">TEST</span>);</span><br><span class="line"><span class="comment">// =&gt; undefined</span></span><br><span class="line"><span class="comment">// 在 Windows 操作系统上，环境变量不区分大小写。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; env &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">env.<span class="property">TEST</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(env.<span class="property">test</span>);</span><br><span class="line"><span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>除非在创建 Worker 实例时显式地指定，否则每个 Worker 线程都有自己的 process.env 副本，基于其父线程的 process.env，或任何指定为 Worker 构造函数的 env 选项。 对 process.env 的更改不会跨 Worker 线程可见，只有主线程可以进行对操作系统或原生插件可见的更改。</p>
<p>process.execArgv<br>process.execArgv 属性返回 Node.js 进程启动时传入的一组特定于 Node.js 的命令行选项。<br><strong>这些选项不会出现在 process.argv 属性返回的数组中，也不包括 Node.js 可执行文件、脚本名称或脚本名称后面的任何选项。 这些选项可用于衍生与父进程具有相同执行环境的子进程。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node --harmony script.<span class="property">js</span> --version</span><br><span class="line">process.<span class="property">execArgv</span> 的结果：</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;--harmony&#x27;</span>]</span><br><span class="line">process.<span class="property">argv</span> 的结果：</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;/usr/local/bin/node&#x27;</span>, <span class="string">&#x27;script.js&#x27;</span>, <span class="string">&#x27;--version&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>有关具有此属性的工作线程的详细行为，请参阅 Worker 构造函数。</p>
<p>process.execPath<br>process.execPath 属性返回启动 Node.js 进程的可执行文件的绝对路径名。 符号链接（如果有）会被解析。</p>
<p>process.exit([code])<br>code <integer> 退出码。 默认值: 0。<br>process.exit() 方法指示 Node.js 以 code 的退出状态同步终止进程。 如果省略 code，则退出将使用“成功”代码 0 或 process.exitCode 的值（如果已设置）。 直到所有 ‘exit’ 事件监听器都被调用，Node.js 才会终止。</integer></p>
<p>以“失败”代码退出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; exit &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">exit</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>执行 Node.js 的 shell 应该看到退出码为 1。<br>调用 process.exit() 将强制进程尽快退出，即使仍有未完全完成的异步操作挂起，包括对 process.stdout 和 process.stderr 的 I/O 操作。</p>
<p>在大多数情况下，实际上没有必要显式调用 process.exit()。 如果事件循环中没有其他待处理的工作，则 Node.js 进程将自行退出。 可以设置 process.exitCode 属性来告诉进程在进程正常退出时使用哪个退出码。</p>
<p>例如，以下示例说明了 process.exit() 方法的误用，其可能导致打印到标准输出的数据被截断和丢失：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; exit &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是不该做的示例：</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">someConditionNotMet</span>()) &#123;</span><br><span class="line">  <span class="title function_">printUsageToStdout</span>();</span><br><span class="line">  <span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是有问题的原因是因为在 Node.js 中写入 process.stdout 有时是异步的，并且可能发生在 Node.js 事件循环的多个滴答上。 但是，调用 process.exit() 会强制进程在执行对 stdout 的其他写入之前退出。</p>
<p>代码应该设置 process.exitCode 并通过避免为事件循环安排任何额外工作来允许进程自然退出，而不是直接调用 process.exit()：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何正确设置退出码，同时让进程正常退出。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">someConditionNotMet</span>()) &#123;</span><br><span class="line">  <span class="title function_">printUsageToStdout</span>();</span><br><span class="line">  process.<span class="property">exitCode</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果由于错误情况需要终止 Node.js 进程，则抛出未捕获的错误并允许进程相应地终止比调用 process.exit() 更安全。<br>在 Worker 线程中，该函数停止当前线程而不是当前进程。</p>
<p>process.exitCode<br>当进程正常退出或通过 process.exit() 退出而不指定代码时，将作为进程退出码的数字。<br>将代码指定为 process.exit(code) 将覆盖 process.exitCode 的任何先前设置。</p>
<p>process.getActiveResourcesInfo()<br>process.getActiveResourcesInfo() 方法返回字符串数组，其中包含当前保持事件循环活动的活动资源的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getActiveResourcesInfo &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="built_in">setTimeout</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;node:timers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Before:&#x27;</span>, <span class="title function_">getActiveResourcesInfo</span>());</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;&#125;, <span class="number">1000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;After:&#x27;</span>, <span class="title function_">getActiveResourcesInfo</span>());</span><br><span class="line"><span class="comment">// 打印:</span></span><br><span class="line"><span class="comment">//   Before: [ &#x27;CloseReq&#x27;, &#x27;TTYWrap&#x27;, &#x27;TTYWrap&#x27;, &#x27;TTYWrap&#x27; ]</span></span><br><span class="line"><span class="comment">//   After: [ &#x27;CloseReq&#x27;, &#x27;TTYWrap&#x27;, &#x27;TTYWrap&#x27;, &#x27;TTYWrap&#x27;, &#x27;Timeout&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>process.getegid()<br>process.getegid() 方法返回 Node.js 进程的数字有效群组标识。 （见 getegid(2)。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">getegid</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Current gid: <span class="subst">$&#123;process.getegid()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。</em></p>
<p>process.geteuid()<br>process.geteuid() 方法返回进程的数字有效用户身份。 （见 geteuid(2)。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">geteuid</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Current uid: <span class="subst">$&#123;process.geteuid()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。</em></p>
<p>process.getgid()<br>process.getgid() 方法返回进程的数字群组标识。 （见 getgid(2)。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">getgid</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Current gid: <span class="subst">$&#123;process.getgid()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。</p>
<p>process.getgroups()<br>process.getgroups() 方法返回带有补充组 ID 的数组。 POSIX 不指定是否包含有效组 ID，但 Node.js 确保它始终包含。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">getgroups</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="title function_">getgroups</span>()); <span class="comment">// [ 16, 21, 297 ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。</p>
<p>process.getuid()<br>process.getuid() 方法返回进程的数字用户标识。 （见 getuid(2)。）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">getuid</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Current uid: <span class="subst">$&#123;process.getuid()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。</p>
<p>process.hasUncaughtExceptionCaptureCallback()<br>指示是否已使用 process.setUncaughtExceptionCaptureCallback() 设置回调。</p>
<p>process.hrtime([time])<br>time &lt;integer[]&gt; 先前调用 process.hrtime() 的结果<br>返回: &lt;integer[]&gt;<br>这是 process.hrtime.bigint() 在 JavaScript 中引入 bigint 之前的旧版本。<br>process.hrtime() 方法在 [seconds, nanoseconds] 元组 Array 中返回当前高解析度实时，其中 nanoseconds 是无法以秒精度表示的实时剩余部分。</p>
<p>time 是可选参数，它必须是先前 process.hrtime() 调用 diff 与当前时间的结果。 如果传入的参数不是元组 Array，则会抛出 TypeError。 传入用户定义的数组而不是先前调用 process.hrtime() 的结果将导致未定义的行为。</p>
<p>这些时间相对于过去的任意时间，与一天中的时间无关，因此不受时钟漂移的影响。 主要用途是测量间隔之间的性能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hrtime &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">NS_PER_SEC</span> = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">const</span> time = <span class="title function_">hrtime</span>();</span><br><span class="line"><span class="comment">// [ 1800216, 25 ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> diff = <span class="title function_">hrtime</span>(time);</span><br><span class="line">  <span class="comment">// [ 1, 552 ]</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Benchmark took <span class="subst">$&#123;diff[<span class="number">0</span>] * NS_PER_SEC + diff[<span class="number">1</span>]&#125;</span> nanoseconds`</span>);</span><br><span class="line">  <span class="comment">// 基准测试耗时 1000000552 纳秒</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>process.hrtime.bigint()<br>process.hrtime() 方法的 bigint 版本以纳秒为单位返回当前高解析度实时作为 bigint。<br>与 process.hrtime() 不同，它不支持额外的 time 参数，因为可以直接通过减去两个 bigint 来计算差异。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hrtime &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> start = hrtime.<span class="title function_">bigint</span>();</span><br><span class="line"><span class="comment">// 191051479007711n</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> end = hrtime.<span class="title function_">bigint</span>();</span><br><span class="line">  <span class="comment">// 191052633396993n</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Benchmark took <span class="subst">$&#123;end - start&#125;</span> nanoseconds`</span>);</span><br><span class="line">  <span class="comment">// 基准测试耗时 1154389282 纳秒</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>process.initgroups(user, extraGroup)</p>
<ul>
<li>user <string> | <number> 用户名或数字标识符。</number></string></li>
<li>extraGroup <string> | <number> 群组名或数字标识符。<br>process.initgroups() 方法读取 /etc/group 文件并使用用户所属的所有组初始化组访问列表。 这是一个特权操作，要求 Node.js 进程具有 root 访问权限或 CAP_SETGID 能力。</number></string></li>
</ul>
<p>删除权限时要小心：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getgroups, initgroups, setgid &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getgroups</span>());         <span class="comment">// [ 0 ]</span></span><br><span class="line"><span class="title function_">initgroups</span>(<span class="string">&#x27;nodeuser&#x27;</span>, <span class="number">1000</span>);     <span class="comment">// 切换用户</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getgroups</span>());         <span class="comment">// [ 27, 30, 46, 1000, 0 ]</span></span><br><span class="line"><span class="title function_">setgid</span>(<span class="number">1000</span>);                     <span class="comment">// 删除 root 的 gid</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getgroups</span>());         <span class="comment">// [ 27, 30, 46, 1000 ]</span></span><br></pre></td></tr></table></figure>
<p>此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 此特性在 Worker 线程中不可用。</p>
<p>process.kill(pid[, signal])<br>pid <number> 进程标识<br>signal <string> | <number> 要发送的信号，可以是字符串或数字。 默认值: ‘SIGTERM’。<br>process.kill() 方法将 signal 发送到由 pid 标识的进程。</number></string></number></p>
<p>信号名称是字符串，例如 ‘SIGINT’ 或 ‘SIGHUP’。 有关详细信息，请参阅信号事件和 kill(2)。</p>
<p>如果目标 pid 不存在，则此方法将抛出错误。 作为特殊情况，可以使用信号 0 来测试进程是否存在。 如果使用 pid 来杀死进程组，则 Windows 平台将抛出错误。<br>尽管此函数的名字是 process.kill()，但它实际上只是信号发送者，就像 kill 系统调用。 发送的信号可能会做其他事情而不是杀死目标进程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> process, &#123; kill &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&#x27;SIGHUP&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Got SIGHUP signal.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Exiting.&#x27;</span>);</span><br><span class="line">  process.<span class="title function_">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">kill</span>(process.<span class="property">pid</span>, <span class="string">&#x27;SIGHUP&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>当 Node.js 进程收到 SIGUSR1 时，Node.js 将启动调试器。 参见信号事件。</p>
<p>process.memoryUsage()<br>返回: <Object></Object></p>
<ul>
<li>rss <integer></integer></li>
<li>heapTotal <integer></integer></li>
<li>heapUsed <integer></integer></li>
<li>external <integer></integer></li>
<li>arrayBuffers <integer><br>返回描述 Node.js 进程的内存使用量（以字节为单位）的对象。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memoryUsage &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">memoryUsage</span>());</span><br><span class="line"><span class="comment">// 打印:</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//  rss: 4935680,</span></span><br><span class="line"><span class="comment">//  heapTotal: 1826816,</span></span><br><span class="line"><span class="comment">//  heapUsed: 650472,</span></span><br><span class="line"><span class="comment">//  external: 49879,</span></span><br><span class="line"><span class="comment">//  arrayBuffers: 9386</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// heapTotal 和 heapUsed 指的是 V8 的内存使用量。</span></span><br><span class="line"><span class="comment">// external 指的是绑定到 V8 管理的 JavaScript 对象的 C++ 对象的内存使用量。</span></span><br><span class="line"><span class="comment">// rss，常驻集大小，是进程在主内存设备（即总分配内存的子集）中占用的空间量，包括所有 C++ 和 JavaScript 对象和代码。</span></span><br><span class="line"><span class="comment">// arrayBuffers 是指为 ArrayBuffer 和 SharedArrayBuffer 分配的内存，包括所有 Node.js Buffer。 这也包含在 external 值中。 当 Node.js 被用作嵌入式库时，此值可能为 0，因为在这种情况下可能不会跟踪 ArrayBuffer 的分配。</span></span><br><span class="line"><span class="comment">// 当使用 Worker 线程时，则 rss 将是对整个进程都有效的值，而其他字段仅涉及当前线程。</span></span><br></pre></td></tr></table></figure>
process.memoryUsage() 方法遍历每个页面以收集有关内存使用情况的信息，这可能会根据程序内存分配而变慢。</integer></li>
</ul>
<p>process.memoryUsage.rss()<br>process.memoryUsage.rss() 方法返回以字节为单位表示驻留集大小的整数 (RSS)。<br>驻留集大小是进程在主内存设备（即总分配内存的子集）中占用的空间量，包括所有 C++ 和 JavaScript 对象和代码。<br><em>这与 process.memoryUsage() 提供的 rss 属性值相同，但 process.memoryUsage.rss() 更快。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; memoryUsage &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(memoryUsage.<span class="title function_">rss</span>());</span><br><span class="line"><span class="comment">// 35655680</span></span><br></pre></td></tr></table></figure>

<p>process.nextTick(callback[, …args])<br>callback <Function><br>…args <any> 当调用 callback 时要传入的额外参数<br>process.nextTick() 将 callback 添加到”下一个滴答队列”。 在 JavaScript 堆栈上的当前操作运行完成之后，且在允许事件循环继续之前，此队列将被完全排空。 如果递归地调用 process.nextTick()，则可能会创建无限的循环。</any></Function></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick callback&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scheduled&#x27;</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// scheduled</span></span><br><span class="line"><span class="comment">// nextTick callback</span></span><br></pre></td></tr></table></figure>

<p>这在开发 API 时很重要，以便让用户有机会在对象构建之后但在任何 I/O 发生之前分配事件句柄：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyThing</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setupOptions</span>(options);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">startDoingStuff</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> <span class="title class_">MyThing</span>();</span><br><span class="line">thing.<span class="title function_">getReadyForStuff</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// thing.startDoingStuff() 现在被调用，而不是之前。</span></span><br></pre></td></tr></table></figure>
<p>这对于要 100% 同步或 100% 异步的 API 非常重要。 设想这个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 警告！不要使用！不安全的危险！</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maybeSync</span>(<span class="params">arg, cb</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arg) &#123;</span><br><span class="line">    <span class="title function_">cb</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">stat</span>(<span class="string">&#x27;file&#x27;</span>, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此 API 是危险的，因为在以下情况下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maybeTrue = <span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">maybeSync</span>(maybeTrue, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">foo</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>();</span><br></pre></td></tr></table></figure>
<p>并不清楚是先调用 foo() 还是 bar()。</p>
<p>以下方法要好得多：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">definitelyAsync</span>(<span class="params">arg, cb</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arg) &#123;</span><br><span class="line">    <span class="title function_">nextTick</span>(cb);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">stat</span>(<span class="string">&#x27;file&#x27;</span>, cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>何时使用 queueMicrotask() 与 process.nextTick()<br><strong>queueMicrotask() API 是 process.nextTick() 的替代方案，它还使用用于执行 then、catch 和 finally 处理程序的相同微任务队列来延迟函数的执行。 在 Node.js 中，每次“下一个滴答队列”被排空时，微任务队列也会立即排空。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>));</span><br><span class="line"><span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>));</span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>对于_大多数_用户空间用例，queueMicrotask() API 提供了一种可移植且可靠的延迟执行机制，该机制适用于多个 JavaScript 平台环境，应该比 process.nextTick() 更受青睐。 在简单的场景中，queueMicrotask() 可以直接替代 process.nextTick()。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;microtask callback&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;scheduled&#x27;</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// scheduled</span></span><br><span class="line"><span class="comment">// microtask callback</span></span><br></pre></td></tr></table></figure>
<p><em>process.nextTick()和queueMicrotask()区别</em></p>
<ul>
<li>process.nextTick() 允许指定额外值，这些值将在调用时作为参数传递给延迟函数。使用 queueMicrotask() 实现相同的结果需要使用闭包或绑定函数</li>
<li>从下一个滴答队列和微任务队列中引发的错误的处理方式存在细微差别。 在排队的微任务回调中抛出的错误应该在可能的情况下在排队的回调中处理。 如果不是，则可以使用 process.on(‘uncaughtException’) 事件句柄来捕获和处理错误。</li>
</ul>
<p>process.noDeprecation<br>process.noDeprecation 属性指示是否在当前 Node.js 进程上设置了 –no-deprecation 标志。 有关此标志行为的更多信息，请参阅 ‘warning’ 事件和 emitWarning() 方法的文档。</p>
<p>process.report<br>process.report 是一个对象，其方法用于为当前进程生成诊断报告。 报告文档中提供了额外文档。</p>
<p>process.report.getReport([err])<br>返回正在运行的进程的诊断报告的 JavaScript 对象表示形式。 报告的 JavaScript 堆栈跟踪取自 err（如果存在）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; report &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = report.<span class="title function_">getReport</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">header</span>.<span class="property">nodejsVersion</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于 process.report.writeReport()</span></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;node:fs&#x27;</span>;</span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;my-report.log&#x27;</span>, util.<span class="title function_">inspect</span>(data), <span class="string">&#x27;utf8&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>process.report.reportOnSignal<br>如果为 true，则当进程接收到 process.report.signal 指定的信号时生成诊断报告。</p>
<p>process.report.reportOnUncaughtException<br>如果为 true，则针对未捕获的异常生成诊断报告。</p>
<p>process.report.signal<br>用于触发诊断报告创建的信号。 默认为 ‘SIGUSR2’。</p>
<p>process.report.writeReport([filename][, err])<br>filename <string> 写入报告的文件的名称。 这应该是相对路径，如果未指定，它将附加到 process.report.directory 中指定的目录或 Node.js 进程的当前工作目录。<br>err <Error> 用于报告 JavaScript 堆栈的自定义错误。<br>将诊断报告写入文件。 如果未提供 filename，则默认文件名包括日期、时间、PID 和序列号。 报告的 JavaScript 堆栈跟踪取自 err（如果存在）。</Error></string></p>
<p>process.send(message[, sendHandle[, options]][, callback])<br>如果使用 IPC 通道衍生 Node.js，则可以使用 process.send() 方法向父进程发送消息。 消息将作为父对象 ChildProcess 对象上的 ‘message’ 事件接收。<br><em>如果 Node.js 没有使用 IPC 通道衍生，则 process.send 将是 undefined。</em><br><em>消息经过序列化和解析。 结果消息可能与最初发送的消息不同。</em></p>
<p>process.setegid(id)<br>process.setegid() 方法设置进程的有效群组标识。 （请参阅 setegid(2)。）id 可以作为数字 ID 或群组名称字符串传入。 如果指定了群组名，则此方法在解析关联的数字 ID 时会阻塞。<br><em>此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 此特性在 Worker 线程中不可用。</em></p>
<p>process.seteuid(id)<br>process.setgid(id)<br>process.setuid(id)<br>与process.setegid(id)类似</p>
<p>process.setgroups(groups)<br>process.setgroups() 方法为 Node.js 进程设置补充群组 ID。<br><em>这是一个特权操作，需要 Node.js 进程具有 root 或 CAP_SETGID 能力。</em><br>groups 数组可以包含数字群组 ID、群组名称或两者。<br>此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 此特性在 Worker 线程中不可用。</p>
<p>process.setUncaughtExceptionCaptureCallback(fn)<br>fn <Function> | <null><br>process.setUncaughtExceptionCaptureCallback() 函数设置一个函数，当发生未捕获的异常时将调用该函数，该函数将接收异常值本身作为其第一个参数。<br><em>如果设置了这样的函数，则不会触发 ‘uncaughtException’ 事件。 如果 –abort-on-uncaught-exception 是从命令行传入的或通过 v8.setFlagsFromString() 设置的，则进程不会中止。 配置为对异常执行的操作（例如报告生成）也将受到影响</em></null></Function></p>
<p>要取消捕获功能，可以使用 process.setUncaughtExceptionCaptureCallback(null)。 在设置另一个捕获函数时使用非 null 参数调用此方法将引发错误。</p>
<p><em>使用此函数与使用已弃用的 domain 内置模块是相互排斥的。</em></p>
<p>process.stderr<br>process.stderr 属性返回连接到 stderr (文件描述符 2) 的流。 它是 net.Socket（也就是 Duplex 流），除非文件描述符 2 指向文件，在这种情况下它是 Writable 流。<br>process.stderr 在一些重要的方面不同于其他 Node.js 流。 有关更多信息，请参阅进程 I/O 的注意事项。</p>
<p>process.stderr.fd<br>该属性指的是 process.stderr 的底层文件描述符的值。 该值固定为 2。 在 Worker 线程中，该字段不存在。</p>
<p>process.stdin<br>process.stdin 属性返回连接到 stdin (文件描述符 0) 的流。 它是 net.Socket（也就是 Duplex 流），除非文件描述符 0 指向文件，在这种情况下它是 Readable 流。<br>有关如何从 stdin 读取的详细信息，请参阅 readable.read()。<br><em>在“旧”流模式下，stdin 流默认是暂停的，所以必须调用 process.stdin.resume() 来读取它。 另请注意，调用 process.stdin.resume() 本身会将流切换到“旧”模式。</em></p>
<p>process.stdout<br>process.stdout 属性返回连接到 stdout (文件描述符 1) 的流。 它是 net.Socket（也就是 Duplex 流），除非文件描述符 1 指向文件，在这种情况下它是 Writable 流。</p>
<h6 id="进程-I-O-的注意事项"><a href="#进程-I-O-的注意事项" class="headerlink" title="进程 I/O 的注意事项"></a>进程 I/O 的注意事项</h6><p>process.stdout 和 process.stderr 在重要方面与其他 Node.js 流不同：</p>
<p>它们分别由 console.log() 和 console.error() 内部使用。<br>写入的区别：</p>
<ul>
<li>文件：在 Windows 和 POSIX 上是_同步的_</li>
<li>TTY（终端）: 在 Windows 上是_异步的_，在 POSIX 上是_同步的_</li>
<li>管道（和套接字）: 在 Windows 上是_同步的_，在 POSIX 上是_异步的_</li>
</ul>
<p><strong>警告：同步写入会阻塞事件循环，直到写入完成。 在输出到文件的情况下，这可能几乎是瞬时的，但在系统负载高、接收端未读取管道或终端或文件系统速度较慢的情况下，事件循环可能经常被阻塞足够长，足以对性能产生严重的负面影响。 这在写入交互式终端会话时可能不是问题，但在对流程输出流进行生产日志记录时要特别小心。</strong></p>
<p>要检查流是否连接到 TTY 上下文，请检查 isTTY 属性。</p>
<p>process.title<br>process.title 属性返回当前进程标题（即返回 ps 的当前值）。 为 process.title 分配一个新值会修改 ps 的当前值。</p>
<p>分配新值时，不同平台会对标题施加不同的最大长度限制。</p>
<p>将值分配给 process.title 可能不会在进程管理器应用程序（例如 macOS 活动监视器或 Windows 服务管理器）中产生准确的标签。</p>
<p>process.umask(mask)<br>process.umask(mask) 设置 Node.js 进程的文件模式创建掩码。 子进程从父进程继承掩码。 返回上一个掩码。<br>在 Worker 线程中，process.umask(mask) 会抛出异常。</p>
<p>process.uptime()<br>process.uptime() 方法返回当前 Node.js 进程已经运行的秒数。<br>返回值包括几分之一秒。 使用 Math.floor() 获得整秒。</p>
<p>process.version<br>process.version 属性包含 Node.js 版本字符串。<br>要获取不带 v 的版本字符串，则使用 process.versions.node。</p>
<p>process.versions<br>process.versions 属性返回对象，其中列出了 Node.js 的版本字符串及其依赖项。<br>process.versions.modules 表示当前的 ABI 版本，每当 C++ API 更改时都会增加。 Node.js 将拒绝加载针对不同模块 ABI 版本编译的模块。</p>
<h6 id="退出码"><a href="#退出码" class="headerlink" title="退出码"></a>退出码</h6><p>当没有更多异步操作挂起时，Node.js 通常会以 0 状态代码退出。 在其他情况下使用以下状态代码：</p>
<p>1 未捕获的致命异常：存在未捕获的异常，并且其没有被域或 ‘uncaughtException’ 事件句柄处理。<br>2: 未使用（由 Bash 预留用于内置误用）<br>3 内部 JavaScript 解析错误：Node.js 引导过程中的内部 JavaScript 源代码导致解析错误。 这是极其罕见的，通常只能在 Node.js 本身的开发过程中发生。<br>4 内部 JavaScript 评估失败：Node.js 引导过程中的内部 JavaScript 源代码在评估时未能返回函数值。 这是极其罕见的，通常只能在 Node.js 本身的开发过程中发生。<br>5 致命错误：V8 中存在不可恢复的致命错误。 通常将打印带有前缀 FATAL ERROR 的消息到标准错误。<br>6 非函数的内部异常句柄：存在未捕获的异常，但内部致命异常句柄不知何故设置为非函数，无法调用。<br>7 内部异常句柄运行时失败：存在未捕获的异常，并且内部致命异常句柄函数本身在尝试处理时抛出错误。 例如，如果 ‘uncaughtException’ 或 domain.on(‘error’) 句柄抛出错误，就会发生这种情况。<br>8: 未使用。 在以前版本的 Node.js 中，退出码 8 有时表示未捕获的异常。<br>9 无效参数：指定了未知选项，或者提供了需要值的选项而没有值。<br>10 内部 JavaScript 运行时失败：Node.js 引导过程中的内部 JavaScript 源代码在调用引导函数时抛出错误。 这是极其罕见的，通常只能在 Node.js 本身的开发过程中发生。<br>12 无效的调试参数：设置了 –inspect 和/或 –inspect-brk 选项，但选择的端口号无效或不可用。<br>13 未完成的顶层等待：在顶层代码中的函数外使用了 await，但传入的 Promise 从未解决。</p>
<blockquote>
<p>128 信号退出：如果 Node.js 收到致命的信号，例如 SIGKILL 或 SIGHUP，则其退出码将是 128 加上信号代码的值。 这是标准的 POSIX 实践，因为退出码被定义为 7 位整数，并且信号退出设置高位，然后包含信号代码的值。 例如，信号 SIGABRT 的值是 6，因此预期的退出码将是 128 + 6 或 134。</p>
</blockquote>

      </div>
      
      
      
    </div>

    
    


</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sun Jinkang</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">60k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:37</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bg-beautifier.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  






  

  
    <script type="text/javascript"
        count="150"
        opacity: 1
        src="/js/canvas-nest.min.js">
    </script>
  

</body>
<script type="text/javascript" src="/js/bg-beautifier.js"></script>
<script>hexoChangeBanner();</script>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
</html>
