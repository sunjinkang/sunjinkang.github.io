{"meta":{"title":"Sun with no word","subtitle":"something about what I have learned and some interesting things","description":"study blog from sun jinkang","author":"Sun Jinkang","url":"https://sunjinkang.github.io","root":"/"},"pages":[{"title":"","date":"2023-07-26T09:46:09.497Z","updated":"2023-07-26T09:46:09.497Z","comments":true,"path":"404.html","permalink":"https://sunjinkang.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2023-07-26T06:55:13.718Z","updated":"2023-07-26T06:55:13.718Z","comments":true,"path":"about/index.html","permalink":"https://sunjinkang.github.io/about/index.html","excerpt":"","text":""},{"title":"babel基础知识","date":"2023-04-09T02:13:45.000Z","updated":"2023-07-24T09:24:46.475Z","comments":true,"path":"babel/babel-note-1.html","permalink":"https://sunjinkang.github.io/babel/babel-note-1.html","excerpt":"","text":"抽象语法树 抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。 babel 的处理过程每一步都涉及抽象语法树。AST Explorer是一个在线转化 ast 的网站，可以查看源码及转化后的 AST 代码。 以 type 划分每一层级，这样的每一层结构也被叫做 节点（Node）。 一个 AST 可以由单一的节点或是成百上千个节点构成。 它们组合在一起可以描述用于静态分析的程序语法。 每一个节点都有 start、end、loc 这三个属性用以确定节点在源代码中的位置 babel 的处理步骤babel 的主要处理分为三个步骤：解析（parse），转换（transform），生成（generate） 解析babel 的解析是将源码转化输出为 ast 的过程，解析分为两步：词法分析和语法分析 词法分析：词法分析阶段把字符串形式的代码转换为 令牌（tokens） 流。 语法分析：语法分析阶段会把一个令牌流转换成 AST 的形式。 这个阶段会使用令牌中的信息把它们转换成一个 AST 的结构，这样更易于后续的操作。 转换转换步骤接收 AST 并对其进行遍历，在此过程中对节点进行添加、更新及移除等操作。 这是 Babel 或是其他编译器中最复杂的过程 同时也是插件将要介入工作的部分，后续将做详细介绍。 生成代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps）。.代码生成其实很简单：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。 State(状态)通过将一个访问者放入另一个访问者中以达到从访问者中消除全局状态的目的。 12345678910111213141516171819const updateParamNameVisitor = &#123; Identifier(path) &#123; if (path.node.name === this.paramName) &#123; path.node.name = &#x27;x&#x27;; &#125; &#125;,&#125;;const MyVisitor = &#123; FunctionDeclaration(path) &#123; const param = path.node.params[0]; const paramName = param.name; param.name = &#x27;x&#x27;; path.traverse(updateParamNameVisitor, &#123; paramName &#125;); &#125;,&#125;;path.traverse(MyVisitor); Scopes(作用域)当编写一个转换时，必须小心作用域。得确保在改变代码的各个部分时不会破坏已经存在的代码。在添加一个新的引用时需要确保新增加的引用名字和已有的所有引用不冲突。 或者我们仅仅想找出使用一个变量的所有引用， 我们只想在给定的作用域（Scope）中找出这些引用。 当你创建一个新的作用域时，需要给出它的路径和父作用域，之后在遍历过程中它会在该作用域内收集所有的引用(“绑定”)。一旦引用收集完毕，你就可以在作用域（Scopes）上使用各种方法 Bindings（绑定）所有引用属于特定的作用域，引用和作用域的这种关系被称作：绑定（binding）。通过绑定的信息可以查找一个绑定的所有引用，并且知道这是什么类型的绑定(参数，定义等等)，查找它所属的作用域，或者拷贝它的标识符。 你甚至可以知道它是不是常量，如果不是，那么是哪个路径修改了它。在很多情况下，知道一个绑定是否是常量非常有用，最有用的一种情形就是代码压缩时。 APIBabylonBabylon has been moved into the main Babel mono-repo as @babel/parser. Babylon 是 Babel 的解析器。最初是 从 Acorn 项目 fork 出来的。Acorn 非常快，易于使用，并且针对非标准特性(以及那些未来的标准特性) 设计了一个基于插件的架构。 具体内容可查看后续章节。 babel-traverseBabel Traverse（遍历）模块维护了整棵树的状态，并且负责替换、移除和添加节点。 traverse 可以和 parser 一起使用，用于遍历和更新节点 12345678910111213141516import * as babylon from &#x27;babylon&#x27;;import traverse from &#x27;babel-traverse&#x27;;const code = `function square(n) &#123; return n * n;&#125;`;const ast = babylon.parse(code);traverse(ast, &#123; enter(path) &#123; if (path.node.type === &#x27;Identifier&#x27; &amp;&amp; path.node.name === &#x27;n&#x27;) &#123; path.node.name = &#x27;x&#x27;; &#125; &#125;,&#125;); 具体内容可查看后续章节。 babel-typesBabel Types 模块是一个用于 AST 节点的 Lodash 式工具库， 它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理 AST 逻辑非常有用。 12345678910import traverse from &#x27;babel-traverse&#x27;;import * as t from &#x27;babel-types&#x27;;traverse(ast, &#123; enter(path) &#123; if (t.isIdentifier(path.node, &#123; name: &#x27;n&#x27; &#125;)) &#123; path.node.name = &#x27;x&#x27;; &#125; &#125;,&#125;); Definitions（定义）Babel Types 模块拥有每一个单一类型节点的定义，包括节点包含哪些属性，什么是合法值，如何构建节点、遍历节点，以及节点的别名等信息。单一节点类型的定义形式如下： 12345678910111213141516defineType(&#x27;BinaryExpression&#x27;, &#123; builder: [&#x27;operator&#x27;, &#x27;left&#x27;, &#x27;right&#x27;], fields: &#123; operator: &#123; validate: assertValueType(&#x27;string&#x27;), &#125;, left: &#123; validate: assertNodeType(&#x27;Expression&#x27;), &#125;, right: &#123; validate: assertNodeType(&#x27;Expression&#x27;), &#125;, &#125;, visitor: [&#x27;left&#x27;, &#x27;right&#x27;], aliases: [&#x27;Binary&#x27;, &#x27;Expression&#x27;],&#125;); Builders（构建器）你会注意到上面的 BinaryExpression 定义有一个 builder 字段。builder: [“operator”, “left”, “right”]这是由于每一个节点类型都有构造器方法 builder，按类似下面的方式使用： 1t.binaryExpression(&#x27;*&#x27;, t.identifier(&#x27;a&#x27;), t.identifier(&#x27;b&#x27;)); Validators（验证器）BinaryExpression 的定义还包含了节点的字段 fields 信息，以及如何验证这些字段。可以创建两种验证方法。第一种是 isX。 123456789t.isBinaryExpression(maybeBinaryExpressionNode);// 这个测试用来确保节点是一个二进制表达式，另外你也可以传入第二个参数来确保节点包含特定的属性和值。t.isBinaryExpression(maybeBinaryExpressionNode, &#123; operator: &#x27;*&#x27; &#125;);// 这些方法还有一种断言式的版本，会抛出异常而不是返回 true 或 false。.t.assertBinaryExpression(maybeBinaryExpressionNode);t.assertBinaryExpression(maybeBinaryExpressionNode, &#123; operator: &#x27;*&#x27; &#125;);// Error: Expected type &quot;BinaryExpression&quot; with option &#123; &quot;operator&quot;: &quot;*&quot; &#125; Converters（变换器） babel-generatorBabel Generator 模块是 Babel 的代码生成器，它读取 AST 并将其转换为代码和源码映射（sourcemaps）。 babel-templatebabel-template 是另一个虽然很小但却非常有用的模块。 它能让你编写字符串形式且带有占位符的代码来代替手动编码， 尤其是生成的大规模 AST 的时候。 在计算机科学中，这种能力被称为准引用（quasiquotes）。 找到特定的父路径有时你需要从一个路径向上遍历语法树，直到满足相应的条件。 1234567891011// 对于每一个父路径调用callback并将其NodePath当作参数，当callback返回真值时，则将其NodePath返回。.path.findParent((path) =&gt; path.isObjectExpression());// 如果也需要遍历当前节点：path.find((path) =&gt; path.isObjectExpression());// 查找最接近的父函数或程序：path.getFunctionParent();// 向上遍历语法树，直到找到在列表中的父节点路径path.getStatementParent(); 获取同级路径如果一个路径是在一个 Function／Program 中的列表里面，它就有同级节点。 使用 path.inList 来判断路径是否有同级节点， 使用 path.getSibling(index)来获得同级路径, 使用 path.key 获取路径所在容器的索引, 使用 path.container 获取路径的容器（包含所有同级节点的数组） 使用 path.listKey 获取容器的 key 停止遍历如果你的插件需要在某种情况下不运行，最简单的做法是尽早写回。 123BinaryExpression(path) &#123; if (path.node.operator !== &#x27;**&#x27;) return;&#125; 如果您在顶级路径中进行子遍历，则可以使用 2 个提供的 API 方法： path.skip() 跳过遍历当前路径的子路径。 path.stop() 完全停止遍历。 处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 替换一个节点BinaryExpression(path) &#123; path.replaceWith( t.binaryExpression(&quot;**&quot;, path.node.left, t.numberLiteral(2)) );&#125;// 用多节点替换单节点ReturnStatement(path) &#123; path.replaceWithMultiple([ t.expressionStatement(t.stringLiteral(&quot;Is this the real life?&quot;)), t.expressionStatement(t.stringLiteral(&quot;Is this just fantasy?&quot;)), t.expressionStatement(t.stringLiteral(&quot;(Enjoy singing the rest of the song in your head)&quot;)), ]);&#125;// *当用多个节点替换一个表达式时，它们必须是 声明。 这是因为Babel在更换节点时广泛使用启发式算法，这意味着您可以做一些非常疯狂的转换，否则将会非常冗长*// 用字符串源码替换节点FunctionDeclaration(path) &#123; path.replaceWithSourceString(&#x27;function add(a, b) &#123; return a + b; &#125;&#x27;);&#125;// 不建议使用这个API，除非您正在处理动态的源码字符串，否则在访问者外部解析代码更有效率。// 插入兄弟节点FunctionDeclaration(path) &#123; path.insertBefore(t.expressionStatement(t.stringLiteral(&quot;Because I&#x27;m easy come, easy go.&quot;))); path.insertAfter(t.expressionStatement(t.stringLiteral(&quot;A little high, little low.&quot;)));&#125;// 这里同样应该使用声明或者一个声明数组。 这个使用了在用多个节点替换一个节点中提到的相同的启发式算法。// 插入到容器（container）中// 如果您想要在AST节点属性中插入一个像body.0那样的数组。 它与insertBefore/insertAfter 类似, 但您必须指定 listKey (通常是 正文).ClassMethod(path) &#123; path.get(&#x27;body&#x27;).unshiftContainer(&#x27;body&#x27;, t.expressionStatement(t.stringLiteral(&#x27;before&#x27;))); path.get(&#x27;body&#x27;).pushContainer(&#x27;body&#x27;, t.expressionStatement(t.stringLiteral(&#x27;after&#x27;)));&#125;// 删除一个节点FunctionDeclaration(path) &#123; path.remove();&#125;// 替换父节点// 只需使用parentPath,调用 replaceWith即可BinaryExpression(path) &#123; path.parentPath.replaceWith( t.expressionStatement(t.stringLiteral(&quot;Anyway the wind blows, doesn&#x27;t really matter to me, to me.&quot;)) );&#125;// 删除父节点BinaryExpression(path) &#123; path.parentPath.remove();&#125; Scope（作用域） 123456789101112131415161718192021222324252627282930313233343536373839// 检查本地变量是否被绑定FunctionDeclaration(path) &#123; if (path.scope.hasBinding(&quot;n&quot;)) &#123; // ... &#125;&#125;// 这将遍历范围树并检查特定的绑定。// 您也可以检查一个作用域是否有自己的绑定：FunctionDeclaration(path) &#123; if (path.scope.hasOwnBinding(&quot;n&quot;)) &#123; // ... &#125;&#125;// 创建一个 UID，这将生成一个标识符，不会与任何本地定义的变量相冲突。FunctionDeclaration(path) &#123; path.scope.generateUidIdentifier(&quot;uid&quot;); // Node &#123; type: &quot;Identifier&quot;, name: &quot;_uid&quot; &#125; path.scope.generateUidIdentifier(&quot;uid&quot;); // Node &#123; type: &quot;Identifier&quot;, name: &quot;_uid2&quot; &#125;&#125;// 提升变量声明至父级作用域，有时你可能想要推送一个VariableDeclaration，这样你就可以分配给它。FunctionDeclaration(path) &#123; const id = path.scope.generateUidIdentifierBasedOnNode(path.node.id); path.remove(); path.scope.parent.push(&#123; id, init: path.node &#125;);&#125;// - function square(n) &#123;// + var _square = function square(n) &#123;// return n * n;// - &#125;// + &#125;;// 重命名绑定及其引用FunctionDeclaration(path) &#123; path.scope.rename(&quot;n&quot;, &quot;x&quot;);&#125; 插件选项 123456789101112131415161718192021// 如果您想让您的用户自定义您的Babel插件的行为您可以接受用户可以指定的插件特定选项，如下所示：&#123; plugins: [ [&quot;my-plugin&quot;, &#123; &quot;option1&quot;: true, &quot;option2&quot;: false &#125;] ]&#125;// 这些选项会通过`状态对象传递给插件访问者export default function(&#123; types: t &#125;) &#123; return &#123; visitor: &#123; FunctionDeclaration(path, state) &#123; console.log(state.opts); // &#123; option1: true, option2: false &#125; &#125; &#125; &#125;&#125; 插件的准备和收尾工作 12345678910111213141516// 插件可以具有在插件之前或之后运行的函数。它们可以用于设置或清理/分析目的。export default function(&#123; types: t &#125;) &#123; return &#123; pre(state) &#123; this.cache = new Map(); &#125;, visitor: &#123; StringLiteral(path) &#123; this.cache.set(path.node.value, 1); &#125; &#125;, post(state) &#123; console.log(this.cache); &#125; &#125;;&#125; 在插件中启用其他语法 123456// 插件可以启用babel plugins，以便用户不需要安装/启用它们。 这可以防止解析错误，而不会继承语法插件。export default function(&#123; types: t &#125;) &#123; return &#123; inherits: require(&quot;babel-plugin-syntax-jsx&quot;) &#125;;&#125; 抛出一个语法错误 12345678910// 如果您想用babel-code-frame和一个消息抛出一个错误：export default function(&#123; types: t &#125;) &#123; return &#123; visitor: &#123; StringLiteral(path) &#123; throw path.buildCodeFrameError(&quot;Error message here&quot;); &#125; &#125; &#125;;&#125; 构建节点编写转换时，通常需要构建一些要插入的节点进入AST。 如前所述，您可以使用babel-types包中的builder方法。构建器的方法名称就是您想要的节点类型的名称，除了第一个字母小写。 例如，如果您想建立一个 MemberExpression 您可以使用 t.memberExpression（…） 1234567891011// 请注意，有时在节点上可以定制的属性比``构建器&lt;/&gt;数组包含的属性更多。 这是为了防止生成器有太多的参数。 在这些情况下，您需要手动设置属性。 // Example// because the builder doesn&#x27;t contain `async` as a propertyvar node = t.classMethod( &quot;constructor&quot;, t.identifier(&quot;constructor&quot;), params, body)// set it manually after creationnode.async = true; 最佳实践将一些公共或者特定的检查提取出来 1234567function isAssignment(node) &#123; return node &amp;&amp; node.operator === opts.operator + &quot;=&quot;;&#125;function buildAssignment(left, right) &#123; return t.assignmentExpression(&quot;=&quot;, left, right);&#125; 尽量避免遍历抽象语法树（AST） 及时合并访问者对象123456789101112// 可以将以下访问器合并path.traverse(&#123; Identifier(path) &#123; // ... &#125;&#125;);path.traverse(&#123; BinaryExpression(path) &#123; // ... &#125;&#125;); 可以手动查找就不要遍历1234567891011121314151617181920// 使用path.traverse查找特定类型的节点const nestedVisitor = &#123; Identifier(path) &#123; // ... &#125;&#125;;const MyVisitor = &#123; FunctionDeclaration(path) &#123; path.get(&#x27;params&#x27;).traverse(nestedVisitor); &#125;&#125;;// 查找特定节点时，可以尝试使用手动处理的方式，无需执行代价高昂的traverse遍历const MyVisitor = &#123; FunctionDeclaration(path) &#123; path.node.params.forEach(function() &#123; // ... &#125;); &#125;&#125;; 优化嵌套的访问者对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const MyVisitor = &#123; FunctionDeclaration(path) &#123; path.traverse(&#123; Identifier(path) &#123; // ... &#125; &#125;); &#125;&#125;;// 将上面的例子改成下面这样，原因：// 每当调用FunctionDeclaration()时都会创建一个新的访问者对象。代价可能有点大，因为每次一个新的访问者对象传入babel，babel都会做一些处理。// babel会将已经处理过的标志保存在访问者对象上，因此最好还是将访问者保存在一个变量里，每次传递相同的对象。const nestedVisitor = &#123; Identifier(path) &#123; // ... &#125;&#125;;const MyVisitor = &#123; FunctionDeclaration(path) &#123; path.traverse(nestedVisitor); &#125;&#125;;// 在嵌套的访问者中需要一些状态const MyVisitor = &#123; FunctionDeclaration(path) &#123; var exampleState = path.node.params[0].name; path.traverse(&#123; Identifier(path) &#123; if (path.node.name === exampleState) &#123; // ... &#125; &#125; &#125;); &#125;&#125;;// 可以将它作为状态传递给traverse()方法，并有权在访问者中通过this拿到状态const nestedVisitor = &#123; Identifier(path) &#123; if (path.node.name === this.exampleState) &#123; // ... &#125; &#125;&#125;;const MyVisitor = &#123; FunctionDeclaration(path) &#123; var exampleState = path.node.params[0].name; path.traverse(nestedVisitor, &#123; exampleState &#125;); &#125;&#125;; 留意嵌套结构 单元测试有几种主要的方法来测试babel插件：快照测试，AST测试和执行测试可以使用插件：babel-plugin-tester 1234567891011121314151617181920212223242526import pluginTester from &#x27;babel-plugin-tester&#x27;;import identifierReversePlugin from &#x27;../identifier-reverse-plugin&#x27;;pluginTester(&#123; plugin: identifierReversePlugin, fixtures: path.join(__dirname, &#x27;__fixtures__&#x27;), tests: &#123; &#x27;does not change code with no identifiers&#x27;: &#x27;&quot;hello&quot;;&#x27;, &#x27;changes this code&#x27;: &#123; code: &#x27;var hello = &quot;hi&quot;;&#x27;, output: &#x27;var olleh = &quot;hi&quot;;&#x27;, &#125;, &#x27;using fixtures files&#x27;: &#123; fixture: &#x27;changed.js&#x27;, outputFixture: &#x27;changed-output.js&#x27;, &#125;, &#x27;using jest snapshots&#x27;: &#123; code: ` function sayHi(person) &#123; return &#x27;Hello &#x27; + person + &#x27;!&#x27; &#125; `, snapshot: true, &#125;, &#125;,&#125;); 疑问点：1、使用@babel/traverse 报错：TypeError: traverse is not a functionhttps://github.com/babel/babel/issues/138552、什么情况下需要同时使用 stopPropagation 和 preventDefault？3、typescript 的 tsconfig 中 esModuleInterop 的到底做了什么？（https://blog.csdn.net/zdhsoft/article/details/123785137）4、默认导出与具名导出5、ESM 与 CJS 的 Interop 的来世今生（https://zhuanlan.zhihu.com/p/446113714）6、启发式算法"},{"title":"","date":"2024-02-20T09:31:43.016Z","updated":"2024-02-20T09:31:43.016Z","comments":true,"path":"index.html","permalink":"https://sunjinkang.github.io/index.html","excerpt":"","text":"This is Sun Jinkang＇s page. Post文章 vue相关 Nodejs相关 Babel相关 Unity相关 linux相关 常用官网地址"},{"title":"","date":"2023-07-26T07:15:24.841Z","updated":"2023-07-26T06:20:03.195Z","comments":true,"path":"404/index.html","permalink":"https://sunjinkang.github.io/404/index.html","excerpt":"","text":"不好意思，页面已丢失，或者请检查路径是否正确！！！"},{"title":"babel基础知识","date":"2023-04-25T07:02:45.000Z","updated":"2023-07-24T09:24:46.477Z","comments":true,"path":"babel/babel-note-2.html","permalink":"https://sunjinkang.github.io/babel/babel-note-2.html","excerpt":"","text":"babel使用指南babel核心库Babel 的核心功能在 @babel/core 模块。通过以下命令安装： 123456// 安装npm install --save-dev @babel/core// 使用const babel = require(&quot;@babel/core&quot;);babel.transform(&quot;code&quot;, optionsObject); CLI 工具@babel/cli 是一个允许你从终端使用 babel 的工具。下面是安装命令和基本用法的示例： 12npm install --save-dev @babel/core @babel/cli./node_modules/.bin/babel src --out-dir lib Plugins &amp; Presets使用 “preset” 来代替预先设定的一组插件，而不是逐一添加想要的所有插件。就像使用 plugins 一样，你也可以创建自己的 preset，分享你需要的任何插件组合。比如：preset-env。 12npm install --save-dev @babel/preset-env./node_modules/.bin/babel src --out-dir lib --presets=@babel/env 没有任何配置，这个 preset 包括支持现代 JavaScript（ES2015，ES2016 等）的所有插件。但是 presets 也可以选择。不从终端传入 cli 和 preset 选项，而是通过另一种传入选项的方式：配置文件（后续会详细说明）。 Polyfill@babel/polyfill 模块包括 core-js 和自定义 regenerator runtime 来模拟完整的 ES2015+ 环境。注意：如果你确切知道需要实现的功能，可以直接从 core-js 中获取它们。避免直接使用@babel/polyfill造成冗余。由于我们正在构建一个应用程序，我们可以只安装 @babel/polyfill: 1npm install --save @babel/polyfill 注意 –save 选项而不是 –save-dev，因为这是一个需要在源代码之前运行的 polyfill。 如果使用的是 env preset，其中有一个 “useBuiltIns” 选项，当设置为 “usage” 时，实际上将应用上面提到的最后一个优化，只包括你需要的 polyfill。使用此新选项，配置更改如下： 12345678910111213141516const presets = [ [ &quot;@babel/env&quot;, &#123; targets: &#123; edge: &quot;17&quot;, firefox: &quot;60&quot;, chrome: &quot;67&quot;, safari: &quot;11.1&quot;, &#125;, useBuiltIns: &quot;usage&quot;, &#125;, ],];module.exports = &#123; presets &#125;; Babel 将检查你的所有代码，以查找目标环境中缺少的功能，并仅包含所需的 polyfill 1234567// 添加useBuiltIns前Promise.resolve().finally();// 添加useBuiltIns后// 会变成这个（因为 Edge 17 没有 Promise.prototype.finally）：require(&quot;core-js/modules/es.promise.finally&quot;);Promise.resolve().finally(); 如果我们没有将 env preset 的 “useBuiltIns” 选项的设置为 “usage” ，就必须在其他代码之前 require 一次完整的 polyfill。 配置babel babel.config.js以编程式创建配置编译 node_modules 文件位置：在项目根目录（package.json同级）举例： 1234567891011module.exports = function (api) &#123; api.cache(true); const presets = [ ... ]; const plugins = [ ... ]; return &#123; presets, plugins &#125;;&#125; 详细配置： .babelrc有一个静态配置只适用于简单的一个包 文件位置：在项目根目录（package.json同级）举例： 1234&#123; &quot;presets&quot;: [...], &quot;plugins&quot;: [...]&#125; package.json或者可以在 package.json 中，使用 babel 属性来指定.babelrc配置，如下所示：12345678&#123; &quot;name&quot;: &quot;my-package&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;babel&quot;: &#123; &quot;presets&quot;: [ ... ], &quot;plugins&quot;: [ ... ], &#125;&#125; .babelrc.js配置与 .babelrc 相同，可以使用 JavaScript 编写。1234567891011const presets = [ ... ];const plugins = [ ... ];module.exports = &#123; presets, plugins &#125;;// 你可以访问任何 Node.js 的 API，例如基于流程环境的动态配置：const presets = [ ... ];const plugins = [ ... ];if (process.env[&quot;ENV&quot;] === &quot;prod&quot;) &#123; plugins.push(...);&#125;module.exports = &#123; presets, plugins &#125;; 插件顺序指定插件每个访问者的事项，这意味着如果两个转换器都访问同一个“ Program ”节点，则转换器将以插件或 preset 顺序运行。 插件plugins在 Presets 前运行。 插件可以指定从头到尾的顺序。 Preset 顺序是相反的 (从后到前).12345678910111213&#123; &quot;plugins&quot;: [ &quot;transform-decorators-legacy&quot;, &quot;transform-class-properties&quot; ]&#125;// 将会运行 transform-decorators-legacy 然后是 transform-class-properties。// 关于 presets 一定要记住，顺序是相反的。如下：&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;]&#125;// 按以下顺序运行：@babel/preset-react 再运行 @babel/preset-env。 插件选项插件和 presets 都可以通过将名称和选项对象放在在配置中的数组中来指定选项。 对于不指定选项，这些都是等效的： 123456789101112131415161718192021222324252627&#123; &quot;plugins&quot;: [ &quot;pluginA&quot;, [&quot;pluginA&quot;], [&quot;pluginA&quot;, &#123;&#125;], ]&#125;// 要指定选项，输入一个选项名作为 key 的对象&#123; &quot;plugins&quot;: [ [&quot;transform-async-to-module-method&quot;, &#123; &quot;module&quot;: &quot;bluebird&quot;, &quot;method&quot;: &quot;coroutine&quot; &#125;] ]&#125;// presets 的选项设置相同:&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;loose&quot;: true, &quot;modules&quot;: false &#125;] ]&#125; 官方 Presets常见环境的presets ：@babel/preset-env@babel/preset-flow@babel/preset-react@babel/preset-typescript 创建 Preset只需要导出一个配置，就可以创建自己的 preset。 1234567891011121314151617181920module.exports = function() &#123; return &#123; plugins: [ &quot;pluginA&quot;, &quot;pluginB&quot;, &quot;pluginC&quot;, ] &#125;;&#125;// Presets 可以包含其他的 presets 以及带有选项的插件。module.exports = () =&gt; (&#123; presets: [ require(&quot;@babel/preset-env&quot;), ], plugins: [ [require(&quot;@babel/plugin-proposal-class-properties&quot;), &#123; loose: true &#125;], require(&quot;@babel/plugin-proposal-object-rest-spread&quot;), ],&#125;); 配置filename需要编译的源码文件的文件名（可以没有）。 filename 参数是可选的，但是当文件名未知时，并不是所有的 Babel 功能都可用， 因为某些参数依赖 filename 参数 来实现其功能。 文件名暴露给插件。一些插件可能需要文件名的存在。 像”test”， “exclude”和”ignore”这样的选项需要文件名来匹配字符串/RegExp。 .babelrc.json或.babelrc文件相对于被编译的文件被加载。如果省略此选项，Babel将表现得好像设置了babelrc: false。 ast(默认值：false)Babel的默认值是生成一个字符串和一个源映射，但在某些上下文中，获取AST本身也很有用。它的主要用例是多个转换传递链 1234567891011121314151617const filename = &quot;example.js&quot;;const source = fs.readFileSync(filename, &quot;utf8&quot;);// Load and compile file normally, but skip code generation.const &#123; ast &#125; = babel.transformSync(source, &#123; filename, ast: true, code: false,&#125;);// Minify the file in a second pass and generate the output code here.const &#123; code, map &#125; = babel.transformFromAstSync(ast, source, &#123; filename, presets: [&quot;minify&quot;], babelrc: false, configFile: false,&#125;); 注意:默认情况下，这个选项不是打开的，因为大多数用户不需要它，因为我们希望最终在Babel中添加一个缓存层。必须缓存AST结构将占用更多的空间。 cloneInputAst(默认值：true，7.11.0)默认是babel.transformFromAst将克隆输入AST以避免突变。如果输入AST没有在其他地方使用，指定cloneInputAst: false可以提高解析性能。 加载配置项 rootMode(默认值：root，7.1.0)这个选项，结合”root”值，定义了Babel如何选择它的项目根。不同的模式定义了Babel处理“root”值以获得最终项目根的不同方式。 注意：babel.config.json从Babel 7.8.0开始支持，在旧的babel7的版本中，只支持babel.config.js。 “root” - 传”root”，表示不变。 “upward” - 从“根”目录向上走，寻找包含babel.config.json文件的目录，如果没有找到babel.config.json则抛出错误。 “upward-optional” - 从“根”目录向上走，寻找包含babel.config.json文件的目录，如果没有找到babel.config.json，则返回到“root”目录。 “root”是默认模式，因为它避免了Babel意外加载完全在当前项目文件夹之外的Babel.config.json的风险。如果您使用“向上可选”，请注意它将沿着目录结构一直走到文件系统根目录，并且总是有可能有人忘记在他们的主目录中加了babel.config.json，这可能会在构建中导致意外错误。 使用单线程项目结构的用户在每个包的基础上运行构建/测试，他们可能很想使用“向上”，因为单线程项目通常在项目根目录中有一个babel.config.json。在monorepo子目录下运行Babel，不使用”upward”，将导致Babel跳过加载项目根目录下的Babel.config.json文件，这可能导致意外错误和编译失败。 envName(默认值：process.env.BABEL_ENV || process.env.NODE_ENV || “development”)配置加载期间使用的当前活动环境。该值在解析”env”配置时用作键，也可以通过api.env()函数在配置函数、插件和预置中使用 configFile(默认值：如果存在文件，为path.resolve(opts.root, “babel.config.json”)，否则为 false)默认查找babel.config.json, 但也可以传入js或者json配置文件。注意:这个选项不影响.babelrc.json的加载。因此，虽然可以尝试执行configFile: “./foo/.babelrc.json”，不建议使用。如果给定.babelrc.json是通过标准的文件相对逻辑加载的，你最终会加载相同的配置文件两次，并将其与自身合并。如果要链接一个特定的配置文件，建议使用独立于“babelrc”名称的命名方案。 babelrc(只有当filename选项存在时，为true)允许在Babel的编程选项中，或者在加载的“configFile”中。编程选项将覆盖配置文件选项。设置为true时，允许通过filename查找对应的配置文件注意：只有当”filename”与任意一个” babelrcRoots “包匹配时，才会加载 .babelrc.json文件。 babelrcRoots(默认值：opts.root)允许在Babel的编程选项中，或者在加载的“configFile”中。编程选项将覆盖配置文件选项。 默认情况下，Babel只会在 “root” 包中搜索.babelrc.json文件，因为Babel无法知道给定的.babelrc.json文件是否意味着要加载，或者它的“插件”和“预置”已经安装，因为正在编译的文件可能在node_modules中，或者已经符号链接到项目中。 这个选项允许用户在考虑是否加载.babelrc.json 文件时提供一个应该被视为“根”包的其他包的列表。 1234567babelrcRoots: [ // Keep the root as a root &quot;.&quot;, // Also consider monorepo packages &quot;root&quot; and load their .babelrc.json files. &quot;./packages/*&quot;,]; 插件和预置项plugins注意:该选项也允许Babel本身的Plugin实例，但不建议直接使用。如果你需要创建一个插件或预设的持久表示，你应该使用babel.createConfigItem()。 presets注意:预设的格式与插件相同，除了名称规范化期望“preset-”而不是“plugin-”，并且预设不能是plugin的实例。 Output targets targets(v7.13.0)允许在Babel的编程选项中，或者在加载的“configFile”中。编程选项将覆盖配置文件选项。描述项目支持的环境。这可以是一个与浏览器列表兼容的查询(带有警告): 1234// babel.config.json&#123; &quot;targets&quot;: &quot;&gt; 0.25%, not dead&quot;&#125; 也可以是一个最小支持环境版本的对象 1234567// babel.config.json&#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;58&quot;, &quot;ie&quot;: &quot;11&quot; &#125;&#125; 支持的环境有：android, chrome, deno, edge, electron, firefox, ie, ios, node, opera, rhino, safari, samsung.如果没有指定次要版本，babel将会按照MAJOR.0解析，比如：”node”:12 将会被解析为node.js 12.0 No targets未指定targets时，babel将假定target为尽可能老的浏览器版本。例如：@babel/preset-env 将会把所有的 ES2015-ES2020 代码编译为 ES5兼容版本。 建议设置target以减小打包的代码大小。babel的操作和browserslist不一致：在babel或者browserslist配置中，如果没有找到targets，不会使用defaults作为默认配置，如果想要使用default，需要将defaults设置为target 1234// babel.config.json&#123; &quot;targets&quot;: &quot;defaults&quot;&#125; 注意：这一点有可能在babel的v8中做出修改。 targets.esmodules你也可以标记支持ES模块的浏览器(https://www.ecma-international.org/ecma-262/6.0/#sec-modules)。当esmodules的target被指定时，它将与browser的target和browserslist的target相交。您可以将此方法与结合使用，以便有条件地为用户提供较小的脚本(https://jakearchibald.com/2017/es-modules-in-browsers/#nomodule-for-backwards-compatibility)。 注意：当同时指定browsers和esmodules的target，他们将会相交。 123456// babel.config.json&#123; &quot;targets&quot;: &#123; &quot;esmodules&quot;: true &#125;&#125; targets.node如果想编译当前版本node，可以设置”node”: true 或者 “node”: “current”, 和 “node”: process.versions.node 的作用是一样的也可以在browserslist里面指定node版本（不推荐） 1234// babel.config.json&#123; &quot;targets&quot;: &quot;node 12&quot; // not recommended&#125; 在这种情况下，browserslist将把它解析为node-releases库中可用的最新版本。由于Node.js可能在次要版本中支持新的语言特性，因此为Node.js 12.22生成的程序可能会在Node.js 12.0上抛出语法错误。我们建议你在使用browserslist节点查询时总是指定一个次要版本: 1234// babel.config.json&#123; &quot;targets&quot;: &quot;node 12.0&quot;&#125; targets.safari如果你想编译Safari的技术预览版本，你可以指定” Safari “: “tp”。 targets.browsers使用browserslist选择浏览器(例如: last 2 versions, &gt; 5%, safari tp)的查询。注意，浏览器的结果会被来自targets的显式项覆盖。 targets.deno最小的deno支持版本为1.0 123456// babel.config.json&#123; &quot;targets&quot;: &#123; &quot;deno&quot;: &quot;1.9&quot; &#125;&#125; browserslistConfigFile(默认值：true，7.13.0)允许在Babel的编程选项中，或者在加载的配置文件中。切换是否使用browserslist配置源，包括搜索任何browserslist文件或引用package.json中的browserslist键。这对于使用browserslist配置文件的项目很有用，这些文件不会用Babel编译。 如果指定了字符串，它必须表示browserslist配置文件的路径。相对路径是相对于指定该选项的配置文件解析的，或者当它作为编程选项的一部分传递时，相对路径是相对于cwd解析的。 browserslistEnv(默认值：undefined，7.13.0)允许在Babel的编程选项中，或者在加载的配置文件中。使用的 Browserslist 环境。（https://github.com/browserslist/browserslist#configuring-for-different-environments） Config Merging options extends不允许放在presets里面配置文件可以“扩展”其他配置文件。当前配置中的配置字段将合并到扩展文件的配置之上。 env不能嵌套在另一个env块中。允许整个嵌套配置选项，只有当envKey与envName选项匹配时才会启用。注意:env[envKey]选项将合并在根对象中指定的选项之上。 overrides不能嵌套在另一个overrides对象中，或者在一个env块中。允许用户提供一个选项数组，这些选项将一次一个地合并到当前配置中。该特性最好与“test”/“include”/“exclude”选项一起使用，以提供应该应用覆盖的条件。 12345// JavaScriptoverrides: [&#123; test: &quot;./vendor/large.min.js&quot;, compact: true,&#125;], 可以用来为一个已知是大文件和小文件的特定文件启用compact选项，并告诉Babel不要费心尝试打印该文件。 test当所有匹配失败时，当前配置对象被认为不起作用，并在处理中被忽略。该项在overrides配置项内最有用，但也允许使用在其他地方。注意:这些切换不会影响之前区块中的编程和配置加载选项，因为它们在准备合并的配置之前就已经被添加进去了。 include该项是 test 的同义项。 exclude当任意匹配成功时，当前配置对象被认为不起作用，并在处理中被忽略。该项在overrides配置项内最有用，但也允许使用在其他地方。注意:这些切换不会影响之前区块中的编程和配置加载选项，因为它们在准备合并的配置之前就已经被添加进去了。 ignore不允许放在presets里面。当任意匹配成功时，babel将会立即停止当前build中的所有处理。比如：用户想要禁用lib文件夹中babel的编译可以设置如下配置： 12// JavaScriptignore: [&quot;./lib&quot;]; 注意:此选项禁用文件的所有Babel处理。虽然这有其用途，但作为一种不那么激进的选择，“exclude”选项也值得考虑。 only不允许放在presets里面。当任意匹配失败时，babel将会立即停止当前build中的所有处理。比如：用户想要禁用除src文件夹中以外其他地方的babel的编译可以设置如下配置： 12// JavaScriptonly: [&quot;./src&quot;]; 注意:此选项禁用文件的所有Babel处理。虽然这有其用途，但作为一种不那么激进的选择，”test”/“include” 选项也值得考虑。 Source Map options inputSourceMap(默认值：true)如果文件存在 //# sourceMappingURL=… 注释且设置为true时，会尝试从文件本身加在输入sourcemap。如果找不到map或者map加载解析失败，它将被无声地丢弃如果提供的是object，它将会被当做source map的object sourceMaps(默认值： false) 设置为true时，会为代码生成sourcemap，并包含在结果对象中。 设置为”inline”时，会为代码生成sourcemap，并将其作为一个data url追加到代码里面，但是不会包含在结果对象中。 设置为”both”时，和‘inline’的表现一致，但是map会包含在结果对象中。@babel/cli加载这些也会影响map写入磁盘： 设置为true时，会在磁盘上写入一个.map文件 设置为”inline”时，将会直接写入文件，但在map中会有一个 data: 设置为”both”时，会写入包含data: url的文件和一个.map文件注意:这些选项有点奇怪，因此根据您的用例，使用true并在您自己的代码中处理其余部分可能是最有意义的。 sourceMapsourceMaps的同义项，推荐使用sourceMaps sourceFileName(默认值：可用时为 path.basename(opts.filenameRelative), 或者为 “unknown”)这是source map对象中的文件名。 sourceRoot要在生成的源映射中设置的sourceRoot字段(如果需要的话)。 Misc options sourceType(默认值：module) “script” - 使用 ECMAScript Script 语法解析文件。不允许使用 import/export 语句, 同时文件不是‘strict’ 模式。 “module” - 使用 ECMAScript Module 语法解析文件。文件自动设置‘strict’ 模式，并且允许使用 import/export 语句。 “unambiguous” - 当文件中有 import/export 语句时，作为”module”解析，否则作为”script”解析。unambiguous在type未知时十分有用，但是可能由于module没有使用import/export 语句导致匹配失败，因为它是完全匹配的这个选项很重要，因为当前文件的类型既会影响输入文件的解析，也会影响可能希望向当前文件添加 import/require 用法的某些转换。 例如：@babel/plugin-transform-runtime 依据当前文件的type判定插入import 语句还是require语句。@babel/preset-env 的”useBuiltIns”配置项也是一样的。自从Babel 默认将文件作为ES modules, 这些plugins/presets 也默认插入import语句。这是正确的sourceType非常重要，因为设置了错误的type会导致babel向原本是CommonJS的文件插入import语句。这在需要编译node_modules依赖项的项目中尤为重要，因为插入import语句可能会导致Webpack和其他工具将文件视为ES模块，从而破坏了本来可以正常工作的CommonJS文件。注意:此选项不会影响.mjs文件的解析，因为它们目前是硬编码的，总是解析为“模块”文件。 assumptions(默认值:{}, 7.13.0)允许在编程选项、配置文件和预设中使用。设定Babel可以做出的假设，以产生较小的输出: 1234567// babel.config.json&#123; &quot;assumptions&quot;: &#123; &quot;iterableIsArray&quot;: true &#125;, &quot;presets&quot;: [&quot;@babel/preset-env&quot;]&#125; highlightCode(默认值：true)突出显示Babel错误消息中的代码片段中的标记，使它们更容易阅读。 wrapPluginVisitorMethod（Type: (key: string, nodeType: string, fn: Function) =&gt; Function）允许用户在每个访问者上添加一个包装器，以便在Babel执行插件时检查访问者进程。Key是一个简单的不透明字符串，表示正在执行的插件。nodeType是正在访问的AST代码类型fn是访问者函数用户可以返回一个替换函数，该函数应该在执行他们希望执行的任何日志记录和分析之后调用原始函数。 parserOpts一个不透明的对象，其中包含要传递给正在使用的解析器的选项。有关可用的解析器选项，请参见解析器选项。 generatorOpts一个不透明的对象，包含要传递给代码生成器的选项，可以查看Code Generator Options。 Code Generator options retainLines（默认值：false）babel尝试将源文件中同一行的代码经过生成器后仍在同一行。这个选项的存在是为了让不能使用源映射的用户可以得到模糊有用的错误行号，但这只是最好的选择，并不能保证在所有插件的所有情况下都适用。 compact(默认值：”auto”)“auto”通过计算代码长度大于500_000设置值。在紧凑模式下生成代码时，所有可选的换行符和空格都将被省略。 minified(Default: false)包括compact: true，省略块尾分号，在可能的情况下从new Foo()中省略()，并可能输出更短版本的文字。 auxiliaryCommentBefore允许指定在原始文件中不存在的代码段之前插入前缀注释。注意:原始文件中存在和不存在的定义可能有点难看，因此不建议使用此选项。如果你需要以某种方式注释代码，最好使用Babel插件。 auxiliaryCommentAfter作用与auxiliaryCommentBefore类似，不过是在代码段之后插入前缀注释 comments(默认值：true)如果没有给出函数，则为shouldPrintComment提供默认注释状态。有关更多信息，请参阅该选项的默认值。 shouldPrintCommentType: (value: string) =&gt; booleanDefault without minified: (val) =&gt; opts.comments || /@license|@preserve/.test(val)Default with minified: () =&gt; opts.comments决定给定的注释是否包含在babel输出的代码中。 AMD / UMD / SystemJS module options moduleIds(默认值：!!opts.moduleId)启用模块ID生成功能。 moduleId用于模块的硬编码ID。不能与getModuleId一起使用。 getModuleIdType: (name: string) =&gt; string依据babel生成的模块name，返回要使用的name。返回false值将使用原始名称。 moduleRoot要包含在生成的模块名中的根路径。 Options Concepts MatchPatternType: string | RegExp | (filename: string | void, context: { caller: { name: string } | void, envName: string, dirname: string ) =&gt; boolean几个Babel选项对文件路径执行测试。通常，这些选项支持一种公共模式方法，其中单个模式可以是： string - 一个文件路径，简单地支持*和**作为完整的分段匹配。任何与模式匹配的文件或父文件夹都被视为匹配。路径遵循Node的正常路径逻辑，因此在POSIX上必须以/-分隔，但在Windows上/和\\都被支持。 RegExp - 与规范化文件名匹配的正则表达式。在POSIX上，路径RegExp将在 / 分隔的路径上运行，而在Windows上，它将在 \\ 分隔的路径上运行。重要的是，如果使用这两个选项中的任何一个，Babel要求文件名选项存在，否则将认为它是错误的。 (filename: string | void, context: { caller: { name: string } | void, envName: string, dirname: string }) =&gt; boolean 是一个通用回调，它应该返回一个布尔值来指示是否匹配。该函数传递文件名，如果没有给Babel，则未定义。它还传递了当前的envName和调用者选项，这些选项是由对Babel的顶级调用指定的，而dirname是配置文件的目录或当前工作目录(如果以编程方式调用转换)。 Plugin/Preset entriesPluginEntry / PresetEntry单个插件/预置项可以有几个不同的结构: EntryTarget - 单个插件 [EntryTarget, EntryOptions] - 单个插件 w/ 选项 [EntryTarget, EntryOptions, string] - 带有选项和名称的单个插件(有关名称的更多信息，请参阅合并) ConfigItem - 一个由babel.createConfigItem()创建的插件配置项。同一个EntryTarget可以被多次使用，除非每个都被赋予不同的名称，但是这样做会导致重复插件/预设错误。同时这样做会造成阅读困难：12345678910111213plugins: [ // EntryTarget &#x27;@babel/plugin-transform-classes&#x27;, // [EntryTarget, EntryOptions] [&#x27;@babel/plugin-transform-arrow-functions&#x27;, &#123; spec: true &#125;], // [EntryTarget, EntryOptions, string] [&#x27;@babel/plugin-transform-for-of&#x27;, &#123; loose: true &#125;, &quot;some-name&quot;], // ConfigItem babel.createConfigItem(require(&quot;@babel/plugin-transform-spread&quot;)),], EntryTarget来自不同来源的插件或预置的target:string - 需求样式的路径或插件/预置标识符。标识符将通过名称规范化传递。{} | Function - 一个实际的插件/预设对象或函数在被require()后。EntryOptions每个插件或预置执行时的选项。undefined将被视作空对象。False表示条目完全禁用。这在排序很重要的上下文中很有用，但是需要一个单独的条件来决定是否启用了某些内容。 1234567891011plugins: [ &#x27;one&#x27;, [&#x27;two&#x27;, false], &#x27;three&#x27;,],overrides: [&#123; test: &quot;./src&quot;, plugins: [ &#x27;two&#x27;, ]&#125;] 上面的设置将为src中的文件启用插件two，但插件two仍然会在插件1和插件3之间执行。 名称规范化默认情况下，Babel希望插件的名称中有一个 babel-plugin- 或 babel-preset- 前缀。为了避免重复，Babel有一个名称规范化阶段，将在加载项时自动添加这些前缀。这可以归结为几个基本规则: 传入的绝对路径不受影响 以./开头的相对路径不受影响 包内的文件引用不受影响 任何以module:为前缀的标识符都将删除前缀，但除此之外不受影响 plugin-/preset- will be injected at the start of any @babel-scoped package that doesn’t have it as a prefix. babel-plugin-/babel-preset- will be injected as a prefix any unscoped package that doesn’t have it as a prefix. babel-plugin-/babel-preset- will be injected as a prefix any @-scoped package that doesn’t have it anywhere in their name. babel-plugin/babel-preset will be injected as the package name if only the @-scope name is given.举例如下：| Input | Normalized || “/dir/plugin.js” | “/dir/plugin.js” || “./dir/plugin.js” | “./dir/plugin.js” || “mod” | “babel-plugin-mod” || “mod/plugin” | “mod/plugin” || “babel-plugin-mod” | “babel-plugin-mod” || “@babel/mod” | “@babel/plugin-mod” || “@babel/plugin-mod” | “@babel/plugin-mod” || “@babel/mod/plugin” | “@babel/mod/plugin” || “@scope” | “@scope/babel-plugin” || “@scope/babel-plugin” | “@scope/babel-plugin” || “@scope/mod” | “@scope/babel-plugin-mod” || “@scope/babel-plugin-mod” | “@scope/babel-plugin-mod” || “@scope/prefix-babel-plugin-mod” | “@scope/prefix-babel-plugin-mod” || “@scope/mod/plugin” | “@scope/mod/plugin” || “module:foo” | “foo” | 不透明字符串(https://www.w3.org/html/ig/zh/wiki/File#.E4.B8.8D.E9.80.8F.E6.98.8E.E5.AD.97.E7.AC.A6.E4.B8.B2)不得包含任何未经百分号编码[RFC3986]规定的保留字符，这些字符必须通过百分号编码。不透明字符串必须是全球唯一的。此类字符串应当只使用在U+002A至U+002B、U+002D至U+002E、U+0030至U+0039、U+0041至U+005A, U+005E至U+007E[Unicode]这些范围内的字符，并且应当至少由36个字符组成。UUID是一个潜在的用作[Blob URI]的不透明字符串的可选项，同时强烈推荐使用UUID。UUID由[RFC4122]定义，UUID的ABNF可参见附录A。"},{"title":"babel基础知识- helpers、runtime、template、traverse、types","date":"2023-05-14T02:13:50.000Z","updated":"2023-07-24T09:24:46.477Z","comments":true,"path":"babel/babel-note-5.html","permalink":"https://sunjinkang.github.io/babel/babel-note-5.html","excerpt":"","text":"@babel/helpers工具类，提供了一些内置的函数实现，主要用于babel插件的开发 定义helper 注意:此包仅供包含在此存储库中的包使用。目前第三方插件还没有办法定义helper。helper是在src/ Helpers .js文件中定义的，它们必须是有效的模块，并遵循以下准则: 它们必须具有默认导出，这是它们的入口点。 它们可以通过使用默认导入来导入其他帮助程序。 它们不能有命名出口。123456789helpers.customHelper = defineHelper(` import dep from &quot;dependency&quot;; const foo = 2; export default function getFooTimesDepPlusX(x) &#123; return foo * dep() + x; &#125;`); @babel/runtime@babel/runtime是一个包含Babel模块化运行时helper和regenerator-runtime版本的库。与Babel插件@babel/plugin-transform-runtime一起作为运行时依赖项使用。 12345var _classCallCheck = require(&quot;@babel/runtime/helpers/classCallCheck&quot;);var Circle = function Circle() &#123; _classCallCheck(this, Circle);&#125;; 具体作用可查看：https://www.jiangruitao.com/babel/transform-runtime/ @babel/template123456789101112131415import template from &quot;@babel/template&quot;;import generate from &quot;@babel/generator&quot;;import * as t from &quot;@babel/types&quot;;const buildRequire = template(` var IMPORT_NAME = require(SOURCE);`);const ast = buildRequire(&#123; IMPORT_NAME: t.identifier(&quot;myModule&quot;), SOURCE: t.stringLiteral(&quot;my-module&quot;),&#125;);console.log(generate(ast).code);const myModule = require(&quot;my-module&quot;); .ast如果没有使用占位符，并且您只是想要一种简单的方法将字符串解析为AST，则可以使用模板的. AST版本。 123const ast = template.ast(` var myModule = require(&quot;my-module&quot;);`); AST results@babel/template API提供了一些灵活的API，使创建具有预期结构的ast尽可能容易。它们中的每一个都有上面提到的.ast属性。templatetemplate依据解析结果，返回单个表达式，或者表达式数组 template.smart和template方法一样 template.statementtemplate.statement(“foo;”)() 返回单个表达式节点，其他情况时抛出错误 template.statementstemplate.statements(“foo;foo;”)() 返回表达式节点数组 template.expressiontemplate.expression(“foo”)() 返回表达式节点 template.programtemplate.program(“foo;”)() 返回程序节点 APItemplate(code, [opts])选项@babel/template接受Babel Parser的所有选项，并指定一些自己的默认值: allowReturnOutsideFunction默认值为true. allowSuperOutsideMethod默认值为true. sourceType默认值为module. placeholderWhitelist一组要自动接受的占位符名称。此列表中的项不需要匹配给定的占位符模式。 placeholderPattern（默认值：/^[_$A-Z0-9]+$/）在寻找应该被视为占位符的Identifier和StringLiteral节点时要搜索的模式。’false’将完全禁用占位符搜索，只留下’placeholderWhitelist’值来查找占位符。 preserveComments(默认值false)将其设置为true以保留来自code参数的任何注释。 Return value默认情况下，@babel/template返回一个函数，该函数由一个可选的替换对象调用。有关示例，请参阅用法部分。使用.ast时，直接返回AST数据 @babel/traverse1234567891011121314151617181920212223import * as parser from &quot;@babel/parser&quot;;import traverse from &quot;@babel/traverse&quot;;const code = `function square(n) &#123; return n * n;&#125;`;const ast = parser.parse(code);traverse(ast, &#123; enter(path) &#123; if (path.isIdentifier(&#123; name: &quot;n&quot; &#125;)) &#123; path.node.name = &quot;x&quot;; &#125; &#125;&#125;);// 此外，我们还可以针对语法树中的特定节点类型traverse(ast, &#123; FunctionDeclaration: function(path) &#123; path.node.id.name = &quot;x&quot;; &#125;&#125;) @babel/types方法较多，可依据自身需要使用，文档：https://babel.docschina.org/docs/en/7.0.0/babel-types/"},{"title":"babel基础知识- 配置文件","date":"2023-05-10T10:05:35.000Z","updated":"2023-07-24T09:24:46.477Z","comments":true,"path":"babel/babel-note-3.html","permalink":"https://sunjinkang.github.io/babel/babel-note-3.html","excerpt":"","text":"配置文件Babel 有两种并行的配置文件格式，可以一起使用，也可以单独使用。 项目范围的配置 文件相关配置 .babelrc（和 .babelrc.js）文件 带有 “babel” 键的 package.json 文件 项目范围的配置Babel 7.x 中的新功能，Babel 具有 “root” 目录的概念，默认为 到当前的工作目录。对于项目范围的配置，Babel 将自动搜索 相对对于此根目录下的 “babel.config.js” 。或者，用户可以使用显式 “configFile” 值覆盖默认的配置文件搜索行为。也可以通过将 “configFile” 设置为 false 来禁用项目范围的配置。 配置函数APIJS 配置文件可以导出一个将传递配置函数 API 的函数： 123module.exports = function(api) &#123; return &#123;&#125;;&#125; api 对象暴露的API： api.version正在加载配置文件的 Babel 版本的版本字符串。 api.cache进行缓存设置 api.cache.forever() - Permacache 计算的配置，永远不再调用该函数。api.cache.never() - 不要缓存此配置，并且每次都重新执行该功能。api.cache.using(() =&gt; process.env.NODE_ENV) - 根据 NODE_ENV 的值缓存。 如果using 回调返回的值不是预期的值，将再次调用config函数，并将新条目添加到缓存中。api.cache.invalidate(() =&gt; process.env.NODE_ENV) - 根据 NODE_ENV 的值缓存。 如果using 回调返回的值不是预期的值，将再次调用 config 函数，缓存中的所有条目将替换为结果。api.cache(true) - 与 api.cache.forever() 相同api.cache(false) - 与 api.cache.never() 相同 由于实际的回调结果用于检查缓存条目是否有效，因此建议使用： 回调应该小而且没有副作用。 回调应该返回可能的最小范围的值。例如 .using(() =&gt; process.env.NODE_ENV) 上面的用法并不理想，因为它会造成一个未知的 高速缓存条目的数量取决于检测到多少个 NODE_ENV 值。 .using(() =&gt; process.env.NODE_ENV === “development”) 更安全，因为缓存条目 只能是 true 或 false。 api.env(…)由于 NODE_ENV 是一种相当常见的切换行为方式，因此 Babel 还包含一个 API 函数 专门为此而设。它有几种不同的形式： api.env(“production”) 返回 true 如果 envName === “production”. api.env([“development”, “test”]) 返回 true 如果 [“development”, “test”].includes(envName). api.env() 返回当前的 envName 字符串。 api.env(envName =&gt; envName.startsWith(“test-“)) 如果 env 以 “test-“ 开头，则返回 true。注意:这个函数在内部使用api.cache，以确保Babel知道此构建依赖于特定的envName。你不应该将它与api.cache.forever()或api.cache.never()一起使用。 api.caller(cb)该API用于访问传递给Babel的调用者数据。由于Babel的许多实例可能在具有不同调用者值的相同进程中运行，因此该API被设计为自动配置API.cache，与api.env()相同。caller 值可用作回调函数的第一个参数。 123456789101112function isBabelRegister(caller) &#123; return !!(caller &amp;&amp; caller.name === &quot;@babel/register&quot;);&#125; // 根据特定环境切换配置行为。module.exports = function(api) &#123; const isRegister = api.caller(isBabelRegister); return &#123; // ... &#125;;&#125; api.assertVersion(range)虽然 api.version 在一般情况下很有用，但有时候声明你的版本会很好。 此 API 公开了一种简单的方法： 1234567module.exports = function(api) &#123; api.assertVersion(&quot;^7.2&quot;); return &#123; // ... &#125;;&#125;; @babel/plugin-transform-runtime作用一：自动移除语法转换后内联的辅助函数（inline Babel helpers），使用@babel/runtime/helpers里的辅助函数来替代相关文章：https://www.jiangruitao.com/babel/transform-runtime/ @babel/register@babel/register只有一个功能，就是重写node的require方法。@babel/register在底层改写了node的require方法，在代码里引入@babel/register模块后，所有通过require引入并且以.es6, .es, .jsx 和 .js为后缀名的模块都会经过babel的转译。 123456789101112131415161718192021222324252627282930313233require(&quot;@babel/register&quot;)(&#123; // Array of ignore conditions, either a regex or a function. (Optional) // File paths that match any condition are not compiled. ignore: [ // When a file path matches this regex then it is **not** compiled /regex/, // The file&#x27;s path is also passed to any ignore functions. It will // **not** be compiled if `true` is returned. function(filepath) &#123; return filepath !== &quot;/path/to/es6-file.js&quot;; &#125;, ], // Array of accept conditions, either a regex or a function. (Optional) // File paths that match all conditions are compiled. only: [ // File paths that **don&#x27;t** match this regex are not compiled /my_es6_folder/, // File paths that **do not** return true are not compiled function(filepath) &#123; return filepath === &quot;/path/to/es6-file.js&quot;; &#125; ], // Setting this will remove the currently hooked extensions of `.es6`, `.es`, `.jsx`, `.mjs` // and .js so you&#x27;ll have to add them back if you want them to be used again. extensions: [&quot;.es6&quot;, &quot;.es&quot;, &quot;.jsx&quot;, &quot;.js&quot;, &quot;.mjs&quot;], // Setting this to false will disable the cache. cache: true,&#125;); 注意:@babel/register不支持动态编译本地Node.js ES模块，因为目前还没有稳定的API来拦截ES模块加载。 @babel/preset-env@babel/preset-env是一个智能预设，允许您使用最新的JavaScript，而无需微观管理目标环境需要哪些语法转换(以及可选的浏览器填充)。这既使您的生活更轻松，又使JavaScript包更小! Browserslist Integration对于browser- or Electron-based的项目，我们建议使用.browserslistrc文件来指定目标。你可能已经有了这个配置文件，因为它被生态系统中的许多工具所使用，比如autoprefixer、stylelint、eslint-plugin-compat和许多其他工具。 默认情况下，@babel/preset-env将使用browserslist配置源，除非设置了targets或ignoreBrowserslistConfig选项。 例如，只包含浏览器市场份额&gt;0.25%的用户所需的填充和代码转换(忽略没有安全更新的浏览器，如IE 10和BlackBerry): 1234567891011121314151617&#123; &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, &#123; &quot;useBuiltIns&quot;: &quot;entry&quot; &#125; ] ]&#125;// browserslist&gt; 0.25%not dead// package.json&quot;browserslist&quot;: &quot;&gt; 0.25%, not dead&quot; @babel/preset-flow包含插件 @babel/plugin-transform-flow-strip-types 12345// Infunction foo(one: any, two: number, three?): string &#123;&#125;// Outfunction foo(one, two, three) &#123;&#125; 配置项：all（默认值为 false） 如果文件顶部有@flow pragma，或者在.flowconfig中设置了all选项，那么Flow只会解析特定于Flow的特性。如果您在Flow配置中使用all选项，请确保将此选项设置为true以获得匹配的行为。例如，如果没有上述集合中的任何一个，下面的调用表达式带有类型参数: 12345// Inf&lt;T&gt;(e)// Outf &lt; T &gt; e; @babel/preset-react包含插件： @babel/plugin-syntax-jsx @babel/plugin-transform-react-jsx @babel/plugin-transform-react-display-name使用development选项时: @babel/plugin-transform-react-jsx-self @babel/plugin-transform-react-jsx-source在v7中不再启用流语法支持。为此，您需要添加Flow预设。 选项：pragma(默认值：React.createElement) pragmaFrag(默认值：React.Fragment) useBuiltIns(默认值：false)Will use the native built-in instead of trying to polyfill behavior for any plugins that require one. development(默认值：false)用于切换开发的插件，比如： @babel/plugin-transform-react-jsx-self 和 @babel/plugin-transform-react-jsx-source.这在与env选项配置或js配置文件结合使用时非常有用。 throwIfNamespace(默认值：true)切换是否在使用XML名称空间标记名时抛出错误。比如：&lt;f:image /&gt;虽然JSX规范允许这样做，但由于React的JSX目前不支持，因此默认情况下是禁用的 1234567891011// .babelrc.jsmodule.exports = &#123; presets: [ [ &quot;@babel/preset-react&quot;, &#123; development: process.env.BABEL_ENV === &quot;development&quot;, &#125;, ], ],&#125;; @babel/preset-typescript包含插件： @babel/plugin-transform-typescript需要为 @babel/cli 和 @babel/node 处理 .ts 文件指定 –extensions “.ts” 选项：isTSX（默认值：false）强制启用jsx解析。否则，尖括号将被视为typescript的遗留类型断言var foo = bar;同时，isTSX: true 要求 allExtensions: true. jsxPragma（默认值：React）替换编译JSX表达式时使用的函数。这样我们就知道导入不是类型导入，不应该被删除。 allExtensions(默认值：false)指示每个文件应解析为TS或TSX(取决于isTSX选项)。"},{"title":"babel基础知识- parser、core、generator、code-frame","date":"2023-05-12T12:23:42.000Z","updated":"2023-07-24T09:24:46.477Z","comments":true,"path":"babel/babel-note-4.html","permalink":"https://sunjinkang.github.io/babel/babel-note-4.html","excerpt":"","text":"@babel/parser_作用_： 默认启用的最新 ECMAScript 版本(ES2017)。 附件发表评论。 支持 JSX, Flow, Typescript。 支持实验性语言提案(至少接受 0 阶段的 pr)。 APIbabelParser.parse(code, [options])babelParser.parseExpression(code, [options])parse()将所提供的代码作为一个完整的 ECMAScript 程序进行解析，而 parseExpression()则尝试在考虑性能的情况下解析单个表达式。如果有疑问，请使用.parse()。 Option allowImportExportEverywhere: 默认情况下，导入和导出声明只能出现在程序的顶层。将此选项设置为 true 允许在任何允许语句的地方使用它们。 allowAwaitOutsideFunction: 默认情况下，await 不允许在 async 函数外部使用，将此选项设置为 true 允许外部使用 await。 allowReturnOutsideFunction: 默认情况下，顶层的 return 语句会引发错误。将此设置为 true 以接受此类代码。 allowSuperOutsideMethod: 默认情况下，不允许在类和对象方法之外使用 super。将此设置为 true 以接受此类代码。 sourceType: 指示应该解析代码的模式。可以是“script”、“module”或“unambiguous”之一。默认为“script”。“unambiguous”会让@babel/parser 根据 ES6 的 import 或 export 语句进行猜测。带有 ES6 导入和导出的文件被认为是“模块”，否则就是“脚本”。 sourceFilename: 将输出 AST 节点与其源文件名关联起来。在从多个输入文件的 ast 生成代码和源映射时非常有用。 startLine: 默认情况下，解析的第一行代码被视为第 1 行。您可以提供一个行号作为开头。与其他源工具集成时有用。 plugins: 想要启用的插件数组 strictMode: 默认情况下，ECMAScript 代码只在”use strict”;指令存在，或者被解析的文件是 ECMAScript 模块才使用严格模式。将此选项设置为 true 以始终以严格模式解析文件。 ranges: 为每个节点添加一个 ranges 属性: [node.start, node.end] tokens: 将所有解析过的令牌添加到“文件”节点上的令牌属性 OutputBabel 解析器根据 Babel AST 格式生成 AST。它基于具有以下偏差的 ESTree 规范: 现在有一个 estree 插件可以恢复这些偏差 文字标记被 StringLiteral, NumericLiteral, BooleanLiteral, NullLiteral, RegExpLiteral 所取代 属性令牌替换为 ObjectProperty 和 ObjectMethod MethodDefinition 替换为 ClassMethod Program 和 BlockStatement 包含额外的指令字段 Directive 和 DirectiveLiteral FunctionExpression 中的 ClassMethod、ObjectProperty 和 ObjectMethod value property 的属性被强制/引入到主方法节点中。AST for JSX code 是基于 Facebook JSX AST. SemverBabel Parser 在大多数情况下跟随 semver。唯一需要注意的是，一些符合规范的错误修复可能会在补丁版本下发布。 Example 12345678910require(&#x27;@babel/parser&#x27;).parse(&#x27;code&#x27;, &#123; // parse in strict mode and allow module declarations sourceType: &#x27;module&#x27;, plugins: [ // enable jsx and flow syntax &#x27;jsx&#x27;, &#x27;flow&#x27;, ],&#125;); @babel/core方法transform babel.transform(code: string, options?: Object, callback: Function)转换传入的代码，回调函数中有生成代码、源码映射和 AST 的对象 123babel.transform(code, options, function (err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;); transformSync babel.transformSync(code: string, options?: Object)转换传入的代码，返回一个拥有生成代码、源码映射和 AST 的对象 1babel.transformSync(code, options); // =&gt; &#123; code, map, ast &#125; transformAsync babel.transformAsync(code: string, options?: Object) 1babel.transformAsync(code, options); // =&gt; Promise&lt;&#123; code, map, ast &#125;&gt; transformFile babel.transformFile(filename: string, options?: Object, callback: Function)异步转换整个文件内容 12345babel.transformFile(filename, options, callback);babel.transformFile(&#x27;test.js&#x27;, options, function (err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;); transformFileSync babel.transformFileSync(filename: string, options?: Object) 1babel.transformFileSync(filename, options); // =&gt; &#123; code, map, ast &#125; transformFileAsync babel.transformFileAsync(filename: string, options?: Object) 1babel.transformFileAsync(filename, options); // =&gt; Promise&lt;&#123; code, map, ast &#125;&gt; transformFromAst babel.transformFromAst(ast: Object, code?: string, options?: Object, callback: Function): FileNode | null传入 AST 进行转换 1234567const sourceCode = &#x27;if (true) return;&#x27;;const parsedAst = babel.parse(sourceCode, &#123; parserOpts: &#123; allowReturnOutsideFunction: true &#125;,&#125;);babel.transformFromAst(parsedAst, sourceCode, options, function (err, result) &#123; const &#123; code, map, ast &#125; = result;&#125;); transformFromAstSync babel.transformFromAstSync(ast: Object, code?: string, options?: Object) 123456789const sourceCode = &#x27;if (true) return;&#x27;;const parsedAst = babel.parse(sourceCode, &#123; parserOpts: &#123; allowReturnOutsideFunction: true &#125;,&#125;);const &#123; code, map, ast &#125; = babel.transformFromAstSync( parsedAst, sourceCode, options); transformFromAstAsync babel.transformFromAstAsync(ast: Object, code?: string, options?: Object) 123456789const sourceCode = &#x27;if (true) return;&#x27;;babel .parseAsync(sourceCode, &#123; parserOpts: &#123; allowReturnOutsideFunction: true &#125; &#125;) .then((parsedAst) =&gt; &#123; return babel.transformFromAstAsync(parsedAst, sourceCode, options); &#125;) .then((&#123; code, map, ast &#125;) =&gt; &#123; // ... &#125;); parse babel.parse(code: string, options?: Object, callback: Function)给定一些代码，使用 Babel 的标准行为对其进行解析。将加载引用的预设和插件，以便自动启用可选的语法插件。 parseSync babel.parseSync(code: string, options?: Object)返回一个 AST parseAsync babel.parseAsync(code: string, options?: Object)返回一个 AST 的 Promise DEFAULT_EXTENSIONS babel.DEFAULT_EXTENSIONS: ReadonlyArraybabel 支持的默认扩展列表(“.js”, “.jsx”, “.es6”, “.es”, “.mjs”)。@babel/register 和@babel/cli 使用这个列表来确定哪些文件需要编译。扩展这个列表是不可能的，但是@babel/cli 确实提供了使用 ——extensions 来支持其他扩展的方法。 @babel/generatorOptions(输出格式选项)| name | type | default | description |auxiliaryCommentBefore | string | | Optional string to add as a block comment at the start of the output file |auxiliaryCommentAfter | string | | Optional string to add as a block comment at the end of the output file |shouldPrintComment | function | opts.comments | Function that takes a comment (as a string) and returns true if the comment should be included in the output. By default, comments are included if opts.comments is true or if opts.minified is false and the comment contains @preserve or @license || retainLines | boolean | false | Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces) || retainFunctionParens | boolean | false | Retain parens around function expressions (could be used to change engine parsing behavior) || comments | boolean | true | Should comments be included in output || compact | boolean or ‘auto’ | opts.minified | Set to true to avoid adding whitespace for formatting || minified | boolean | false | Should the output be minified || concise | boolean | false | Set to true to reduce whitespace (but not as much as opts.compact) || filename | string | | Used in warning messages || jsonCompatibleStrings | boolean | false | Set to true to run jsesc with “json”: true to print “\\u00A9” vs. “©”; || jsescOption | object | | Use jsesc to process string literals. You can customize jsesc by passing options to it. | Options(源码映射选项)| name | type | default | description || sourceMaps | boolean | false | Enable generating source maps || sourceRoot | string | | A root for all relative URLs in the source map || sourceFileName | string | | The filename for the source code (i.e. the code in the code argument). This will only be used if code is a string.| AST from Multiple Sources在大多数情况下，Babel在输入文件到输出文件之间进行1:1的转换。但是，您可能要处理由多个源(JS文件、模板等)构造的AST。如果是这种情况，并且希望源映射反映正确的源，则需要传递一个要生成的对象作为代码参数。键应该是源文件名，值应该是源内容。 123456789101112131415161718import &#123;parse&#125; from &#x27;@babel/parser&#x27;;import generate from &#x27;@babel/generator&#x27;;const a = &#x27;var a = 1;&#x27;;const b = &#x27;var b = 2;&#x27;;const astA = parse(a, &#123; sourceFilename: &#x27;a.js&#x27; &#125;);const astB = parse(b, &#123; sourceFilename: &#x27;b.js&#x27; &#125;);const ast = &#123; type: &#x27;Program&#x27;, body: [].concat(astA.program.body, astB.program.body)&#125;;const &#123; code, map &#125; = generate(ast, &#123; sourceMaps: true &#125;, &#123; &#x27;a.js&#x27;: a, &#x27;b.js&#x27;: b&#125;);// Sourcemap will point to both a.js and b.js where appropriate. @babel/code-frame用于生成错误信息并且打印出错误原因和错误行数。（其实就是个console工具类） 123456789101112131415161718192021222324252627282930313233343536373839import &#123; codeFrameColumns &#125; from &#x27;@babel/code-frame&#x27;;const rawLines = `class Foo &#123; constructor()&#125;`;const location = &#123; start: &#123; line: 2, column: 16 &#125; &#125;;const result = codeFrameColumns(rawLines, location, &#123; /* options */ &#125;);console.log(result); 1 | class Foo &#123;&gt; 2 | constructor() | ^ 3 | &#125;// 注意：列未知时也可以省略import &#123; codeFrameColumns &#125; from &#x27;@babel/code-frame&#x27;;const rawLines = `class Foo &#123; constructor() &#123; console.log(&quot;hello&quot;); &#125;&#125;`;const location = &#123; start: &#123; line: 2, column: 17 &#125;, end: &#123; line: 4, column: 3 &#125; &#125;;const result = codeFrameColumns(rawLines, location, &#123; /* options */ &#125;);console.log(result); 1 | class Foo &#123;&gt; 2 | constructor() &#123; | ^&gt; 3 | console.log(&quot;hello&quot;); | ^^^^^^^^^^^^^^^^^^^^^^^^^&gt; 4 | &#125; | ^^^ 5 | &#125;; 选项highlightCode(默认值false)切换语法，将代码高亮显示为终端的JavaScript。 linesAbove(默认值 2) 调整行数以显示上面的错误。 linesBelow(默认值 3)调整行数以显示下面的错误。 forceColor(默认值 false)启用此功能以强制语法高亮显示代码为JavaScript(对于非终结符);覆盖highlightCode。 message传入一个字符串，在代码中突出显示的位置旁边内联显示(如果可能的话)。如果它不能内联定位，它将被放置在代码框架之上。 12341 | class Foo &#123;&gt; 2 | constructor() | ^ Missing &#123;3 | &#125;;"},{"title":"babel插件笔记","date":"2023-04-09T02:12:34.000Z","updated":"2023-07-24T09:24:46.478Z","comments":true,"path":"babel/index.html","permalink":"https://sunjinkang.github.io/babel/index.html","excerpt":"","text":"什么是babel？Babel 是一个通用的多功能的 JavaScript 编译器，是一种从源码到源码的编译器，将拿到的代码进行处理后生成新的代码。此外它还拥有众多模块可用于不同形式的静态分析。 静态分析是在不需要执行代码的前提下对代码进行分析的处理过程 （执行代码的同时进行代码分析即是动态分析）。 静态分析的目的是多种多样的， 它可用于语法检查，编译，代码高亮，代码转换，优化，压缩等等场景。 抽象语法树中的处理type类型的方法：将页面代码复制到在线转换网页中，看有哪些type类型，哪些type类型是需要转换的，依据这个去做处理。没有好的办法解决在一个页面中处理完成，在另一个页面中出现新的需要处理的type，方法：1、新的页面在在线转换网页中转换处理一下，看需要处理的是否都已处理2、另写一个脚本，去做比较，看看两边的结果是否一致，或原有的转换之后，另一个脚本是否又做了处理 babel笔记1 babel笔记2 babel笔记3 babel笔记4 babel笔记5 babel插件练习：https://github.com/sunjinkang/custom_replace_babel_plugin javascript duck-typing接口 lebab：https://github.com/lebab/lebab和babel作用相反 css中使用 white-space: pre-wrap;如果行位存在空格的话会挂起，使用white-space: break-spaces;时行位空格会保留这个挂起是什么意思？挂起和保留的区别是什么？"},{"title":"分类","date":"2024-03-27T09:48:19.000Z","updated":"2024-03-27T09:58:50.489Z","comments":true,"path":"categories/index.html","permalink":"https://sunjinkang.github.io/categories/index.html","excerpt":"","text":"Babel Vue NodeJS Unity Git Linux"},{"title":"Git - 常用的git命令","date":"2024-03-21T02:28:30.000Z","updated":"2024-03-21T02:47:54.289Z","comments":true,"path":"git/about-git-1.html","permalink":"https://sunjinkang.github.io/git/about-git-1.html","excerpt":"","text":"Git批量删除分支命令 git branch -a | grep ‘匹配文字’ | xargs git branch -D 注意：上面这个命令的意思是 git branch -a列出所有远程和本地分支 grep ‘匹配文字’筛选出匹配该模式的分支 xargs git branch -D将这些分支传递给git branch -D以批量删除 上面这个命令会同时删除远程的匹配到的分支，找不到时会提示，不建议使用，建议使用下面这个命令仅删除本地分支 git branch | grep ‘匹配文字’ | xargs git branch -D PS: 上面的命令在vscode的终端中以powershell模式运行时会报错，可改为Git Bash模式运行。"},{"title":"","date":"2024-03-21T02:27:25.985Z","updated":"2024-03-21T02:27:25.985Z","comments":true,"path":"git/index.html","permalink":"https://sunjinkang.github.io/git/index.html","excerpt":"","text":""},{"title":"linux - 关于磁盘命令","date":"2024-02-11T11:23:54.000Z","updated":"2024-02-28T03:10:44.904Z","comments":true,"path":"linux/linux-command-1.html","permalink":"https://sunjinkang.github.io/linux/linux-command-1.html","excerpt":"","text":"linux查看磁盘使用情况命令1234567891011121314151617181920语法：df [选项]... [FILE]...-a, --all 包含所有的具有 0 Blocks 的文件系统--block-size=&#123;SIZE&#125; 使用 &#123;SIZE&#125; 大小的 Blocks-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024-i, --inodes 列出 inode 资讯，不列出已使用 block-k, --kilobytes 就像是 --block-size=1024-l, --local 限制列出的文件结构-m, --megabytes 就像 --block-size=1048576--no-sync 取得资讯前不 sync (预设值)-P, --portability 使用 POSIX 输出格式--sync 在取得资讯前 sync-t, --type=TYPE 限制列出文件系统的 TYPE-T, --print-type 显示文件系统的形式-x, --exclude-type=TYPE 限制列出文件系统不要显示 TYPE-v (忽略)--help 显示这个帮手并且离开--version 输出版本资讯并且离开 使用命令举例说明Filesystem：代表该文件系统所有的分区1K-blocks：说明下面的数字单位是1KB（默认），可利用-h或-m来改变容量Used：已经使用的硬盘空间Available：剩下的磁盘空间大小Use%：磁盘使用率Mounted on：磁盘挂载的目录所在（挂载点） 以 MB 为单位查看磁盘占用情况 123456789101112131415root@ubuntu:~# df -mFilesystem 1M-blocks Used Available Use% Mounted onudev 16072 0 16072 0% /devtmpfs 3217 10 3208 1% /run/dev/vda1 396797 78460 318321 20% /tmpfs 16085 0 16085 0% /dev/shmtmpfs 5 0 5 0% /run/locktmpfs 16085 0 16085 0% /sys/fs/cgroup/dev/vda15 105 9 96 9% /boot/efioverlay 396797 78460 318321 20% /var/lib/docker/overlay2/04c65d21c919fc334c6cf13c2c3f3f5246c68591ff99335016cc5a49a2da0118/mergedoverlay 396797 78460 318321 20% /var/lib/docker/overlay2/9c36fd2e009478330599a29068dfdb363be16726381b52f120e233241f1b2790/mergedoverlay 396797 78460 318321 20% /var/lib/docker/overlay2/b844f9a9ae8f4d8799a5c00960aa1011498e299a00246f81edb2a362fec82772/mergedoverlay 396797 78460 318321 20% /var/lib/docker/overlay2/6176224b017c21cd8c2c290b1c1cb4b3adf3d464498a558271c837db4c9f7fc7/mergedoverlay 396797 78460 318321 20% /var/lib/docker/overlay2/b7e90c6775a6d381fc028cd3b76a49b37743b888fb6045e8f6ebde6f582cae41/mergedtmpfs 3217 0 3217 0% /run/user/0 使用人类友好的单位查看磁盘占用情况 123456789101112131415root@ubuntu:~# df -hFilesystem Size Used Avail Use% Mounted onudev 16G 0 16G 0% /devtmpfs 3.2G 9.1M 3.2G 1% /run/dev/vda1 388G 77G 311G 20% /tmpfs 16G 0 16G 0% /dev/shmtmpfs 5.0M 0 5.0M 0% /run/locktmpfs 16G 0 16G 0% /sys/fs/cgroup/dev/vda15 105M 8.9M 96M 9% /boot/efioverlay 388G 77G 311G 20% /var/lib/docker/overlay2/04c65d21c919fc334c6cf13c2c3f3f5246c68591ff99335016cc5a49a2da0118/mergedoverlay 388G 77G 311G 20% /var/lib/docker/overlay2/9c36fd2e009478330599a29068dfdb363be16726381b52f120e233241f1b2790/mergedoverlay 388G 77G 311G 20% /var/lib/docker/overlay2/b844f9a9ae8f4d8799a5c00960aa1011498e299a00246f81edb2a362fec82772/mergedoverlay 388G 77G 311G 20% /var/lib/docker/overlay2/6176224b017c21cd8c2c290b1c1cb4b3adf3d464498a558271c837db4c9f7fc7/mergedoverlay 388G 77G 311G 20% /var/lib/docker/overlay2/b7e90c6775a6d381fc028cd3b76a49b37743b888fb6045e8f6ebde6f582cae41/mergedtmpfs 3.2G 0 3.2G 0% /run/user/0 列出文件系统下所有特殊文件格式的磁盘使用情况 123456789101112root@ubuntu:~# df -aTFilesystem Type 1K-blocks Used Available Use% Mounted onsysfs sysfs 0 0 0 - /sysproc proc 0 0 0 - /procudev devtmpfs 16457540 0 16457540 0% /devdevpts devpts 0 0 0 - /dev/ptstmpfs tmpfs 3294040 9316 3284724 1% /run/dev/vda1 ext4 406319508 80461588 325841536 20% /securityfs securityfs 0 0 0 - /sys/kernel/securitytmpfs tmpfs 16470180 0 16470180 0% /dev/shmtmpfs tmpfs 5120 0 5120 0% /run/locktmpfs tmpfs 16470180 0 16470180 0% /sys/fs/cgroup 列出指定文件路径下的磁盘使用情况 1234# df -h [路径]root@ubuntu:~# df -h /usrFilesystem Size Used Avail Use% Mounted on/dev/vda1 388G 77G 311G 20% / 输出版本咨询 12345678root@ubuntu:~# df --versiondf (GNU coreutils) 8.28Copyright (C) 2017 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;.This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Written by Torbjorn Granlund, David MacKenzie, and Paul Eggert. du：列出文件系统下的目录大小，disk usage举例 123456789101112root@ubuntu:~# du4 ./.cache8 ./.ssh24 ./quick-usage/upgrade40 ./quick-usage/deploy/compose28 ./quick-usage/deploy/dble12 ./quick-usage/deploy/compose_v1680 ./quick-usage/deploy716 ./quick-usage4 ./.gnupg/private-keys-v1.d8 ./.gnupg768 . du参数说明 123456-a : 列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已；-h : 以人们较易读的容量格式（G/M）显示；-s : 列出总量，而不列出每个个别的目录占用了容量；-S : 不包括子目录下的总计，与-s有点差别；-k : 以KB列出容量显示；-m : 以MB列出容量显示 查看usr/下的所有文件大小并根据大小降序排列 1234567891011121314# 使用的时候，下面这几个命令展示的结果是一样的，但是less命令的展示效果类似查看文件# du -sm /usr/* | sort -nr | less# du -sm /usr/* | sort -nr | more# du -sm /usr/* | sort -nrroot@ubuntu:~# du -sm /usr/* | sort -nr | lessroot@ubuntu:~# du -sm /usr/* | sort -nr | more468 /usr/lib376 /usr/bin271 /usr/src202 /usr/share31 /usr/sbin13 /usr/local1 /usr/include1 /usr/games 查看usr目录下占用前5的文件 123456root@ubuntu:~# du -sm /usr/* | sort -nr | head -n 5468 /usr/lib376 /usr/bin271 /usr/src202 /usr/share31 /usr/sbin df是查看文件系统的磁盘使用情况，包含已删除但为被OS释放的文件所占用的容量大小du是查看目录大小，不包含已删除的文件 查看已被删除但未释放的文件lsof (list opened files) 123456lsof -wn |grep deletedsystemd-l 731 root txt REG 252,1 219272 2005 /lib/systemd/systemd-logind (deleted)dbus-daem 769 messagebus txt REG 252,1 236584 4307 /usr/bin/dbus-daemon (deleted)agetty 1682 root txt REG 252,1 56552 3846 /sbin/agetty (deleted)mysqld 20656 5700 6u REG 0,152 0 4394263 /opt/udb/mysql/tmp/iblcR0CS (deleted)mysqld 20656 5700 7u REG 0,152 0 4394264 /opt/udb/mysql/tmp/ib9DHifd (deleted) 注意如果使用 ( lsof -n |grep deleted ) 命令查看时，可能会出现以下错误lsof: no pwd entry for UID 5701 错误原因1.进程在用户被删除之前启动，并且从那以后一直在运行2.进程在容器内被启动 解决方法-w 是指忽略这些错误 以上内容可在man手册中查看具体内容man手册地址：https://man7.org"},{"title":"linux - 软件管理(1)-yum","date":"2024-02-17T01:41:46.000Z","updated":"2024-03-21T11:20:23.722Z","comments":true,"path":"linux/linux-command-2.html","permalink":"https://sunjinkang.github.io/linux/linux-command-2.html","excerpt":"","text":"软件包类型 DEB #适用于UBlinux和DEBlinux这两种Linux系统RPM #适用于redhat、centOS以及fadora这三种Linux系统bz2|gz|xz #压缩包类型，分为两种: 一种解压缩后需要安装需要源码编译，如插件ntfs-3g_ntfsprogs-2017.3.23.tgz,需要编译 “configure”另一种是绿色软件，解压缩以后可以直接使用，不需要安装，如Firefox-latest-x86_64.tar.bz2 Yumyum，全称“Yellow dog Updater, Modified”，是一个专门为了解决包的依赖关系而存在的软件包管理器。 网络 yum 源配置文件位于 /etc/yum.repos.d/ 目录下，文件扩展名为*.repo（只要扩展名为 *.repo 的文件都是 yum 源的配置文件）。查看目录下的CentOS-Base.repo文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 以下为一个 CentOS-Base.repo 文件的举例，缺少mirrorlist[root@62-7-udp-1 yum.repos.d]# cat CentOS-Base.repo # CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead.## [base]name=CentOS-$releasever - Base - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/os/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/os/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #released updates [updates]name=CentOS-$releasever - Updates - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/updates/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/updates/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that may be useful[extras]name=CentOS-$releasever - Extras - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/extras/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/extras/$basearch/gpgcheck=1gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plus - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/centosplus/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/centosplus/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 #contrib - packages by Centos Users[contrib]name=CentOS-$releasever - Contrib - mirrors.aliyun.comfailovermethod=prioritybaseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/gpgcheck=1enabled=0gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-7 [extras]yum的ID，必须唯一的，本地有多个yum源的时候，这里也必须是唯一的。 name 具体的yum源名称，相当于对它的描述信息。 mirrorlist 是镜像服务器地址列表，里面有很多的服务器地址。 baseurl 和mirrorlist一样，都是指向yum源的地址，不同的是包含地址的多少，一般只写一个地址，直接用baseurl。 gpgcheck 0=取消验证，1=使用公钥检验rpm的正确性。 gpgkey 校验的key地址，如果gpgcheck=0的话，那么gpgkey就可以不用填写。 failovermethod 有两个选项roundrobin 和priority，意思分别是有多个url可供选择时，yum 选择的次序，roundrobin 是随机选择，如果连接失败则使用下一个，依次循环，priority 则根据url 的次序从第一个开始。如果不指明，默认是roundrobin yum通常会有一个配置文件yum.conf，一般位于 etc文件夹下 123456789101112131415161718192021222324252627282930# 以下为一个yum.conf文件的举例[root@62-7-udp-1 etc]# cat yum.conf[main]cachedir=/var/cache/yum/$basearch/$releaseverkeepcache=0debuglevel=2logfile=/var/log/yum.logexactarch=1obsoletes=1gpgcheck=1plugins=1installonly_limit=5bugtracker_url=http://bugs.centos.org/set_project.php?project_id=23&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yumdistroverpkg=centos-releaseoverride_install_langs=en_US.UTF-8tsflags=nodocs# This is the default, if you make this bigger yum won&#x27;t see if the metadata# is newer on the remote and so you&#x27;ll &quot;gain&quot; the bandwidth of not having to# download the new metadata and &quot;pay&quot; for it by yum not having correct# information.# It is esp. important, to have correct metadata, for distributions like# Fedora which don&#x27;t keep old packages around. If you don&#x27;t like this checking# interupting your command line usage, it&#x27;s much better to have something# manually check the metadata once an hour (yum-updatesd will do this).# metadata_expire=90m# PUT YOUR REPOS HERE OR IN separate files named file.repo# in /etc/yum.repos.d 配置说明 cachedir yum缓存的目录，yum在此存储下载的rpm包和数据库，一般情况下路径是/var/cache/yum/$basearch/$releasever keepcache 是否保留缓存内容，0=安装后删除软件包，1=安装后保留软件包 debuglevel 除错级别，0-10，默认是2，只记录安装和删除记录。 logfile 存放系统更新软件的日志的目录。可以根据路径去查询自己在过期做了哪些更新。 exactarch 代表是否只升级和你安装软件包CPU体系一致的包，有1和0两个选项，1为是，0为否。 obsoletes 这是一个update的参数，是否允许旧版本的运行，1表示允许。 gpgcheck 是否验证GPG(GNU Private Guard)密钥，1表示验证。 plugins 是否允许插件，1代表允许。 installonly_limit 保存几个内核。 pkgpolicy 包的策略，一共有两个选项，newest和last，这个的作用是如果设置了多个源，而同一个软件在不通的源中同时存在，yum应该选哪一个。如果是newest，则会安装最新的那个版本。如果是last，这回将服务器ID以字母排序，并选择最后的那个服务器上的软件。 distroverpkg 指定一个软件包，yum会根据这个包判断发行版本，默认是RedHat-release，也可以是CentOS-release。 tolerant 表示yum是否容忍命令行发生与软件包有关的错误，有1和0两个选项。 retries 网络链接发生错误时的重试次数，如果设置为0，则会无限重试 override_install_langs 这是一种覆盖rpm的_install_lang宏的方法。而不必在rpm的宏文件中更改它。默认值为nothing。 tsflags 要传递给rpm事务集的事务标志的逗号或空格分隔的列表。这些包括’noscripts’， ‘notriggers’， ‘nodocs’， ‘test’， ‘justdb’和’nocontexts’。’repackage’也可用，但对于较新的RPM版本不起作用。您可以设置所有或其中任何一个。但是，如果您不知道它们在rpm事务集上下文中的作用，那么最好不要去管它。默认值为空列表。 yum的repo配置文件中可用的变量： $releasever: 当前OS的发行版的主版本号，如：8，7，6 $arch: CPU架构，如：arch64, i586, i686，x86_64等 $basearch：系统基础平台；i386, x86_64 $contentdir：表示目录，比如：centos-8，centos-7 $YUM0-$YUM9:自定义变量 yum的具体配置可查看man手册：https://man7.org/linux/man-pages/man5/yum.conf.5@@yum.html yum的常见命令123456789101112131415161718192021222324252627282930313233yum install [软件包名称] # 安装软件包 yum search [软件包名称] # 搜索软件包yum list [软件包名称] # 显示指定程序包安装情况yum list # 显示所有已安装及可安装的软件包yum remove [软件包名称] # 删除程序包yum erase [软件包名称] # 删除程序包yum update # 内核升级或者软件更新yum update [软件包名称] # 更新软件包yum check-update # 检查可更新的程序yum info [软件包名称] # 显示安装包信息yum provides &quot;*/rz&quot; # 列出 rz 命令由哪个软件包提供yum grouplist # 查询可以用 groupinstall 安装的组名称yum groupinstall [组名称] # 安装程序组yum groupremove [组名称] # 删除程序组yum deplist [软件包名称] # 查看程序依赖情况yum clean packages # 清除缓存目录下的软件包yum clean headers # 清除缓存目录下的 headersyum clean all # 清除缓存目录下的所有缓存yum makecache # 建立元数据缓存yum -y update # 升级所有软件包和系统内核yum -y upgrade # 只升级软件包不升级内核# 注意：-y 表示自动安装，不需要交互，如果不加 -y ，安装中会出现问询，需要手动处理。# -y 下载安装# 以下两种试了一下，并不能用于命令中，会导致命令直接报错# -d 只下载不安装# -N 不安装#downloadonly可以仅下载所需软件和及其依赖包，大大解决了无网安装时找依赖包的问题yum install [软件包名称] --downloadonly --downloaddir=/tmp/mysoftware 注意以上命令大部分可同时安装多个软件包或查询多个命令，具体使用可查看man手册https://man7.org/linux/man-pages/man8/yum.8@@yum.html 某些系统中的，或者是某个包需要掌握换源这类知识。进程守护 systemctrl DMP使用进程守护拉起来ushard分库分表和读写分离写了大量日志，不用的话可以卸载 扩展数据库组件用的"},{"title":"linux - 软件管理(2)-rpm","date":"2024-02-21T07:41:52.000Z","updated":"2024-03-18T05:24:36.317Z","comments":true,"path":"linux/linux-command-3.html","permalink":"https://sunjinkang.github.io/linux/linux-command-3.html","excerpt":"","text":"什么是RPM？RPM（Red Hat Package Manager）是一种常见且强大的二进制软件包管理工具，它以 .rpm 格式打包软件，并提供了一系列命令和工具来方便地安装、升级、查询和卸载软件包。 常见命令及举例 安装、卸载rpm软件包安装命令： rpm -i [软件包名]rpm -ivh [软件包名] -i 安装软件包-v 显示详细输出-h 显示安装进度根据需要，安装命令可能需要在前面加 sudo注意：rpm安装包时，包名一定要完整[root@diagno opt]# rpm -i httpderror: open of httpd failed: No such file or directory使用 rpm -ivh /路径/完整包名 才能正常安装。但是，使用yum时，直接使用 yum install httpd 即可安装，yum会自行解决包之间的依赖关系rpm安装一般不用，因为不能解决包之间的依赖关系 卸载命令： rpm -e [软件包名] 查询、验证rpm软件的相关信息命令： rpm -q [软件包名] 查询是否下载软件包（常用）rpm -qa [软件包名] 查询已下载的软件包的信息rpm -ql [软件包名] 查询已下载的软件包的安装列表rpm -qc [软件包名] 只想知道已下载软件包的配置文件rpm -qi [软件包名] 查询下载软件包的基础信息 12345678910111213141516171819202122232425262728293031323334353637383940[root@diagno opt]# rpm -q httpdhttpd-2.4.6-99.el7.centos.1.x86_64[root@diagno opt]# rpm -qa httpdhttpd-2.4.6-99.el7.centos.1.x86_64[root@diagno opt]# rpm -ql httpd/etc/httpd/etc/httpd/conf/etc/httpd/conf.d/etc/httpd/conf.d/README...# 一堆安装列表文件/var/www/html[root@diagno opt]# rpm -qc httpd/etc/httpd/conf.d/autoindex.conf/etc/httpd/conf.d/userdir.conf/etc/httpd/conf.d/welcome.conf...# 一堆配置文件/etc/sysconfig/httpd[root@diagno opt]# rpm -qi httpdName : httpdVersion : 2.4.6Release : 99.el7.centos.1Architecture: x86_64Install Date: 2024年03月18日 星期一 10时30分33秒Group : System Environment/DaemonsSize : 9829328License : ASL 2.0Signature : RSA/SHA256, 2023年05月30日 星期二 23时15分45秒, Key ID 24c6a8a7f4a80eb5Source RPM : httpd-2.4.6-99.el7.centos.1.src.rpmBuild Date : 2023年05月30日 星期二 22时02分56秒Build Host : x86-01.bsys.centos.orgRelocations : (not relocatable)Packager : CentOS BuildSystem &lt;http://bugs.centos.org&gt;Vendor : CentOSURL : http://httpd.apache.org/Summary : Apache HTTP ServerDescription :The Apache HTTP Server is a powerful, efficient, and extensibleweb server. RPM数据库信息RPM数据库信息通常存储在一个或多个文件中，这些文件构成了RPM的存储系统。这些文件包括包信息文件（Package Database）、文件标签数据库（Tag Database）和文件属性数据库（File Attribute Database）。在Linux系统中，RPM数据库通常位于 /var/lib/rpm 目录下。其中： Basenames：包含所有已安装的文件基本名称。 Conflictname：包含可能与其他包发生冲突的文件列表。 Dirnames：包含所有已安装的目录名称。 Group：包含所有已安装的包的组信息。 Installtid：包含安装事务日志，记录了安装、升级和删除操作的详细信息。 Name：包含所有已安装的软件包的名称。 Obsoletename：包含已安装的软件包中已过时的文件列表。 Packages：包含所有已安装的软件包的头信息和文件索引。 Providename：包含已安装的软件包提供的功能列表。 Requirename：包含已安装的软件包所需的文件列表。 Shadow：包含已安装的软件包的阴影信息。 Sigmd5：包含所有已安装软件包的MD5签名。 Triggeruid：包含触发器的UID信息。要查看RPM数据库信息，你可以使用rpm命令行工具。 rpm -qa 查看所有已安装的软件包的列表rpm –rebuilddb 查看RPM数据库的完整性，将重建RPM数据库，并修复损坏的数据库文件"},{"title":"linux - grep命令","date":"2024-02-27T03:25:40.000Z","updated":"2024-03-07T05:18:25.242Z","comments":true,"path":"linux/linux-command-4.html","permalink":"https://sunjinkang.github.io/linux/linux-command-4.html","excerpt":"","text":"Linux - grep命令grep命令介绍grep 是用于在文本中搜索匹配特定模式的行的 Unix 和 Linux 命令。grep也可用于搜索文件夹内的文件内容。 搜索包含关键字的行：语法格式：grep &quot;关键字&quot; 文件名例如：grep &quot;root&quot; /etc/passwd 会找到包含 “root” 这个关键字的行。 搜索以某关键字开头的行：语法格式：grep &quot;^关键字&quot; 文件名例如：grep &quot;^root&quot; /etc/passwd 会找到以 “root” 开头的行。 搜索以某关键字开头的，不区分大小写的行：语法格式：grep -i &quot;^关键字&quot; 文件名例如：grep -i &quot;^root&quot; /etc/passwd 会找到以 “root”、”Root”、”rOot”等开头的行。 搜索某关键字结尾的行：语法格式：grep &quot;关键字$&quot; 文件名例如：grep &quot;root$&quot; /etc/passwd 会找到以 “root” 结尾的行。此外，grep 支持正则表达式和多个文件名的操作。 打印结果显示行号：语法格式：grep -n &quot;关键字&quot; 文件名例如：grep -n &quot;root&quot; /etc/passwd 会找到包含 “root” 的行，并显示具体行号。 在指定目录下多个文件内容中查找包含的关键字语法格式：grep -r &quot;关键字&quot; 目录例如：grep -r &quot;root&quot; /etc 查找etc目录下文件中包含 “root” 的行 查找包含关键字的文件名语法格式：ls | grep &quot;关键字&quot;例如：ls | grep &quot;root&quot; 查找当前目录下文件名中包含 “root” 的文件 man手册中关于 -r 与 -R 的解释： 1234567-r, --recursiveRead all files under each directory, recursively, following symbolic links only if they are on the command line. Note that if no file operand is given, grep searches the working directory. This is equivalent to the -d recurse option.# 译文：递归地读取每个目录下的所有文件，仅当符号链接位于命令行中时才按照符号链接读取。注意，如果没有给出文件操作数，grep将搜索工作目录。这相当于-d递归选项。-R, --dereference-recursiveRead all files under each directory, recursively. Follow all symbolic links, unlike -r.# 译文：递归地读取每个目录下的所有文件。遵循所有符号链接，不像-r。 linux系统中.bashrc文件作用？？ grep -r 和 grep -R 的区别？？？"},{"title":"linux","date":"2024-02-11T11:23:54.000Z","updated":"2024-02-21T07:40:44.506Z","comments":true,"path":"linux/index.html","permalink":"https://sunjinkang.github.io/linux/index.html","excerpt":"","text":"linux查看磁盘使用情况命令linux软件管理-yumlinux软件管理-rpm"},{"title":"linux - 关于man手册","date":"2024-02-28T03:09:30.000Z","updated":"2024-02-28T05:10:13.736Z","comments":true,"path":"linux/linux-command-5.html","permalink":"https://sunjinkang.github.io/linux/linux-command-5.html","excerpt":"","text":"以上内容可在man手册中查看具体内容man手册地址：https://man7.org man手册分为man1-man8： man1:用户命令； man2:系统调用； man3:C库调用； man4:设备文件及特殊文件； man5:文件格式：(配置文件格式)； man6:游戏使用帮助； man7:杂项； man8:管理工具及守护进行。 man只是包含了一些基础的东西，而man-pages包含了详细的帮助手册 安装man手册命令12345678910111213141516171819202122232425# 有时候可能需要在命令前面加上 sudo# -y 表示安装过程中出现的问询直接使用yes进行后续操作，对于 -y 的位置并没有特别说明，放在yum后面貌似都可以# 安装manyum -y install man# 或yum install -y man# 或yum install man -y# 安装man-pagesyum -y install man-pages# 安装 man 和 man-pagesyum -y install man man-pages# 卸载manyum -y remove man# 卸载man-pagesyum -y remove man-pages# 卸载 man 和 man-pagesyum -y remove man man-pages Docker容器中安装man后无法使用man问题？现象：在docker容器中安装了man之后，使用man查看命令时，直接报错，无法查看 No manual entry for man 原因： 我们使用的docker镜像已经被官方精简过了，把所有已安装软件的man页都删除了，这样镜像可以更小 docker镜像中的/etc/yum.conf 也被刻意处理了一下，里面有个tsflags的选项，配置了nodocs，这样的话，新安装的软件也会被自动剔掉man文件（估计rpm知道man文件是被故意删掉的，所以也不报错） 解决办法：将 /etc/yum.conf 中下面的代码注释掉： tsflags=nodocs卸载掉相关软件，重新yum安装，即可正常使用man手册查看命令"},{"title":"linux - uname命令","date":"2024-02-28T03:09:30.000Z","updated":"2024-02-29T05:08:39.541Z","comments":true,"path":"linux/linux-command-6.html","permalink":"https://sunjinkang.github.io/linux/linux-command-6.html","excerpt":"","text":"关于uname命令介绍及常用参数说明uname 常用于获取服务器信息，包括但不限于主机名称、处理信息、架构信息等 参数说明| 参数 | 作用 || -a | 显示全部系统信息 || -m 或 -p | 显示CPU信息 || -n | 显示主机名 || -r | 显示内核版本 || -s | 显示系统名称 || -o | 显示操作系统名称 || -v | 显示系统版本 || -i | 显示硬件平台 | 举例 123456789101112131415161718root@ubuntu:~# uname -aLinux ubuntu 4.15.0-36-generic #39-Ubuntu SMP Mon Sep 24 16:19:09 UTC 2018 x86_64 x86_64 x86_64 GNU/Linuxroot@ubuntu:~# uname -v#39-Ubuntu SMP Mon Sep 24 16:19:09 UTC 2018root@ubuntu:~# uname -sLinuxroot@ubuntu:~# uname -r4.15.0-36-genericroot@ubuntu:~# uname -nubunturoot@ubuntu:~# uname -px86_64root@ubuntu:~# uname -mx86_64root@ubuntu:~# uname -ix86_64root@ubuntu:~# uname -oGNU/Linux Linux系统信息查看命令 lsb_release -a 123456root@ubuntu:~# lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription: Ubuntu 18.04.1 LTSRelease: 18.04Codename: bionic"},{"title":"linux - yum配置本地源","date":"2024-03-21T10:39:10.000Z","updated":"2024-03-26T06:18:33.568Z","comments":true,"path":"linux/linux-command-7.html","permalink":"https://sunjinkang.github.io/linux/linux-command-7.html","excerpt":"","text":"yum仓库配置文件位于 /etc/yum.repos.d 查看yum仓库清单 yum repolist 12345678[root@xxx yum.repos.d]# yum repolistLoaded plugins: ovlrepo id repo name status!base/7/x86_64 CentOS-7 - Base - mirrors.aliyun.com 10,072!epel/x86_64 Extra Packages for Enterprise Linux 7 - x86_64 13,625!extras/7/x86_64 CentOS-7 - Extras - mirrors.aliyun.com 498!updates/7/x86_64 CentOS-7 - Updates - mirrors.aliyun.com 2,542repolist: 26,737 yum清空缓存&amp;重建缓存 yum cleanyum clean all //清空缓存目录下的软件包及旧的headersyum clean packagesyum clean headersyum clean oldheaders yum makecache yum搜索 yum provides 命令 //查看命令是由哪个包提供的yum search [string] // 根据关键字string查找安装包 查看包的依赖 yum deplist [安装包名] yum缓存目录下的 headers是什么东西？？解决需要多次下载问题 什么时候需要被删？硬件损坏包损坏 yum配置文件地址有多个时使用了baseurl，既然有多个，为什么不用mirrorlist ??baseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/ http://mirrors.aliyuncs.com/centos/$releasever/contrib/$basearch/ http://mirrors.cloud.aliyuncs.com/centos/$releasever/contrib/$basearch/ 随机选择一个地址下载，失败后换新的下载。确认某一个mirrorlist哪个最快，类似每一个都ping一下，但只能确定ping的时候哪一个最快。所以实际连接时候可能 3d for js 编译为rpk??andiriod Makefile语言学习，实现一个脚本选择之前先考量一下，类似makefile的语言，大家都在用什么，未来走向，对比一下，再确定。时间久，过时了，有没有什么新的"},{"title":"2.x迁移到3.x变更点","date":"2022-01-25T06:17:57.000Z","updated":"2023-07-24T09:24:46.207Z","comments":true,"path":"vue/change.html","permalink":"https://sunjinkang.github.io/vue/change.html","excerpt":"","text":"生命周期变更 选项式 API Hook inside setup beforeCreate Not needed* created Not needed* beforeMount onBeforeMount mounted onMounted beforeUpdate onBeforeUpdate updated onUpdated beforeUnmount onBeforeUnmount unmounted onUnmounted errorCaptured onErrorCaptured renderTracked onRenderTracked renderTriggered onRenderTriggered activated onActivated deactivated onDeactivated vue3允许组件有多个根节点移除过滤器过滤器已移除，且不再支持，建议用计算属性或方法代替过滤器，而不是使用过滤器 template应用挂载变更在 Vue 2.x 中，当挂载一个具有 template 的应用时，被渲染的内容会替换我们要挂载的目标元素。在 Vue 3.x 中，被渲染的应用会作为子元素插入，从而替换目标元素的 innerHTML 过渡的 class 名更改过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from 组件的相关 prop 名称变化leave-class 已经被重命名为 leave-from-class (在渲染函数或 JSX 中可以写为：leaveFromClass)enter-class 已经被重命名为 enter-from-class (在渲染函数或 JSX 中可以写为：enterFromClass) Transition Group 根元素 不再默认渲染根元素，但仍然可以用 tag attribute 创建根元素，希望保留原效果的，设置 tag=’span’ 即可 移除v-on.native修饰符v-on 的 .native 修饰符已被移除。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。 v-if 与 v-for 的优先级变更 vue2 vue3 在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用 v-if 总是优先于 v-for 生效 v-bind 合并行为 vue2 vue3 如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么这个独立 attribute 总是会覆盖 object 中的绑定（即不分先后） 如果一个元素同时定义了 v-bind=”object” 和一个相同的独立 attribute，那么绑定的声明顺序将决定它们如何被合并（即后覆盖前） VNode 生命周期事件 vue2 vue3 事件来监听组件生命周期,以 hook: 前缀开头，并跟随相应的生命周期钩子的名字 以 vnode- 前缀开头，事件也可用于 HTML 元素 举例：vnode- 前缀：@vnode-updated=”onUpdated”；或者在驼峰命名法的情况下附带前缀 vnode：@vnodeUpdated=”onUpdated”；生命周期钩子 beforeDestroy 和 destroyed 已经分别被重命名为 beforeUnmount 和 unmounted，所以相应的事件名也需要更新。 从vue2迁移官方文档(注意vue3改为默认安装版本后官方文档地址可能发生迁移，该跳转地址可能存在问题)"},{"title":"3.x生态环境","date":"2022-01-25T09:02:52.000Z","updated":"2023-07-24T09:24:46.208Z","comments":true,"path":"vue/dependency.html","permalink":"https://sunjinkang.github.io/vue/dependency.html","excerpt":"","text":"Vue 3 将在 2022 年 2 月 7 日成为新的默认版本！基于 Vite 的极速构建工具链 &lt;script setup&gt; 带来的开发体验更丝滑的组合式 API 语法 Volar 提供的单文件组件 TypeScript IDE 支持 vue-tsc 提供的针对单文件组件的命令行类型检查和生成 Pinia 提供的更简洁的状态管理 / Vuex4 新的开发者工具扩展，同时支持 Vue 2/Vue 3，并且提供一个插件系统来允许社区库自行扩展开发者工具面板 vuejs/core Vue Router 4.0代码地址 vuejs/docs vuejs/test-utils vuejs/babel-plugin-jsx Element Plus(稳定版本预计于2022/02/07发布) Ant Design Vue(从v2开始支持vue3，v3目前为beta版本) 其他Vue UI框架：Vuetify、Quasar 全新的文档(目前只能预览)（中文翻译中）"},{"title":"vue","date":"2022-01-07T09:11:56.000Z","updated":"2023-07-24T09:24:46.208Z","comments":true,"path":"vue/index.html","permalink":"https://sunjinkang.github.io/vue/index.html","excerpt":"","text":"VUE 2本部分用于记录vue2相关的文章地址暂无 VUE 3本部分用于记录vue3相关的文章地址2.x迁移到3.x变更点vue3.x生态环境"},{"title":"nodejs笔记","date":"2022-11-01T03:08:33.000Z","updated":"2023-07-24T09:24:46.496Z","comments":true,"path":"nodejs/index.html","permalink":"https://sunjinkang.github.io/nodejs/index.html","excerpt":"","text":"nvm安装不同版本node nodejs笔记1-基础知识 &amp; 深入浅出nodejs阅读笔记-1 nodejs笔记2-深入浅出nodejs阅读笔记-2 nodejs笔记3-深入浅出nodejs阅读笔记-3 nodejs笔记4-深入浅出nodejs阅读笔记-4 nodejs笔记5-深入浅出nodejs阅读笔记-5 nodejs笔记6-assert &amp; asyncHooks nodejs笔记7-buffer-1 nodejs笔记8-buffer-2 nodejs笔记9-C++ 插件 nodejs笔记10-child_process子进程 nodejs笔记11-cluster集群 nodejs笔记12-命令行选项 &amp; console (控制台) nodejs笔记13-crypto (加密) nodejs笔记14 nodejs笔记15 nodejs笔记16 nodejs笔记17 nodejs笔记18 nodejs笔记19 nodejs笔记20 nodejs笔记21 nodejs笔记22 nodejs笔记23 nodejs笔记24 nodejs笔记25 nodejs笔记26"},{"title":"nodejs基础知识 & 深入浅出nodejs阅读笔记(1)","date":"2022-10-19T11:12:12.000Z","updated":"2023-07-24T09:24:46.496Z","comments":true,"path":"nodejs/nodejs-note-1.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-1.html","excerpt":"","text":"nodejs是什么脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。 每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。 nodejs的安装官网地址：https://nodejs.org/en/ 直接从官网下载nodejs安装包，使用默认安装即可安装完成后打开dos，输入 node -v，如果出现对应的版本信息，代表成功，如果安装失败，查看环境变量等设置是否正常，或者Google一下 注意1、不同nodejs版本在使用上可能存在差异，需要根据自己实际情况，选择对应的版本安装（如果没有特别要求，一般使用标注的推荐版本进行安装即可）2、安装时如无特殊需要，直接选择下一步，使用默认设置即可，环境变量会默认进行设置3、新版的nodejs集成了npm，安装nodejs之后，可直接使用npm，打开dos，输入 npm -v，查看npm版本 根据不同的前端框架，使用不同的命令，安装对应的依赖、脚手架等，即可进行开发 nodejs官网地址：https://nodejs.org/zh-cn/docs/nodejs中文文档地址：https://www.nodeapp.cn/documentation.html node的特点(1)异步I/O在Node中，绝大多数的操作都以异步的方式进行调用(2)事件与回调函数(3)单线程在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。单线程弱点 无法利用多核CPU 错误会引起整个应用退出，应用的健壮性值得考验 大量计算占用CPU导致无法继续调用异步I/O node使用子进程的方式解决以上问题(4)跨平台Node基于libuv实现跨平台 Node 的应用场景(1)I/O密集型Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。(2)是否不擅长CPU密集型业务node优秀的运算能力主要来自V8的深度性能优化CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。 node充分利用CPU的方式： Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。由上面的测试结果可以看到，通过C/C++扩展的方式实现斐波那契数列计算，速度比Java还快。 如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。(3)与遗留系统和平共处(4)分布式应用 Node 的使用者 前后端编程语言环境统一 Node带来的高性能I/O用于实时应用 并行I/O使得使用者可以更高效地利用分布式环境 并行I/O，有效利用稳定接口提升Web渲染能力 云计算平台提供Node支持 游戏开发领域 工具类应用 模块机制CommonJSCommonJS规范为JavaScript制定了一个美好的愿景——希望JavaScript能够在任何地方运行。 过去javascript缺陷： 没有模块系统。 标准库较少。ECMAScript仅定义了部分核心库，对于文件系统，I/O流等常见需求却没有标准的API。就HTML5的发展状况而言，W3C标准化在一定意义上是在推进这个过程，但是它仅限于浏览器端。 没有标准接口。在JavaScript中，几乎没有定义过如Web服务器或者数据库之类的标准统一接口。 缺乏包管理系统。这导致JavaScript应用中基本没有自动加载和安装依赖的能力。 CommonJS的模块规范分为模块引用、模块定义和模块标识 模块引用在CommonJS规范中，存在require()方法，这个方法接受模块标识，以此引入一个模块的API到当前上下文中 模块定义在模块中，上下文提供require()方法来引入外部模块。对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式 模块标识模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。 Node 的模块实现在Node中引入模块，需要经历如下3个步骤。(1) 路径分析(2) 文件定位(3) 编译执行 在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢 Node缓存编译和执行之后的对象不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查 路径分析和文件定位 模块标识符分析 核心模块，如http、fs、path等。 核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码，其加载过程最快。 如果试图加载一个与核心模块标识符相同的自定义模块，那是不会成功的。如果自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或者换用路径的方式。 .或..开始的相对路径文件模块。 由于文件模块给Node指明了确切的文件位置，所以在查找过程中可以节约大量时间，其加载速度慢于核心模块 以/开始的绝对路径文件模块。 非路径形式的文件模块，如自定义的connect模块。 自定义模块指的是非核心模块，也不是路径形式的标识符。它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。 模块路径模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组模块路径的生成规则： 当前文件目录下的node_modules目录。 父目录下的node_modules目录。 父目录的父目录下的node_modules目录。 沿路径向上逐级递归，直到根目录下的node_modules目录。它的生成方式与JavaScript的原型链或作用域链的查找方式十分类似。在加载的过程中，Node会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。 文件定位 文件扩展名分析require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补足扩展名，依次尝试。小诀窍是：如果是.node和.json文件，在传递给require()的标识符中带上扩展名另一个诀窍是：同步配合缓存，可以大幅度缓解Node单线程中阻塞式调用的缺陷。 目录分析和包在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。在这个过程中，Node对CommonJS包规范进行了一定程度的支持。首先，Node在当前目录下查找package.json（CommonJS包规范定义的包描述文件），通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.json、index.node。如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。 模块编译编译和执行是引入文件模块的最后一个阶段。定位到具体的文件后，Node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法也有所不同： .js文件。通过fs模块同步读取文件后编译执行 .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件 .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果 其余扩展名文件。它们都被当做.js文件载入 每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能 JavaScript模块的编译在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。在头部添加了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值如果要达到require引入一个类的效果，请赋值给module.exports对象。 C/C++模块的编译.node的模块文件并不需要编译，因为它是编写C/C++模块之后编译生成的，所以这里只有加载和执行的过程 JSON文件的编译.json文件的编译是3种编译方式中最简单的。Node利用fs模块同步读取JSON文件的内容之后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用 核心模块(1)JavaScript核心模块的编译过程 转存为C/C++代码 编译JavaScript核心模块与文件模块有区别的地方在于：获取源代码的方式（核心模块是从内存中加载的）以及缓存执行结果的位置JavaScript核心模块，编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上(2)C/C++核心模块的编译过程将那些由纯C/C++编写的部分统一称为内建模块，因为它们通常不被用户直接调用。Node的buffer、crypto、evals、fs、os等模块都是部分通过C/C++编写的 内建模块的组织形式每一个内建模块在定义之后，都通过NODE_MODULE宏将模块定义到node命名空间中，模块的具体初始化方法挂载为结构的register_func成员node_extensions.h文件将这些散列的内建模块统一放进了一个叫node_module_list的数组中，这些模块有： node_buffer node_crypto node_evals node_fs node_http_parser node_os node_zlib node_timer_wrap node_tcp_wrap node_udp_wrap node_pipe_wrap node_cares_wrap node_tty_wrap node_process_wrap node_fs_event_wrap node_signal_watcher内建模块的优势在于： 首先，它们本身由C/C++编写，性能上优于脚本语言； 其次，在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再次做标识符定位、文件定位、编译等过程，直接就可执行。 内建模块的导出在Node的所有模块类型中，存在着一种依赖层级关系，即文件模块可能会依赖核心模块(javascript)，核心模块可能会依赖内建模块(C/C++)通常，不推荐文件模块直接调用内建模块。如需调用，直接调用核心模块即可，因为核心模块中基本都封装了内建模块在加载内建模块时，我们先创建一个exports空对象，然后调用get_builtin_module()方法取出内建模块对象，通过执行register_func()填充exports对象，最后将exports对象按模块名缓存，并返回给调用方完成导出(3)核心模块的引入流程 C/C++扩展模块(1)前提条件 GYP项目生成工具 V8引擎C++库 libuv库 Node内部库 其他库以.node为扩展名的文件，Node将会调用process.dlopen()方法去加载文件：//Native extension for .nodeModule._extensions[‘.node’] = process.dlopen; require()在引入.node文件的过程中，实际上经历了4个层面上的调用： 模块调用栈 C/C++内建模块 属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和第三方JavaScript文件模块调用。如果不是非常了解要调用的C/C++内建模块，请尽量避免通过process.binding()方法直接调用，这是不推荐的 JavaScript核心模块 主要扮演的职责有两类：一类是作为C/C++内建模块的封装层和桥接层，供文件模块调用；一类是纯粹的功能模块，它不需要跟底层打交道，但是又十分重要 文件模块 通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块 包与NPM 包结构包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。完全符合CommonJS规范的包目录应该包含如下这些文件。 package.json：包描述文件。 bin：用于存放可执行二进制文件的目录。 lib：用于存放JavaScript代码的目录。 doc：用于存放文档的目录。 test：用于存放单元测试用例的代码。 包描述文件与NPM包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于包的根目录下，是包的重要组成部分CommonJS为package.json文件定义了如下一些必需的字段。 name。包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。 description。包简介。 version。版本号。一个语义化的版本号，这在http://semver.org/上有详细定义，通常为major.minor.revision格式。该版本号十分重要，常常用于一些版本控制的场合。 keywords。关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。 maintainers。包维护者列表。每个维护者由name、email和web这3个属性组成。示例如下：”maintainers”: [{ “name”: “Jackson Tian”, “email”: “&#115;&#104;&#x79;&#x76;&#x6f;&#x31;&#x39;&#x38;&#x37;&#64;&#x67;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;“, “web”: “http://html5ify.com&quot; }], NPM通过该属性进行权限认证 contributors。贡献者列表。在开源社区中，为开源项目提供代码是经常出现的事情，如果名字能出现在知名项目的contributors列表中，是一件比较有荣誉感的事。列表中的第一个贡献应当是包的作者本人。它的格式与维护者列表相同。 bugs。一个可以反馈bug的网页地址或邮件地址。 licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。它的格式如下：”licenses”: [{ “type”: “GPLv2”, “url”: “http://www.example.com/licenses/gpl.html&quot;, }] repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。 dependencies。使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性帮助自动加载依赖的包。 除了必选字段外，规范还定义了一部分可选字段，具体如下所示。 homepage。当前包的网站地址。 os。操作系统支持列表。这些操作系统的取值包括aix、freebsd、linux、macos、solaris、vxworks、windows。如果设置了列表为空，则不对操作系统做任何假设。 cpu。CPU架构的支持列表，有效的架构名称有arm、mips、ppc、sparc、x86和x86_64。同os一样，如果列表为空，则不对CPU架构做任何假设。 engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。 builtin。标志当前包是否是内建在底层系统的标准组件。 directories。包目录说明。 implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。 scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。示例如下：“scripts”: { “install”: “install.js”,“uninstall”: “uninstall.js”,“build”: “build.js”,“doc”: “make-doc.js”,“test”: “test.js” } 包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、repositories、author、bin、main、scripts、engines、dependencies、devDependencies与包规范的区别在于多了author、bin、main和devDependencies这4个字段，下面补充说明一下。 author。包作者。 bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前面的node-gyp即是这样安装的。通过-g命令安装的模块包称为全局模式。 main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。 devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包 发布包 编写模块 初始化包描述文件 npm init 注册包仓库账号 npm adduser 上传包 npm publish . 安装包 npm install XXXX 管理包权限 npm owner ls npm owner add npm owner rm 包的标准： 具备良好的测试。 具备良好的文档（README、API）。 具备良好的测试覆盖率。 具备良好的编码规范。 更多条件 AMD规范AMD规范是CommonJS模块规范的一个延伸，它的模块定义如下：define(id?, dependencies?, factory);它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容AMD模块需要用define来明确定义一个模块，而在Node实现中是隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。 CMD规范与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：define([‘dep1’, ‘dep2’], function (dep1, dep2) { return function () {};});与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义：define(factory);在依赖部分，CMD支持动态引入，示例如下：define(function(require, exports, module) { // The module code goes here});require、exports和module通过形参传递给模块，在需要依赖模块时，随时调用require()引入即可。"},{"title":"使用nvm安装多版本node","date":"2022-12-16T05:21:49.000Z","updated":"2023-07-24T09:24:46.496Z","comments":true,"path":"nodejs/install-diff-version-node-by-nvm.html","permalink":"https://sunjinkang.github.io/nodejs/install-diff-version-node-by-nvm.html","excerpt":"","text":"前言大家在日常开发中，偶尔会遇到因为node不兼容导致的问题，这时候怎么办？相信大家常用的解决手段是卸载当前用的node，去官网重新下一个新的可兼容的版本重新安装。确实，这种方法可以解决遇到的问题，但是如果兼容版本是低版本怎么办？切换一个项目，兼容版本又不兼容了怎么办？或许会有人说再卸载再换。。。。。。但是不觉得这样太繁琐了吗？下面为大家介绍一种使用版本管理工具，安装不同版本的方式，实现不用手动卸载，紧靠命令即可下载、安装、切换、卸载不同版本的node。 nvm–node版本管理工具注意：安装nvm之前一定要先将原本安装的node卸载，删除node相关文件1、下载nvmnvm下载地址github上有不同的安装包，大家可以根据自己的需要进行下载安装 2、安装nvm注意：安装目录不能出现中文、空格等，否则可能导致安装失败或者安装后找不到nvm等问题 安装成功之后，使用cmd打开命令提示符，输入nvm，出现下图中的信息，表示安装成功 3、修改配置找到nvm的安装目录，找到setting.txt文件，打开文件后，将下面的地址增加到文件中 12node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ 4、使用nvm 安装指定版本node12nvm install [--version]// eg: nvm install 18.12 使用/切换指定版本node12nvm use [--version]// eg: nvm use 18.12 卸载指定版本node12nvm uninstall [--version]// eg: nvm uninstall 18.12 查看已下载及当前使用node版本1nvm ls 错误处理1、安装nvm之后，查看node版本，提示拒绝访问解决办法：卸载nvm，查看时候有nodejs文件残留，将残留文件删除 2、使用nvm use切换不同版本的node失败解决办法：使用管理员权限运行命令提示符 3、安装nvm成功，可以正常切换不同版本node，但是在vscode的终端里查看node版本，提示node不是内部或外部命令。。。。解决办法：em…本人遇到这个问题是因为安装nvm之前卸载node之后，把git也卸载了，不过安装git之后，重新安装nvm还是有这个问题，一段时间后重新安装nvm，安装成功了。。。。。。本人猜测是因为卸载了git导致的问题，注意：安装nvm之前，卸载node就行了，不要卸载git"},{"title":"nodejs基础知识(3)","date":"2022-12-29T03:32:45.000Z","updated":"2023-07-24T09:24:46.497Z","comments":true,"path":"nodejs/nodejs-note-10.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-10.html","excerpt":"","text":"child_process 模块提供了衍生子进程的功能，它与 popen(3) 类似，但不完全相同。 这个功能主要由 [child_process.spawn()] 函数提供 1234567891011121314const &#123; spawn &#125; = require(&#x27;child_process&#x27;);const ls = spawn(&#x27;ls&#x27;, [&#x27;-lh&#x27;, &#x27;/usr&#x27;]);ls.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(`输出：$&#123;data&#125;`);&#125;);ls.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(`错误：$&#123;data&#125;`);&#125;);ls.on(&#x27;close&#x27;, (code) =&gt; &#123; console.log(`子进程退出码：$&#123;code&#125;`);&#125;); 默认情况下，Node.js 的父进程与衍生的子进程之间会建立 stdin、stdout 和 stderr 的管道。 数据能以非阻塞的方式在管道中流通。 有些程序会在内部使用行缓冲 I/O，虽然这并不影响 Node.js，但发送到子进程的数据可能无法被立即使用。 [child_process.spawn()] 函数会异步地衍生子进程，且不会阻塞 Node.js 事件循环。 [child_process.spawnSync()] 函数则以同步的方式提供同样的功能，但会阻塞事件循环，直到衍生的子进程退出或被终止。 [child_process.exec()]: 衍生一个 shell 并在 shell 上运行命令，当完成时会传入 stdout 和 stderr 到回调函数。 [child_process.execFile()]: 类似 [child_process.exec()]，但直接衍生命令，且无需先衍生 shell。 [child_process.fork()]: 衍生一个新的 Node.js 进程，并通过建立 IPC 通讯通道来调用指定的模块，该通道允许父进程与子进程之间相互发送信息。 [child_process.execSync()]: [child_process.exec()] 的同步函数，会阻塞 Node.js 事件循环。 [child_process.execFileSync()]: [child_process.execFile()] 的同步函数，会阻塞 Node.js 事件循环。 注：后续函数都是基于 [child_process.spawn()] 或 [child_process.spawnSync()] 实现的。 创建异步进程[child_process.spawn()]、[child_process.fork()]、[child_process.exec()] 和 [child_process.execFile()] 函数都遵循 Node.js API 惯用的异步编程模式。 每个函数都返回 [ChildProcess] 实例。 这些实例实现了 Node.js [EventEmitter] API，允许父进程注册监听器函数，在子进程生命周期期间，当特定的事件发生时会调用这些函数。 [child_process.exec()] 和 [child_process.execFile()] 函数可以额外指定一个可选的 callback 函数，当子进程结束时会被调用。 在 Windows 上衍生 .bat 和 .cmd 文件[child_process.exec()] 和 [child_process.execFile()] 之间的区别会因平台而不同。 在类 Unix 操作系统（Unix、 Linux、 macOS）上，[child_process.execFile()] 效率更高，因为它不需要衍生 shell。 但在 Windows 上，.bat 和 .cmd 文件在没有终端的情况下是不可执行的，因此不能使用 [child_process.execFile()] 启动。 可以使用设置了 shell 选项的 [child_process.spawn()]、或使用 [child_process.exec()]、或衍生 cmd.exe 并将 .bat 或 .cmd 文件作为参数传入（也就是 shell 选项和 [child_process.exec()] 所做的工作）。 如果脚本文件名包含空格，则需要加上引号。 1234567891011121314151617181920212223242526272829303132// 仅限 Windows 系统const &#123; spawn &#125; = require(&#x27;child_process&#x27;);const bat = spawn(&#x27;cmd.exe&#x27;, [&#x27;/c&#x27;, &#x27;my.bat&#x27;]);bat.stdout.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(data.toString());&#125;);bat.stderr.on(&#x27;data&#x27;, (data) =&gt; &#123; console.log(data.toString());&#125;);bat.on(&#x27;exit&#x27;, (code) =&gt; &#123; console.log(`子进程退出码：$&#123;code&#125;`);&#125;);// 或const &#123; exec &#125; = require(&#x27;child_process&#x27;);exec(&#x27;my.bat&#x27;, (err, stdout, stderr) =&gt; &#123; if (err) &#123; console.error(err); return; &#125; console.log(stdout);&#125;);// 文件名带有空格的脚本：const bat = spawn(&#x27;&quot;my script.cmd&quot;&#x27;, [&#x27;a&#x27;, &#x27;b&#x27;], &#123; shell: true &#125;);// 或：exec(&#x27;&quot;my script.cmd&quot; a b&#x27;, (err, stdout, stderr) =&gt; &#123; // ...&#125;); child_process.exec(command[, options][, callback]) command 运行的命令，参数使用空格分隔。 options cwd 子进程的当前工作目录。 env 环境变量键值对。 encoding 默认为 ‘utf8’。 shell 执行命令的 shell。在 UNIX 上默认为 ‘/bin/sh’，在 Windows 上默认为 process.env.ComSpec。详见Shell的要求与Windows默认的Shell。 timeout 默认为 0。 maxBuffer stdout 或 stderr 允许的最大字节数。默认为 200*1024。如果超过限制，则子进程会被终止。详见 maxBuffer与Unicode。 killSignal | 默认为 ‘SIGTERM’。 uid 设置进程的用户标识，详见 setuid(2)。 gid 设置进程的组标识，详见 setgid(2)。 windowsHide 隐藏子进程的控制台窗口，常用于 Windows 系统。默认为 false。 callback 进程终止时调用。 error stdout | stderr | 返回: 衍生一个 shell 并在 shell 中执行 command，且缓冲任何产生的输出。 传入函数的 command 字符串会被 shell 直接处理，特殊字符（因shell而异）需要相应处理： 12345exec(&#x27;&quot;/path/to/test file/test.sh&quot; arg1 arg2&#x27;);// 使用双引号使路径中的空格不会被理解为多个参数。exec(&#x27;echo &quot;The \\\\$HOME variable is $HOME&quot;&#x27;);// 第一个 $HOME 会被转义，而第二个不会。 注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。 123456789const &#123; exec &#125; = require(&#x27;child_process&#x27;);exec(&#x27;cat *.js bad_file | wc -l&#x27;, (error, stdout, stderr) =&gt; &#123; if (error) &#123; console.error(`exec error: $&#123;error&#125;`); return; &#125; console.log(`stdout: $&#123;stdout&#125;`); console.log(`stderr: $&#123;stderr&#125;`);&#125;); 如果提供了一个 callback 函数，则它被调用时会带上参数 (error, stdout, stderr)。 当成功时，error 会是 null。 当失败时，error 会是一个 [Error] 实例。 error.code 属性会是子进程的退出码，error.signal 会被设为终止进程的信号。 除 0 以外的任何退出码都被认为是一个错误。 传给回调的 stdout 和 stderr 参数会包含子进程的 stdout 和 stderr 的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。 encoding 选项可用于指定用于解码 stdout 和 stderr 输出的字符编码。 如果 encoding 是 ‘buffer’、或一个无法识别的字符编码，则传入 Buffer 对象到回调函数。 options 参数可以作为第二个参数传入，用于自定义如何衍生进程。 如果 timeout 大于 0，当子进程运行超过 timeout 毫秒时，父进程就会发送由 killSignal 属性标识的信号（默认为 ‘SIGTERM’）。 如果调用该方法的 [util.promisify()][] 版本，将会返回一个包含 stdout 和 stderr 的 Promise 对象。在出现错误的情况下，将返回 rejected 状态的 promise，拥有与回调函数一样的 error 对象，但附加了 stdout 和 stderr 属性。 123456789const util = require(&#x27;util&#x27;);const exec = util.promisify(require(&#x27;child_process&#x27;).exec);async function lsExample() &#123; const &#123; stdout, stderr &#125; = await exec(&#x27;ls&#x27;); console.log(&#x27;stdout:&#x27;, stdout); console.log(&#x27;stderr:&#x27;, stderr);&#125;lsExample(); child_process.execFile(file[, args][, options][, callback]) file 要运行的可执行文件的名称或路径。 args &lt;string[]&gt; 字符串参数列表。 options cwd 子进程的当前工作目录。 env 环境变量键值对。 encoding 默认为 ‘utf8’。 timeout 默认为 0。 maxBuffer stdout 或 stderr 允许的最大字节数。 默认为 200*1024。 如果超过限制，则子进程会被终止。 killSignal | 默认为 ‘SIGTERM’。 uid 设置该进程的用户标识。（详见 setuid(2)） gid 设置该进程的组标识。（详见 setgid(2)） windowsHide 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。 windowsVerbatimArguments 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认为: false。 callback 当进程终止时调用，并带上输出。 error stdout | stderr | 返回: child_process.execFile() 函数类似 [child_process.exec()]，除了不衍生一个 shell。 而是，指定的可执行的 file 被直接衍生为一个新进程，这使得它比 [child_process.exec()] 更高效。 它支持和 [child_process.exec()] 一样的选项。 由于没有衍生 shell，因此不支持像 I/O 重定向和文件查找这样的行为。 1234567const &#123; execFile &#125; = require(&#x27;child_process&#x27;);const child = execFile(&#x27;node&#x27;, [&#x27;--version&#x27;], (error, stdout, stderr) =&gt; &#123; if (error) &#123; throw error; &#125; console.log(stdout);&#125;); child_process.fork(modulePath[, args][, options]) modulePath 要在子进程中运行的模块。 args 字符串参数列表。 options cwd 子进程的当前工作目录。 env 环境变量键值对。 execPath 用来创建子进程的执行路径。 execArgv 要传给执行路径的字符串参数列表。默认为 process.execArgv。 silent 如果为 true，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见 [child_process.spawn()] 的 [stdio] 中的 ‘pipe’ 和 ‘inherit’ 选项。 默认: false。 stdio | 详见 [child_process.spawn()] 的 [stdio]。 当提供了该选项，则它会覆盖 silent。 如果使用了数组变量，则该数组必须包含一个值为 ‘ipc’ 的子项，否则会抛出错误。 例如 [0, 1, 2, ‘ipc’]。 windowsVerbatimArguments 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略。默认值: false。 uid 设置该进程的用户标识。（详见 setuid(2)） gid 设置该进程的组标识。（详见 setgid(2)）返回: child_process.fork() 方法是 [child_process.spawn()] 的一个特殊情况，专门用于衍生新的 Node.js 进程。 跟 [child_process.spawn()] 一样返回一个 [ChildProcess] 对象。 返回的 [ChildProcess] 会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。 详见 [subprocess.send()]。 衍生的 Node.js 子进程与两者之间建立的 IPC 通信信道的异常是独立于父进程的。 每个进程都有自己的内存，使用自己的 V8 实例。 由于需要额外的资源分配，因此不推荐衍生大量的 Node.js 进程。 默认情况下，child_process.fork() 会使用父进程中的 [process.execPath] 衍生新的 Node.js 实例。 options 对象中的 execPath 属性可以替换要使用的执行路径。 使用自定义的 execPath 启动的 Node.js 进程，会使用子进程的环境变量 NODE_CHANNEL_FD 中指定的文件描述符（fd）与父进程通信。 注意，不像 POSIX 系统回调中的 fork(2)，child_process.fork() 不会克隆当前进程。 提示: 在使用child_process.fork() 产生的子进程内，使用 [child_process.spawn()][] 会自动忽略掉其中的shell 配置选项并不会生效。 child_process.spawn(command[, args][, options]) command 要运行的命令。 args 字符串参数列表。 options cwd 子进程的当前工作目录。 env 环境变量键值对。 argv0 显式地设置要发给子进程的 argv[0] 的值。 如果未指定，则设为 command。 stdio | 子进程的 stdio 配置。 detached 准备将子进程独立于父进程运行。 具体行为取决于平台。 uid 设置该进程的用户标识。 gid 设置该进程的组标识。 shell | 如果为 true，则在一个 shell 中运行 command。 在 UNIX 上使用 ‘/bin/sh’，在 Windows 上使用 process.env.ComSpec。 一个不同的 shell 可以被指定为字符串。 默认为 false（没有 shell）。 windowsVerbatimArguments 决定在Windows系统下是否使用转义参数。 在Linux平台下会自动忽略，当指令 shell 存在的时该属性将自动被设置为true。默认值: false。 windowsHide 是否隐藏在Windows系统下默认会弹出的子进程控制台窗口。 默认为: false。返回: child_process.execFileSync(file[, args][, options])child_process.execFileSync() 方法与 [child_process.execFile()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。 如果进程超时，或有一个非零的退出码，则该方法会抛出一个 [Error]，这个错误对象包含了底层 [child_process.spawnSync()] 的完整结果。 child_process.execSync(command[, options])child_process.execSync() 方法与 [child_process.exec()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。 如果进程超时，或有一个非零的退出码，则该方法会抛出错误。 [Error] 对象会包含从 [child_process.spawnSync()] 返回的整个结果。 注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。 child_process.spawnSync(command[, args][, options])child_process.spawnSync() 方法与 [child_process.spawn()] 基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 killSignal 时，则该方法直到进程完全退出后才返回结果。 注意，如果子进程拦截并处理了 SIGTERM 信号且没有退出，则父进程会一直等待直到子进程退出。 注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。 ChildProcess 类ChildProcess 类的实例是 [EventEmitter]，代表衍生的子进程。 ChildProcess 的实例不被直接创建。 而是，使用 [child_process.spawn()]、[child_process.exec()]、[child_process.execFile()] 或 [child_process.fork()] 方法创建 ChildProcess 实例。 ‘close’ 事件code 如果子进程退出自身，则该值是退出码。signal 子进程被终止时的信号。当子进程的 stdio 流被关闭时会触发 ‘close’ 事件。 这与 [‘exit’] 事件不同，因为多个进程可能共享同一 stdio 流。 ‘disconnect’ 事件在父进程中调用 [subprocess.disconnect()] 或在子进程中调用 [process.disconnect()] 后会触发 ‘disconnect’ 事件。 断开后就不能再发送或接收信息，且 [subprocess.connected] 属性会被设为 false。 ‘error’ 事件err 错误对象。每当出现以下情况时触发 ‘error’ 事件： 进程无法被衍生； 进程无法被杀死； 向子进程发送信息失败。注意，在错误发生后，’exit’ 事件可能会也可能不会触发。 当同时监听了 ‘exit’ 和 ‘error’ 事件，谨防处理函数被多次调用。详见 [subprocess.kill()] 和 [subprocess.send()]。 ‘exit’ 事件code 如果子进程退出自身，则该值是退出码。signal 子进程被终止时的信号。子进程结束后会触发 ‘exit’ 事件。 如果进程退出了，则 code 是进程的最终退出码，否则为 null。如果进程是收到的信号而终止的，则 signal 是信号的字符串名称，否则为 null。这两个总有一个是非空的。 注意，当 ‘exit’ 事件被触发时，子进程的 stdio 流可能依然是打开的。 另外，还要注意，Node.js 建立了 SIGINT 和 SIGTERM 的信号处理程序，且 Node.js 进程收到这些信号也不会立即终止。 相反，Node.js 会执行一系列的清理操作后重新引发处理信号。 ‘message’ 事件message 一个已解析的 JSON 对象或原始值。sendHandle 一个 [net.Socket] 或 [net.Server] 对象 或 undefined。当一个子进程使用 [process.send()] 发送消息时会触发 ‘message’ 事件。 注意: 消息通过序列化和解析传递，结果就是消息可能跟开始发送的不完全一样。 subprocess.channel 代表子进程的IPC通道的管道。subprocess.channel 属性是当前子进程的 IPC 通道的引用。如果当前没有 IPC 通道，则该属性为 undefined。 subprocess.connected 调用 subprocess.disconnect() 后会被设为 falsesubprocess.connected 属性表明是否仍可以从一个子进程发送和接收消息。 当 subprocess.connected 为 false 时，则不能再发送或接收的消息。 subprocess.disconnect()关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。 调用该方法后，父进程和子进程上各自的 subprocess.connected 和 process.connected 属性都会被设为 false，且进程之间不能再传递消息。 当正在接收的进程中没有消息时，就会触发 ‘disconnect’ 事件。 这经常在调用 subprocess.disconnect() 后立即被触发。 注意，当子进程是一个 Node.js 实例时（例如通过 [child_process.fork()] 衍生的），可以在子进程内调用 process.disconnect() 方法来关闭 IPC 通道。 subprocess.kill([signal])signal subprocess.kill() 方法向子进程发送一个信号。 如果没有给定参数，则进程会发送 ‘SIGTERM’ 信号。 123456789const &#123; spawn &#125; = require(&#x27;child_process&#x27;);const grep = spawn(&#x27;grep&#x27;, [&#x27;ssh&#x27;]);grep.on(&#x27;close&#x27;, (code, signal) =&gt; &#123; console.log(`子进程收到信号 $&#123;signal&#125; 而终止`);&#125;);// 发送 SIGHUP 到进程grep.kill(&#x27;SIGHUP&#x27;); 如果信号没有被送达，[ChildProcess] 对象可能会触发一个 [‘error’] 事件。 向一个已经退出的子进程发送信号不是一个错误，但可能有无法预知的后果。 特别是，如果进程的 PID 已经重新分配给其他进程，则信号会被发送到该进程，从而可能有意想不到的结果。 注意，当函数被调用 kill 时，已发送到子进程的信号可能没有实际终止该进程。 subprocess.killed 当 subprocess.kill() 已成功发送信号给子进程后会被设置为 true。subprocess.killed 属性表明该子进程是否已成功接收到 subprocess.kill() 的信号。 该属性不代表子进程是否已被终止。 subprocess.pid 整数返回子进程的进程标识（PID）。 subprocess.send(message[, sendHandle[, options]][, callback])当父进程和子进程之间建立了一个 IPC 通道时（例如，使用 [child_process.fork()]），subprocess.send() 方法可用于发送消息到子进程。 当子进程是一个 Node.js 实例时，消息可以通过 [process.on(‘message’)] 事件接收。 注意: 消息通过序列化和解析进行传递，结果就是消息可能跟开始发送的不完全一样。 subprocess.stderr&lt;stream.Readable&gt;一个代表子进程的 stderr 的可读流。如果子进程被衍生时 stdio[2] 被设为任何不是 ‘pipe’ 的值，则这会是 null。subprocess.stderr 是 subprocess.stdio[2] 的一个别名。 这两个属性指向相同的值。 subprocess.stdin&lt;stream.Writable&gt;一个代表子进程的 stdin 的可写流。注意，如果一个子进程正在等待读取所有的输入，则子进程不会继续直到流已通过 end() 关闭。如果子进程被衍生时 stdio[0] 被设为任何不是 ‘pipe’ 的值，则这会是 null。subprocess.stdin 是 subprocess.stdio[0] 的一个别名。 这两个属性指向相同的值。 subprocess.stdio一个到子进程的管道的稀疏数组，对应着传给 [child_process.spawn()] 的选项中值被设为 ‘pipe’ 的 [stdio]。 注意，subprocess.stdio[0]、subprocess.stdio[1] 和 subprocess.stdio[2] 分别可用作 subprocess.stdin、 subprocess.stdout 和 subprocess.stderr。 subprocess.stdout&lt;stream.Readable&gt;一个代表子进程的 stdout 的可读流。如果子进程被衍生时 stdio[1] 被设为任何不是 ‘pipe’ 的值，则这会是 null。subprocess.stdout 是 subprocess.stdio[1] 的一个别名。 这两个属性指向相同的值。 maxBuffer 与 UnicodemaxBuffer 选项指定了 stdout 或 stderr 上允许的字节数的最大值。 如果超过这个值，则子进程会被终止。 这会影响包含多字节字符编码的输出，如 UTF-8 或 UTF-16。 例如，console.log(‘中文测试’) 会发送 13 个 UTF-8 编码的字节到 stdout，尽管只有 4 个字符。"},{"title":"nodejs基础知识(5)","date":"2023-01-03T10:04:15.000Z","updated":"2023-07-24T09:24:46.497Z","comments":true,"path":"nodejs/nodejs-note-12.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-12.html","excerpt":"","text":"node [options] [V8 options] [script.js | -e “script” | -] [–] [arguments] node debug [script.js | -e “script” | :] … node –v8-options 执行时不带参数，会启动 [REPL]。 选项-v, –version打印 node 的版本号。 -h, –help打印 node 的命令行选项。 -e, –eval “script”把跟随的参数作为 JavaScript 来执行。 在 REPL 中预定义的模块也可以在 script 中使用。在windows的cmd中，使用单引号无法将参数作为javascript执行，仅双引号可正常执行，powershell和git bash中可以使用单引号和双引号 -p, –print “script”与 -e 相同，但会打印结果。 -c, –check在不执行的情况下，对脚本进行语法检查。 -i, –interactive打开 REPL，即使 stdin 看起来不像终端。 -r, –require module在启动时预加载指定的模块。遵循 require() 的模块解析规则。 module 可以是一个文件的路径，或一个 node 模块名称。 –inspect[=[host:]port]在主机端口上激活检查器。默认为127.0.0.1:9229。V8检查器集成允许Chrome DevTools和IDE等工具调试和配置Node.js实例。 这些工具通过tcp端口附加到Node.js实例，并使用[Chrome Debugging Protocol][]调试协议进行通信 –inspect-brk[=[host:]port]在主机上激活检查器：端口并在用户脚本开始时中断，默认为127.0.0.1:9229。 –inspect-port=[host:]port设置激活检查器时要使用的主机：端口。通过发送SIGUSR1信号激活检查器时有用。默认主机为：127.0.0.1。 –no-deprecation静默废弃的警告。 –trace-deprecation打印废弃的堆栈跟踪。 –throw-deprecation抛出废弃的错误。 –pending-deprecation发出挂起的弃用警告Note: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the –pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective “early warning” mechanism that developers may leverage to detect deprecated API usage.（注意：挂起的弃用通常与运行时弃用相同，但值得注意的是，它们在默认情况下被关闭，除非设置了–Pending弃用命令行标志或NODE_Pending_deprecation=1环境变量，否则不会发出。待定弃用用于提供一种选择性的“预警”机制，开发人员可以利用该机制来检测弃用的API使用情况。） –no-warnings静默一切进程警告（包括废弃警告）。 –expose-http2Enable the experimental ‘http2’ module.（启用实验“http2”模块。） –abort-on-uncaught-exceptionAborting instead of exiting causes a core file to be generated for post-mortem analysis using a debugger (such as lldb, gdb, and mdb)(中止而不是退出会导致使用调试器(如lldb、gdb和mdb)生成一个用于事后分析的核心文件。) –trace-warnings打印进程警告的堆栈跟踪（包括废弃警告）。 –redirect-warnings=fileWrite process warnings to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead.(将进程警告写入给定文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。) –trace-sync-io每当事件循环的第一帧之后检测到同步 I/O 时，打印堆栈跟踪。 –force-async-hooks-checksEnables runtime checks for async_hooks. These can also be enabled dynamically by enabling one of the async_hooks hooks.(启用async_hooks的运行时检查。也可以通过启用async_hooks钩子之一来动态启用这些钩子。) –trace-events-enabledEnables the collection of trace event tracing information.(启用跟踪事件跟踪信息的收集。) –trace-event-categoriesA comma separated list of categories that should be traced when trace event tracing is enabled using –trace-events-enabled.(当使用——trace-events-enabled启用跟踪事件跟踪时，应该跟踪的类别列表，以逗号分隔。) –zero-fill-buffers自动用 0 填充所有新分配的 [Buffer] 和 [SlowBuffer] 实例。 –preserve-symlinks当解析和缓存模块时，命令模块加载器保持符号连接。默认情况下，当 Node.js 从一个被符号连接到另一块磁盘位置的路径加载一个模块时，Node.js 会解引用该连接，并使用模块的真实磁盘的实际路径，作为定位其他依赖模块的标识符和根路径。 大多数情况下，默认行为是可接受的。 但是，当使用符号连接的同行依赖，如下例子所描述的，如果 moduleA 试图引入 moduleB 作为一个同行依赖，默认行为就会抛出异常：–preserve-symlinks 命令行标志命令 Node.js 使用模块的符号路径而不是真实路径，是符号连接的同行依赖能被找到。注意，使用 –preserve-symlinks 会有其他方面的影响。 比如，如果符号连接的原生模块在依赖树里来自超过一个位置，它们会加载失败。 （Node.js 会将它们视为两个独立的模块，且会试图多次加载模块，造成抛出异常。） –track-heap-objects为堆快照追踪堆栈对象的分配。 –prof-process处理 V8 分析器的输出，通过使用 V8 选项 –prof 生成。 –v8-options打印 V8 命令行选项。注意，V8 选项允许单词使用破折号（-）或下划线（_）分隔。例如，–stack-trace-limit 等同于 –stack_trace_limit。 –tls-cipher-list=list指定备用的默认 TLS 加密列表。 （需要 Node.js 被构建为支持加密。（默认）） –enable-fips启动时启用符合 FIPS 标准的加密。 （需要 Node.js 使用 ./configure –openssl-fips 构建） –force-fips启动时强制使用符合 FIPS 标准的加密。 （无法通过脚本代码禁用。） （需要 Node.js 使用 ./configure –openssl-fips 构建） –openssl-config=file启动时加载 OpenSSL 配置文件。 在其他用途中，如果 Node.js 使用 ./configure –openssl-fips 构建，它可以用于启用符合 FIPS 标准的加密。 –use-openssl-ca, –use-bundled-caUse OpenSSL’s default CA store or use bundled Mozilla CA store as supplied by current Node.js version. The default store is selectable at build-time. Using OpenSSL store allows for external modifications of the store. For most Linux and BSD distributions, this store is maintained by the distribution maintainers and system administrators. OpenSSL CA store location is dependent on configuration of the OpenSSL library but this can be altered at runtime using environment variables. The bundled CA store, as supplied by Node.js, is a snapshot of Mozilla CA store that is fixed at release time. It is identical on all supported platforms. See SSL_CERT_DIR and SSL_CERT_FILE.(使用OpenSSL的默认CA存储或使用当前Node.js版本提供的捆绑Mozilla CA存储。默认存储在构建时是可选择的。使用OpenSSL存储允许对存储进行外部修改。对于大多数Linux和BSD发行版，这个存储区由发行版维护人员和系统管理员维护。OpenSSL CA存储位置依赖于OpenSSL库的配置，但这可以在运行时使用环境变量更改。由Node.js提供的捆绑CA存储是发布时固定的Mozilla CA存储的快照。它在所有支持的平台上都是相同的。请参阅SSL_CERT_DIR和SSL_CERT_FILE。) –icu-data-dir=file指定 ICU 数据的加载路径。 （覆盖 NODE_ICU_DATA） -Alias for stdin, analogous to the use of - in other command line utilities, meaning that the script will be read from stdin, and the rest of the options are passed to that script.(stdin的别名，类似于-在其他命令行实用程序中的使用，这意味着脚本将从stdin读取，其余选项将传递给该脚本。) –Indicate the end of node options. Pass the rest of the arguments to the script. If no script filename or eval/print script is supplied prior to this, then the next argument will be used as a script filename.(指示节点选项的结束。将其余参数传递给脚本。如果在此之前没有提供脚本文件名或eval/print脚本，则下一个参数将用作脚本文件名。) 环境变量NODE_DEBUG=module[,…]以 ‘,’ 分隔的应该打印调试信息的核心模块列表。 NODE_PATH=path[:…]以 ‘:’ 分隔的有模块搜索路径作前缀的目录列表。注意，在 Windows 中，列表是用 ‘;’ 分隔的。 NODE_DISABLE_COLORS=1当设为 1 时，不会在 REPL 中使用颜色。 NODE_ICU_DATA=fileICU（Intl 对象）数据的数据路径。 当使用 small-icu 编译时，扩展链接的数据。 NODE_NO_WARNINGS=1When set to 1, process warnings are silenced.(当设置为1时，进程警告将被静音。) NODE_NO_HTTP2=1When set to 1, the http2 module is suppressed.(当设置为1时，http2模块将被抑制。) NODE_OPTIONS=options…A space-separated list of command line options. options… are interpreted as if they had been specified on the command line before the actual command line (so they can be overridden). Node will exit with an error if an option that is not allowed in the environment is used, such as -p or a script file.(以空格分隔的命令行选项列表。选择……将它们解释为在实际命令行之前在命令行上指定的(因此可以覆盖它们)。如果使用了环境中不允许的选项，例如-p或脚本文件，则Node将退出并报错。)node选项如下： –enable-fips –force-fips –icu-data-dir –inspect-brk –inspect-port –inspect –no-deprecation –no-warnings –openssl-config –redirect-warnings –require, -r –throw-deprecation –tls-cipher-list –trace-deprecation –trace-events-categories –trace-events-enabled –trace-sync-io –trace-warnings –track-heap-objects –use-bundled-ca –use-openssl-ca –v8-pool-size –zero-fill-buffersV8选项如下: –abort-on-uncaught-exception –max-old-space-size –stack-trace-limit NODE_PENDING_DEPRECATION=1When set to 1, emit pending deprecation warnings. Note: Pending deprecations are generally identical to a runtime deprecation with the notable exception that they are turned off by default and will not be emitted unless either the –pending-deprecation command line flag, or the NODE_PENDING_DEPRECATION=1 environment variable, is set. Pending deprecations are used to provide a kind of selective “early warning” mechanism that developers may leverage to detect deprecated API usage.(当设置为1时，发出挂起的弃用警告。注意:挂起的弃用通常与运行时弃用相同，有一个显著的例外:它们在默认情况下是关闭的，除非设置了–pending -deprecation命令行标志或NODE_PENDING_DEPRECATION=1环境变量，否则不会被触发。未决弃用用于提供一种选择性的“早期预警”机制，开发人员可以利用这种机制来检测弃用API的使用情况。) NODE_PRESERVE_SYMLINKS=1When set to 1, instructs the module loader to preserve symbolic links when resolving and caching modules.(当设置为1时，指示模块加载器在解析和缓存模块时保留符号链接。) NODE_REPL_HISTORY=file用于存储持久性的 REPL 历史记录的文件的路径。 默认路径是 ~/.node_repl_history，可被该变量覆盖。 将值设为空字符串（”” 或 “ “）会禁用持久性的 REPL 历史记录。 NODE_EXTRA_CA_CERTS=file当设置了此选项时，根 CA 证书（如 VeriSign）会被 file 指定的证书扩展。 文件应该包括一个或多个可信的 PEM 格式的证书。 如果文件丢失或有缺陷，则 process.emitWarning() 会触发一个消息。注意，当一个 TLS 或 HTTPS 的客户端或服务器的 ca 选项的属性被显式地指定时，则指定的证书不会被使用。 OPENSSL_CONF=fileLoad an OpenSSL configuration file on startup. Among other uses, this can be used to enable FIPS-compliant crypto if Node.js is built with ./configure –openssl-fips.If the [–openssl-config][] command line option is used, the environment variable is ignored.(启动时加载OpenSSL配置文件。在其他用途中，如果Node.js使用./configure –openssl-fips构建，则可以使用它来启用符合fips的加密。如果使用[–openssl-config][]命令行选项，则忽略环境变量。) SSL_CERT_DIR=dirIf –use-openssl-ca is enabled, this overrides and sets OpenSSL’s directory containing trusted certificates.Note: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.(如果启用了–use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL目录。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。) SSL_CERT_FILE=fileIf –use-openssl-ca is enabled, this overrides and sets OpenSSL’s file containing trusted certificates.Note: Be aware that unless the child environment is explicitly set, this environment variable will be inherited by any child processes, and if they use OpenSSL, it may cause them to trust the same CAs as node.(如果启用了–use-openssl-ca，将覆盖并设置包含受信任证书的OpenSSL文件。注意:除非显式地设置了子环境，否则此环境变量将由任何子进程继承，并且如果它们使用OpenSSL，则可能导致它们信任与节点相同的CA。) NODE_REDIRECT_WARNINGS=fileWhen set, process warnings will be emitted to the given file instead of printing to stderr. The file will be created if it does not exist, and will be appended to if it does. If an error occurs while attempting to write the warning to the file, the warning will be written to stderr instead. This is equivalent to using the –redirect-warnings=file command-line flag.(设置后，进程警告将被发送到给定的文件，而不是打印到stderr。如果它不存在，则创建该文件;如果存在，则追加该文件。如果在尝试将警告写入文件时发生错误，则警告将被写入stderr。这相当于使用–redirect-warnings=file命令行标志。) UV_THREADPOOL_SIZE=sizeSet the number of threads used in libuv’s threadpool to size threads.Asynchronous system APIs are used by Node.js whenever possible, but where they do not exist, libuv’s threadpool is used to create asynchronous node APIs based on synchronous system APIs. Node.js APIs that use the threadpool are: all fs APIs, other than the file watcher APIs and those that are explicitly synchronous crypto.pbkdf2() crypto.randomBytes(), unless it is used without a callback crypto.randomFill() dns.lookup() all zlib APIs, other than those that are explicitly synchronousBecause libuv’s threadpool has a fixed size, it means that if for whatever reason any of these APIs takes a long time, other (seemingly unrelated) APIs that run in libuv’s threadpool will experience degraded performance. In order to mitigate this issue, one potential solution is to increase the size of libuv’s threadpool by setting the ‘UV_THREADPOOL_SIZE’ environment variable to a value greater than 4 (its current default value). For more information, see the [libuv threadpool documentation][]. [–openssl-config]: #cli_openssl_config_file [Buffer]: buffer.html#buffer_buffer [Chrome Debugging Protocol]: https://chromedevtools.github.io/debugger-protocol-viewer [REPL]: repl.html [SlowBuffer]: buffer.html#buffer_class_slowbuffer [debugger]: debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv threadpool documentation]: http://docs.libuv.org/en/latest/threadpool.html 将libuv线程池中使用的线程数设置为线程大小。node .js尽可能使用异步系统api，但在不存在异步系统api的地方，libuv的线程池用于基于同步系统api创建异步节点api。使用线程池的Node.js api有: 所有的fs api，除了文件监视器api和那些显式同步的api crypto.pbkdf2() crypt.randombytes()，除非它在没有回调的情况下使用 crypto.randomFill() dns.lookup() 所有的zlib api，除了那些显式同步的因为libuv的线程池大小是固定的，这意味着无论出于什么原因，如果这些api中的任何一个需要很长时间，在libuv的线程池中运行的其他(看似无关的)api将会经历性能下降。为了缓解这个问题，一个潜在的解决方案是通过将“UV_THREADPOOL_SIZE”环境变量设置为大于4(当前的默认值)来增加libuv线程池的大小。有关更多信息，请参阅[libuv线程池文档][]。[——openssl-config]: #cli_openssl_config_file [Buffer]: Buffer .html#buffer_buffer [Chrome调试协议]:https://chromedevtools.github.io/debugger-protocol-viewer [REPL]: REPL .html [SlowBuffer]: Buffer .html#buffer_class_slowbuffer[调试器]:debugger.html [emit_warning]: process.html#process_process_emitwarning_warning_type_code_ctor [libuv线程池文档]:http://docs.libuv.org/en/latest/threadpool.html console (控制台)console 模块提供了一个简单的调试控制台，类似于 Web 浏览器提供的 JavaScript 控制台。该模块导出了两个特定的组件： 一个 Console 类，包含 console.log() 、 console.error() 和 console.warn() 等方法，可以被用于写入到任何 Node.js 流。 一个全局的 console 实例，可被用于写入到 process.stdout 和 process.stderr。 全局的 console 使用时无需调用 require(‘console’)。注意：全局的 console 对象的方法既不总是同步的（如浏览器中类似的 API），也不总是异步的（如其他 Node.js 流）。 详见 进程 I/O。 123456789101112131415161718192021222324// 使用全局的 consoleconsole.log(&#x27;你好世界&#x27;);// 打印: &#x27;你好世界&#x27;到 stdout。console.log(&#x27;你好%s&#x27;, &#x27;世界&#x27;);// 打印: &#x27;你好世界&#x27;到 stdout。console.error(new Error(&#x27;错误信息&#x27;));// 打印: [Error: 错误信息]到 stderr。const name = &#x27;描述&#x27;;console.warn(`警告$&#123;name&#125;`);// 打印: &#x27;警告描述&#x27;到 stderr。// 使用 Console 类const out = getStreamSomehow();const err = getStreamSomehow();const myConsole = new console.Console(out, err);myConsole.log(&#x27;你好世界&#x27;);// 打印: &#x27;你好世界&#x27;到 out。myConsole.log(&#x27;你好%s&#x27;, &#x27;世界&#x27;);// 打印: &#x27;你好世界&#x27;到 out。myConsole.error(new Error(&#x27;错误信息&#x27;));// 打印: [Error: 错误信息]到 err。const name = &#x27;描述&#x27;;myConsole.warn(`警告$&#123;name&#125;`);// 打印: &#x27;警告描述&#x27;到 err。 Console 类Console 类可用于创建一个具有可配置的输出流的简单记录器，可以通过 require(‘console’).Console 或 console.Console 使用： 12const &#123; Console &#125; = require(&#x27;console&#x27;);const &#123; Console &#125; = console; 全局的 console 是一个特殊的 Console 实例，它的输出会发送到 process.stdout 和 process.stderr。 相当于调用： 1new Console(process.stdout, process.stderr); console.assert(value[, message][, …args])一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。 如果提供了 message，则使用 util.format() 格式化并作为错误信息使用。 1234console.assert(true, &#x27;does nothing&#x27;);// 通过console.assert(false, &#x27;Whoops %s&#x27;, &#x27;didn\\&#x27;t work&#x27;);// AssertionError: Whoops didn&#x27;t work 注意：Node.js 中的 console.assert() 方法与在浏览器中的 console.assert() 方法的实现是不一样的。具体地说，在浏览器中，用非真的断言调用 console.assert() 会导致 message 被打印到控制台但不会中断后续代码的执行。 在 Node.js v10.0.0 之前，一个值为假的断言也将会导致一个AssertionError被抛出，使得代码执行被打断。v10.0.0 修复了此差异，所以现在console.assert()在 Node 和浏览器中执行行为相同。可以通过扩展 Node.js 的 console 并重写 console.assert() 方法来实现与浏览器中类似的功能。console.assert 在不同浏览器中可能获得不同的效果 1234567891011121314151617181920212223&#x27;use strict&#x27;;// 用一个新的不带补丁的 assert 实现来创建一个简单的 console 扩展。const myConsole = Object.create(console, &#123; assert: &#123; value: function assert(assertion, message, ...args) &#123; try &#123; console.assert(assertion, message, ...args); &#125; catch (err) &#123; console.error(err.stack); &#125; &#125;, configurable: true, enumerable: true, writable: true, &#125;,&#125;);module.exports = myConsole;const console = require(&#x27;./myConsole&#x27;);console.assert(false, &#x27;会打印这个消息，但不会抛出错误&#x27;);console.log(&#x27;这个也会打印&#x27;); console.clear()当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。注意：console.clear() 的具体行为可能因操作系统和终端类型而异。 对于大多数Linux操作系统，console.clear() 与 clear shell 命令行为类似。 在Windows上，console.clear() 将只清除当前终端视图中Node.js二进制文件的输出。 console.count([label]) label 计数器的显示标签。 默认为 ‘default’。维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。12345678910111213141516171819&gt; console.count()default: 1undefined&gt; console.count(&#x27;default&#x27;)default: 2undefined&gt; console.count(&#x27;abc&#x27;)abc: 1undefined&gt; console.count(&#x27;xyz&#x27;)xyz: 1undefined&gt; console.count(&#x27;abc&#x27;)abc: 2undefined&gt; console.count()default: 3undefined&gt; console.countReset([label=’default’]) label 计数器的显示标签。 默认为 ‘default’。重置指定 label 的内部计数器。 console.debug(data[, …args])console.debug()函数是console.log()的别名。 console.dir(obj[, options])在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。(在控制台中显示指定对象的属性，并通过类似文件树样式的交互列表显示。)该函数会绕过任何定义在 obj 上的自定义的 inspect() 函数。可选的 options 对象可以传入用于改变被格式化的字符串： showHidden - 如果为 true，则该对象中的不可枚举属性和 symbol 属性也会显示。默认为 false。 depth - 告诉 util.inspect() 函数当格式化对象时要递归多少次。 这对于检查较大的复杂对象很有用。 默认为 2。 设为 null 可无限递归。 colors - 如果为 true，则输出会带有 ANSI 颜色代码。 默认为 false。 颜色是可定制的，详见定制 util.inspect() 颜色。 console.error([data][, …args])打印到 stderr，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。如果在第一个字符串中没有找到格式化元素（如 %d），则在每个参数上调用 util.inspect() 并将结果字符串值拼在一起。 详见 util.format()。 console.group([…label])#…label 将后续行的缩进增加两个空格。如果提供了一个或多个 labels，则首先打印这些 labels，而不需要额外的缩进。 console.groupCollapsed()console.group()的一个别名. console.groupEnd()将后续行的缩进减少两个空格。 console.info([data][, …args])console.info() 函数是 console.log() 的一个别名。 console.log([data][, …args])打印到 stdout，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 printf(3) 中的代替值（参数都会传给 util.format()）。 console.time(label)启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。 console.timeEnd(label)停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout： 1234console.time(&#x27;100-elements&#x27;);for (let i = 0; i &lt; 100; i++) &#123;&#125;console.timeEnd(&#x27;100-elements&#x27;);// 打印 100-elements: 225.438ms 该方法在使用时不会将输出的时间返回到 js，它只能用于控制台调试。请勿将该方法作为普通计时器或性能数据收集器的一部分。 console.trace([message][, …args])打印字符串 ‘Trace :’ 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。 console.warn([data][, …args])console.warn() 函数是 console.error() 的一个别名。"},{"title":"nodejs基础知识(4)","date":"2022-12-30T08:27:30.000Z","updated":"2023-07-24T09:24:46.497Z","comments":true,"path":"nodejs/nodejs-note-11.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-11.html","excerpt":"","text":"Node.js在单个线程中运行单个实例。 用户(开发者)为了使用现在的多核系统，有时候,用户(开发者)会用一串Node.js进程去处理负载任务。 cluster 模块允许简单容易的创建共享服务器端口的子进程。 12345678910111213141516171819202122232425const cluster = require(&#x27;cluster&#x27;);const http = require(&#x27;http&#x27;);const numCPUs = require(&#x27;os&#x27;).cpus().length;if (cluster.isMaster) &#123; console.log(`主进程 $&#123;process.pid&#125; 正在运行`); // 衍生工作进程。 for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123; console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`); &#125;);&#125; else &#123; // 工作进程可以共享任何 TCP 连接。 // 在本例子中，共享的是一个 HTTP 服务器。 http.createServer((req, res) =&gt; &#123; res.writeHead(200); res.end(&#x27;你好世界\\n&#x27;); &#125;).listen(8000); console.log(`工作进程 $&#123;process.pid&#125; 已启动`);&#125; cluster模块支持两种连接分发模式（将新连接安排给某一工作进程处理）。 第一种方法（也是除Windows外所有平台的默认方法），是循环法。由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程。在分发中使用了一些内置技巧防止工作进程任务过载。 第二种方法是，主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接。 理论上第二种方法应该是效率最佳的，但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。我们遇到过这种情况：8个进程中的2个，分担了70%的负载。 Class: WorkerWorker对象包含了关于工作进程的所有public信息和方法。在一个主进程里，可以使用cluster.workers来获取Worker对象。在一个工作进程里，可以使用cluster.worker来获取Worker对象。 Event: ‘disconnect’虽然与 cluster.on(‘disconnect’)事件 是相似的,但是这个进程又有其他特征。 123cluster.fork().on(&#x27;disconnect&#x27;, () =&gt; &#123; // Worker has disconnected&#125;); Event: ‘error’此事件和 child_process.fork()提供的error事件相同。在一个工作进程中，可以使用process.on(‘error’) Event: ‘exit’ code 若正常退出，表示退出代码. signal 引发进程被kill的信号名称（如’SIGHUP’）.和cluster.on(‘exit’)事件类似，但针对特定的工作进程。12345678910const worker = cluster.fork();worker.on(&#x27;exit&#x27;, (code, signal) =&gt; &#123; if (signal) &#123; console.log(`worker was killed by signal: $&#123;signal&#125;`); &#125; else if (code !== 0) &#123; console.log(`worker exited with error code: $&#123;code&#125;`); &#125; else &#123; console.log(&#x27;worker success!&#x27;); &#125;&#125;); Event: ‘listening’address 和cluster.on(‘listening’)事件类似，但针对特定的工作进程。本事件不会在工作进程内触发。 Event: ‘message’message handle | 和cluster.on(‘message’)事件类似，但针对特定的工作进程。在工作进程内，可以使用process.on(‘message’) 123456789101112131415161718192021222324252627282930313233343536373839const cluster = require(&#x27;cluster&#x27;);const http = require(&#x27;http&#x27;);if (cluster.isMaster) &#123; // 跟踪 http 请求 let numReqs = 0; setInterval(() =&gt; &#123; console.log(`numReqs = $&#123;numReqs&#125;`); &#125;, 1000); // 计算请求数目 function messageHandler(msg) &#123; if (msg.cmd &amp;&amp; msg.cmd === &#x27;notifyRequest&#x27;) &#123; numReqs += 1; &#125; &#125; // 启动 worker 并监听包含 notifyRequest 的消息 const numCPUs = require(&#x27;os&#x27;).cpus().length; for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; for (const id in cluster.workers) &#123; cluster.workers[id].on(&#x27;message&#x27;, messageHandler); &#125;&#125; else &#123; // Worker 进程有一个http服务器 http.Server((req, res) =&gt; &#123; res.writeHead(200); res.end(&#x27;hello world\\n&#x27;); // 通知 master 进程接收到了请求 process.send(&#123; cmd: &#x27;notifyRequest&#x27; &#125;); &#125;).listen(8000);&#125; Event: ‘online’和cluster.on(‘online’)事件类似，但针对特定的工作进程。本事件不会在工作进程内部被触发。 worker.disconnect()Returns: 一个 worker 的引用。在一个工作进程内，调用此方法会关闭所有的server，并等待这些server的 ‘close’事件执行，然后关闭IPC管道。 在主进程内，会给工作进程发送一个内部消息，导致工作进程自身调用.disconnect()。 会设置.exitedAfterDisconnect 。 需要注意的是，当一个server关闭后，它将不再接收新的连接，但新连接会被其他正在监听的工作进程接收。已建立的连接可以正常关闭。当所有连接都关闭后，通往该工作进程的IPC管道将会关闭，允许工作进程优雅地死掉 需要注意的是，我们这里的方法是disconnect，同时还有一个不一样的方法process.disconnect，大家不要混淆了 worker.exitedAfterDisconnect当调用 .kill() 或者 .disconnect()方法时被设置，在这之前都是 undefined。worker.exitedAfterDisconnect可以用于区分自发退出还是被动退出，主进程可以根据这个值决定是否重新衍生新的工作进程。与worker.suicide等价 worker.id每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在id里面。当工作进程还存活时，id可以作为在cluster.workers中的索引。 worker.isConnected()当工作进程通过IPC管道连接至主进程时，这个方法返回true，否则返回false。一个工作进程在创建后会自动连接到它的主进程，当’disconnect’ 事件被触发时才会断开连接。 worker.isDead()当工作进程被终止时（包括自动退出或被发送信号），这个方法返回true ，否则返回false。 worker.kill([signal=’SIGTERM’])signal 被发送kill信号的工作进程名称。这个方法将会kill工作进程。在主进程中，通过断开与worker.process的连接来实现，一旦断开连接后，通过signal来杀死工作进程。在工作进程中，通过断开IPC管道来实现，然后以代码0退出进程。将导致.exitedAfterDisconnect被设置。为向后兼容，这个方法与worker.destroy()等义。需要注意的是，在工作进程中有一个方法process.kill() ，这个方法本方法不同，本方法是kill。 worker.process所有的工作进程都是通过child_process.fork()来创建的，这个方法返回的对象被存储为.process。在工作进程中， process属于全局对象。需要注意：当process上发生 ‘disconnect’事件，并且.exitedAfterDisconnect的值不是true时，工作进程会调用 process.exit(0)。这样就可以防止连接意外断开。 worker.send(message[, sendHandle][, callback])发送一个消息给工作进程或主进程，也可以附带发送一个handle。主进程调用这个方法会发送消息给具体的工作进程。还有一个等价的方法是ChildProcess.send()。工作进程调用这个方法会发送消息给主进程。还有一个等价方法是process.send()。 Event: ‘disconnect’worker &lt;cluster.Worker&gt;在工作进程的IPC管道被断开后触发本事件。可能导致事件触发的原因包括：工作进程优雅地退出、被kill或手动断开连接（如调用worker.disconnect()）。‘disconnect’ 和 ‘exit’事件之间可能存在延迟。这些事件可以用来检测进程是否在清理过程中被卡住，或是否存在长时间运行的连接。 Event: ‘exit’worker &lt;cluster.Worker&gt;code 正常退出情况下，是退出代码.signal 导致进程被kill的信号名称 (例如 ‘SIGHUP’)当任何一个工作进程关闭的时候，cluster模块都将触发’exit’事件。可以被用来重启工作进程（通过调用.fork()） 12345cluster.on(&#x27;exit&#x27;, (worker, code, signal) =&gt; &#123; console.log(&#x27;worker %d died (%s). restarting...&#x27;, worker.process.pid, signal || code); cluster.fork();&#125;); Event: ‘fork’worker &lt;cluster.Worker&gt;当新的工作进程被fork时，cluster模块将触发’fork’事件。 可以被用来记录工作进程活动，产生一个自定义的timeout。 Event: ‘listening’worker &lt;cluster.Worker&gt;address 当一个工作进程调用listen()后，工作进程上的server会触发’listening’ 事件，同时主进程上的 cluster 也会被触发’listening’事件。事件处理器使用两个参数来执行，其中worker包含了工作进程对象，address 包含了以下连接属性： address、port 和 addressType。当工作进程同时监听多个地址时，这些参数非常有用。addressType 可选值包括: 4 (TCPv4) 6 (TCPv6) -1 (unix domain socket) “udp4” or “udp6” (UDP v4 or v6) Event: ‘message’worker &lt;cluster.Worker&gt;message handle | 当cluster主进程接收任意工作进程发送的消息后被触发。 Event: ‘online’worker &lt;cluster.Worker&gt;当新建一个工作进程后，工作进程应当响应一个online消息给主进程。当主进程收到online消息后触发这个事件。 ‘fork’ 事件和 ‘online’事件的不同之处在于，前者是在主进程新建工作进程后触发，而后者是在工作进程运行的时候触发。 Event: ‘setup’settings 每当 .setupMaster() 被调用的时候触发。settings 对象是 setupMaster() 被调用时的 cluster.settings 对象，并且只能查询，因为在一个 tick 内 .setupMaster() 可以被调用多次。如果精确度十分重要，请使用 cluster.settings。 cluster.disconnect([callback])callback 当所有工作进程都断开连接并且所有handle关闭的时候调用。在cluster.workers的每个工作进程中调用 .disconnect()。当所有工作进程断开连接后，所有内部handle将会关闭，这个时候如果没有等待事件的话，运行主进程优雅地关闭。这个方法可以选择添加一个回调参数，当结束时会调用这个回调函数。这个方法只能由主进程调用。 cluster.fork([env])env 增加进程环境变量，以Key/value对的形式。return &lt;cluster.Worker&gt;衍生出一个新的工作进程。只能通过主进程调用。 cluster.isMaster当该进程是主进程时，返回 true。这是由process.env.NODE_UNIQUE_ID决定的，当process.env.NODE_UNIQUE_ID未定义时，isMaster为true。 cluster.isWorker当进程不是主进程时，返回 true。（和cluster.isMaster刚好相反） cluster.schedulingPolicy调度策略，包括循环计数的 cluster.SCHED_RR，以及由操作系统决定的cluster.SCHED_NONE。 这是一个全局设置，当第一个工作进程被衍生或者调动cluster.setupMaster()时，都将第一时间生效。 cluster.settingsexecArgv 传递给Node.js可执行文件的参数列表。 (Default=process.execArgv)exec worker文件路径。 (Default=process.argv[1])args 传递给worker的参数。(Default=process.argv.slice(2))silent 是否需要发送输出值父进程的stdio。(Default=false)stdio 配置fork进程的stdio。 由于cluster模块运行依赖于IPC，这个配置必须包含’ipc’。当提供了这个选项后，将撤销silent。uid 设置进程的user标识符。 (见 setuid(2).)gid 设置进程的group标识符。 (见 setgid(2).)inspectPort | Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number. By default each worker gets its own port, incremented from the master’s process.debugPort.调用.setupMaster() (或 .fork())后，这个settings对象将会包含这些设置项，包括默认值。这个对象不打算被修改或手动设置。 cluster.setupMaster([settings])settings 详见 cluster.settings。用于修改默认’fork’ 行为。一旦调用，将会按照cluster.settings进行设置。只能由主进程调用注意: 所有的设置只对后来的 .fork()调用有效，对之前的工作进程无影响。 唯一无法通过 .setupMaster()设置的属性是传递给.fork()的env属性。 上述的默认值只在第一次调用时有效，当后续调用时，将采用cluster.setupMaster()调用时的当前值。123456789101112const cluster = require(&#x27;cluster&#x27;);cluster.setupMaster(&#123; exec: &#x27;worker.js&#x27;, args: [&#x27;--use&#x27;, &#x27;https&#x27;], silent: true&#125;);cluster.fork(); // https workercluster.setupMaster(&#123; exec: &#x27;worker.js&#x27;, args: [&#x27;--use&#x27;, &#x27;http&#x27;]&#125;);cluster.fork(); // http worker cluster.worker当前工作进程对象的引用，对于主进程则无效。 cluster.workers这是一个哈希表，储存了活跃的工作进程对象，id作为key。有了它，可以方便地遍历所有工作进程。只能在主进程中调用。 工作进程断开连接以及退出后，将会从cluster.workers里面移除。这两个事件的先后顺序并不能预先确定，但可以保证的是， cluster.workers的移除工作在’disconnect’ 和 ‘exit’两个事件中的最后一个触发之前完成。"},{"title":"nodejs基础知识(7)","date":"2023-01-06T06:52:33.000Z","updated":"2023-07-24T09:24:46.498Z","comments":true,"path":"nodejs/nodejs-note-14.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-14.html","excerpt":"","text":"Node.js 包含一个进程外的调试工具，可以通过V8检查器与内置的调试客户端访问。 要使用它，需要以 inspect 参数启动 Node.js，并带上需要调试的脚本的路径 1node inspect test.js 在脚本的源代码中插入 debugger; 语句，则会在代码的那个位置启用一个断点 123const a = 1;debugger;const b = 2; repl 命令用于运行代码。 next 命令用于步入下一行。 输入 help 可查看其他可用的命令。按下 enter 键且不输入命令，则可重复上一个调试命令。 监视器在每个断点上，监视器列表中的每个表达式都会在当前上下文中被执行，并在断点的源代码列表之前立即显示。输入 watch(‘my_expression’) 开始监视一个表达式。 watchers 命令会打印已激活的监视器。 输入 unwatch(‘my_expression’) 来移除一个监视器。 命令参考手册步进 cont, c - 继续执行 next, n - 下一步 step, s - 跳进函数 out, o - 跳出函数 pause - 暂停运行代码（类似开发者工具中的暂停按钮） 断点 setBreakpoint(), sb() - 在当前行设置断点 setBreakpoint(line), sb(line) - 在指定行设置断点 setBreakpoint(‘fn()’), sb(…) - 在函数体的第一条语句设置断点 setBreakpoint(‘script.js’, 1), sb(…) - 在 script.js 的第 1 行设置断点 clearBreakpoint(‘script.js’, 1), cb(…) - 清除 script.js 第 1 行的断点 也可以在一个还未被加载的文件（模块）中设置断点 信息 backtrace, bt - 打印当前执行框架的回溯 list(5) - 列出脚本源代码的 5 行上下文（前后各 5 行） watch(expr) - 添加表达式到监视列表 unwatch(expr) - 从监视列表移除表达式 watchers - 列出所有监视器和它们的值（每个断点会自动列出） repl - 打开调试器的 repl，用于在所调试的脚本的上下文中进行执行 exec expr - 在所调试的脚本的上下文中执行一个表达式 执行控制 run - 运行脚本（调试器开始时自动运行） restart - 重新启动脚本 kill - 终止脚本 杂项 scripts - 列出所有已加载的脚本 version - 显示 V8 引擎的版本号 Node.js 的 V8 检查器集合打开Chrome地址：chrome://inspect/#devices运行 node –inspect-brk test.js即可在浏览器中查看node运行结果相关文档地址 DNS(域名解析)dns 模块包含两类函数： 第一类函数，使用底层操作系统工具进行域名解析，且无需进行网络通信。 这类函数只有一个：[dns.lookup()]。12345const dns = require(&#x27;dns&#x27;);dns.lookup(&#x27;iana.org&#x27;, (err, address, family) =&gt; &#123; console.log(&#x27;IP 地址: %j 地址族: IPv%s&#x27;, address, family);&#125;);// IP 地址: &quot;192.0.43.8&quot; 地址族: IPv4 第二类函数，连接到一个真实的 DNS 服务器进行域名解析，且始终使用网络进行 DNS 查询。 这类函数包含了 dns 模块中除 [dns.lookup()] 以外的所有函数。 这些函数使用与 dns.lookup() 不同的配置文件（例如 /etc/hosts）。 这类函数适合于那些不想使用底层操作系统工具进行域名解析、而是想使用网络进行 DNS 查询的开发者。12345678910111213const dns = require(&#x27;dns&#x27;);dns.resolve4(&#x27;archive.org&#x27;, (err, addresses) =&gt; &#123; if (err) throw err; console.log(`IP 地址: $&#123;JSON.stringify(addresses)&#125;`); addresses.forEach((a) =&gt; &#123; dns.reverse(a, (err, hostnames) =&gt; &#123; if (err) &#123; throw err; &#125; console.log(`IP 地址 $&#123;a&#125; 逆向解析到域名: $&#123;JSON.stringify(hostnames)&#125;`); &#125;); &#125;);&#125;); Class dns.ResolverDNS请求的独立解析程序。使用默认的设置创建一个新的解析程序。为一个解析程序设置servers使用[resolver.setServers()][dns.setServers()]，它不会影响其他的解析程序： 1234567const &#123; Resolver &#125; = require(&#x27;dns&#x27;);const resolver = new Resolver();resolver.setServers([&#x27;4.4.4.4&#x27;]);// This request will use the server at 4.4.4.4, independent of global settings.resolver.resolve4(&#x27;example.org&#x27;, (err, addresses) =&gt; &#123; // ...&#125;); dns模块方法： [resolver.getServers()][dns.getServers()] [resolver.setServers()][dns.setServers()] [resolver.resolve()][dns.resolve()] [resolver.resolve4()][dns.resolve4()] [resolver.resolve6()][dns.resolve6()] [resolver.resolveAny()][dns.resolveAny()] [resolver.resolveCname()][dns.resolveCname()] [resolver.resolveMx()][dns.resolveMx()] [resolver.resolveNaptr()][dns.resolveNaptr()] [resolver.resolveNs()][dns.resolveNs()] [resolver.resolvePtr()][dns.resolvePtr()] [resolver.resolveSoa()][dns.resolveSoa()] [resolver.resolveSrv()][dns.resolveSrv()] [resolver.resolveTxt()][dns.resolveTxt()] [resolver.reverse()][dns.reverse()] resolver.cancel()取消这个解析程序的未解决的DNS查询，相应的回调用一个ECANCELLED码调用。 dns.getServers()返回一个用于当前DNS解析的IP地址的数组的字符串，格式根据[rfc5952][]。如果使用自定义端口，那么字符串将包括一个端口部分。 dns.lookup(hostname[, options], callback) hostname options | family The record family. Must be 4 or 6. IPv4 and IPv6 addresses are both returned by default. hints One or more [supported getaddrinfo flags][]. Multiple flags may be passed by bitwise ORing their values. all When true, the callback returns all resolved addresses in an array. Otherwise, returns a single address. Default: false verbatim When true, the callback receives IPv4 and IPv6 addresses in the order the DNS resolver returned them. When false, IPv4 addresses are placed before IPv6 addresses. Default: currently false (addresses are reordered) but this is expected to change in the not too distant future. New code should use { verbatim: true }. callback err address A string representation of an IPv4 or IPv6 address. family 4 or 6, denoting the family of address.解析hostname(例如：’nodejs.org’)为第一个找到的A（IPv4）或AAAA（IPv6）记录。options可以是对象或者整数。如果options没有被提供，那么IPv4 和 IPv6都是有效的。如果options是整数，只能是4或6。另外，options可以是一个含有以下属性的对象： family - T地址族。如果提供，必须为整数4或6。如果没有提供，只接受IPv4和IPv6地址。 hints: - 如果提供，它必须是一个或多个支持的getaddrinfo标识。如果没有提供，那么没有标识被传递给getaddrinfo。多个标识可以通过在逻辑上ORing它们的值，来传递给hints。支持的getaddrinfo标识请参阅下文。有关支持的标志的更多信息请查询[supported getaddrinfo flags][]章节。 all: - 值为true时， 回调函数返回一个包含所有解析后地址的数组，否则只返回一个地址。默认值为false。所有的参数都是可选的。回调函数包含(err, address, family)参数。address是IPv4或IPv6地址字符串。family、是整数4或6，表示地址族（不一定是最初传递给查找的值）。当all属性被设置为true时，回调函数参数变为(err, addresses)，addresses则变成一个由address 和 family 属性组成的对象数组。发生错误时，err是一个[Error][]对象，err.code是错误码。不仅在主机名不存在时，在如没有可用的文件描述符等情况下查找失败，err.code也会被设置为’ENOENT’。1234567891011121314const dns = require(&#x27;dns&#x27;);const options = &#123; family: 6, hints: dns.ADDRCONFIG | dns.V4MAPPED,&#125;;dns.lookup(&#x27;example.com&#x27;, options, (err, address, family) =&gt; console.log(&#x27;address: %j family: IPv%s&#x27;, address, family));// address: &quot;::ffff:93.184.216.34&quot; family: IPv6// When options.all is true, the result will be an Array.options.all = true;dns.lookup(&#x27;example.com&#x27;, options, (err, addresses) =&gt; console.log(&#x27;addresses: %j&#x27;, addresses));// addresses: [&#123;&quot;address&quot;:&quot;::ffff:93.184.216.34&quot;,&quot;family&quot;:6&#125;] 以下内容可以作为hints标志传递给[dns.lookup()]: dns.ADDRCONFIG: 返回当前系统支持的地址类型。例如，如果当前系统至少配置了一个 IPv4 地址，则返回 IPv4地址。不考虑回环地址。 dns.V4MAPPED: 如果指定了 IPv6 家族， 但是没有找到 IPv6 地址，将返回 IPv4 映射的 IPv6地址。在有些操作系统中不支持 dns.lookupService(address, port, callback) address port callback err hostname e.g. example.com service e.g. http将参数address和port传入操作系统底层getnameinfo服务来解析处理并返回主机名。如果address不是有效的IP地址，会抛出TypeError。port必须是一个整数.如果不是规定的端口号，会抛出TypeError.出错情况下，err是一个Error对象，err.code代码错误码。12345const dns = require(&#x27;dns&#x27;);dns.lookupService(&#x27;127.0.0.1&#x27;, 22, (err, hostname, service) =&gt; &#123; console.log(hostname, service); // DESKTOP-894BKU0 ssh&#125;); 如果以 [util.promisify()][] 方式进行调用, 它将返回一个包含hostname和service属性的 Promise 对象。 dns.resolve(hostname[, rrtype], callback) hostname 解析的主机名。 rrtype 资源记录类型. 默认: ‘A’. callback err records &lt;string[]&gt; | &lt;Object[]&gt; | 使用DNS协议来解析一个主机名(e.g. ‘nodejs.org’)为一个资源记录的数组。回调函数的参数为(err, records)。当成功时，records将是一个资源记录的数组。它的类型和结构取决于rrtype出错时，err是一个[Error][] object，err.code是DNS error codes的一种。 dns.resolve4(hostname[, options], callback) hostname 需要解析的主机名。 options ttl 记录每一条记录的存活次数 (TTL)。如果为 true， 返回的结果将会为 Object 的数组，就像 { address: ‘1.2.3.4’, ttl: 60 } 带有 TTL 秒数的记录，而不是 string 的数组. callback err addresses &lt;string[]&gt; | &lt;Object[]&gt;使用DNS协议解析IPv4地址主机名(A记录)。addresses参数是传递给callback函数的IPv4地址数组。（例如：[‘74.125.79.104’, ‘74.125.79.105’, ‘74.125.79.106’]） dns.resolve6(hostname[, options], callback)参数说明参考：dns.resolve4 dns.resolveCname(hostname, callback) hostname callback err addresses &lt;string[]&gt;使用DNS协议解析CNAME记录主机名。addresses参数是传递给callback函数规范内有效的主机名数组（例如：[‘bar.example.com’]） dns.resolveMx(hostname, callback) hostname callback err addresses &lt;Object[]&gt;使用DNS协议处理邮件交换记录主机名(MX记录)。addresses参数是传递给callback函数的主机名对象数组，对象包含priority和exchange属性（例如： [{priority: 10, exchange: ‘mx.example.com’}, …]）。 dns.resolveNaptr(hostname, callback)参数与上面的类似使用DNS协议来处理基于正则表达式匹配的记录(NAPTR记录)的主机名。addresses参数是传递给callback函数的主机名对象数组，对象包含属性： flags service regexp replacement order preference dns.resolveNs(hostname, callback)参数与上面的类似使用DNS协议处理名称服务器主机名记录(NS记录)。addresses为有效的名称服务器记录主机名数组（eg:[‘ns1.example.com’, ‘ns2.example.com’]）。 dns.resolvePtr(hostname, callback)参数与上面的类似使用DNS协议处理主机名引用记录(PTR记录)。addresses参数将一个字符串数组传递给回调函数callback,其中包含回复记录。 dns.resolveSoa(hostname, callback)参数与上面的类似使用DNS协议处理主机名子域名记录(SOA记录)。addresses参数为一个对象包含以下属性： nsname hostmaster serial refresh retry expire minttl dns.resolveSrv(hostname, callback)参数与上面的类似使用DNS协议来处理主机名服务记录(SRV记录)。callback函数返回的addresses参数为对象数组,每个对象包含以下属性： priority weight port name dns.resolveTxt(hostname, callback)参数与上面的类似使用DNS协议处理文本查询主机名(TXT记录)。回调函数callback会返回records参数，它是一个文本记录与主机名一一对应的二维数组(例如：[ [‘v=spf1 ip4:0.0.0.0 ‘, ‘~all’ ] ]). 每个数组文本块包含一条记录。根据用例,这些可以是连接在一起或单独对待。 dns.resolveAny(hostname, callback) hostname callback err ret &lt;Object[]&gt;使用DNS协议解析所有记录(也称为ANY或 * query)。传递给回调函数的ret参数将是一个包含各种类型记录的数组。每个对象都有一个属性类型，用于指示当前记录的类型。根据类型的不同，额外的属性会出现在对象上: dns.reverse(ip, callback) ip callback err hostnames &lt;string[]&gt;执行一个反向DNS查询返回IPv4或IPv6地址的主机名的数组。出错情况下，err是一个Error对象，err.code代码错误码。 dns.setServers(servers)servers &lt;string[]&gt; array of [rfc5952][] formatted addresses设置IP地址服务器端口在进行DNS解析时可用，servers参数是一个[rfc5952][]数组格式的地址。 如果端口是IANA默认端口(53),那么它可以被忽略。ip地址无效将会报错。dns.setServers()方法不要在DNS查询过程中使用。 错误码每个DNS查询可以返回一个错误代码如下: dns.NODATA: DNS服务返回没有数据. dns.FORMERR: DNS服务器查询没有格式化. dns.SERVFAIL: DNS服务器返回失败。 dns.NOTFOUND: 域名未找到。 dns.NOIMP: DNS服务器不执行请求的操作。 dns.REFUSED: 查询DNS服务器拒绝。 dns.BADQUERY: 未格式化DNS查询。 dns.BADNAME: 未格式化主机名 dns.BADFAMILY: 没有提供地址族 dns.BADRESP: 未格式化DNS回复 dns.CONNREFUSED: 无法连接DNS服务器 dns.TIMEOUT: 连接DNS服务器超时 dns.EOF: 文件末尾 dns.FILE: 读取文件错误 dns.NOMEM: 内存溢出 dns.DESTRUCTION: 通道以及销毁 dns.BADSTR: 未格式化字符串 dns.BADFLAGS: 指定非法标记 dns.NONAME: 给定的主机名不是数字。 dns.BADHINTS: 指定非法的提示标志。 dns.NOTINITIALIZED: c-ares异步DNS请求库初始化未完成。 dns.LOADIPHLPAPI: 加载iphlpapi.dll(Windows IP辅助API应用程序接口模块)错误 dns.ADDRGETNETWORKPARAMS: 找不到GetNetworkParams(读取本机DNS信息)函数 dns.CANCELLED: DNS查询取消"},{"title":"nodejs基础知识(6)","date":"2023-01-03T10:04:15.000Z","updated":"2023-07-24T09:24:46.498Z","comments":true,"path":"nodejs/nodejs-note-13.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-13.html","excerpt":"","text":"crypto 模块提供了加密功能，包含对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。 使用 require(‘crypto’) 来访问该模块。 1const crypto = require(&#x27;crypto&#x27;); Class: CertificateSPKAC 最初是由 Netscape 实现的一种证书签名请求机制, 现在正式成为 HTML5’s keygen element 的一部分.crypto 模块提供 Certificate 类用于处理 SPKAC 数据. 最普遍的用法是处理 HTML5 keygen 元素 产生的输出. Node.js 内部使用 OpenSSL’s SPKAC implementation 处理. new crypto.Certificate()#可以使用 new 关键字或者调用 crypto.Certificate() 方法创建 Certificate 类的实例: 123const crypto = require(&#x27;crypto&#x27;);const cert1 = new crypto.Certificate();const cert2 = crypto.Certificate(); certificate.exportChallenge(spkac)spkac | | | 返回 返回 spkac 数据结构的 challenge 部分，spkac 包含一个公钥和一个 challange。 12345const cert = require(&#x27;crypto&#x27;).Certificate();const spkac = getSpkacSomehow();// 生成过程省略了，不存在这个函数，只是一种象征意义const challenge = cert.exportChallenge(spkac);console.log(challenge.toString(&#x27;utf8&#x27;));// Prints: the challenge as a UTF8 string certificate.exportPublicKey(spkac)spkac | | | 返回 数据结构的公钥部分，spkac 包含一个公钥和一个 challange。 12345const cert = require(&#x27;crypto&#x27;).Certificate();const spkac = getSpkacSomehow();// 生成过程省略了，不存在这个函数，只是一种象征意义const publicKey = cert.exportPublicKey(spkac);console.log(publicKey);// Prints: the public key as &lt;Buffer ...&gt; certificate.verifySpkac(spkac)spkac | | 返回 如果 spkac 数据结构是有效的返回 true，否则返回 false。 1234const cert = require(&#x27;crypto&#x27;).Certificate();const spkac = getSpkacSomehow();console.log(cert.verifySpkac(Buffer.from(spkac)));// Prints: true 或者 false Class: CipherCipher类的实例用于加密数据。这个类可以用在以下两种方法中的一种: 作为stream，既可读又可写，未加密数据的编写是为了在可读的方面生成加密的数据 使用cipher.update()和cipher.final()方法产生加密的数据。crypto.createCipher()或crypto.createCipheriv()方法用于创建Cipher实例。Cipher对象不能直接使用new关键字创建。123456789101112131415161718192021222324252627282930313233343536// 使用Cipher对象作为流const crypto = require(&#x27;crypto&#x27;);const cipher = crypto.createCipher(&#x27;aes192&#x27;, &#x27;a password&#x27;);let encrypted = &#x27;&#x27;;cipher.on(&#x27;readable&#x27;, () =&gt; &#123; const data = cipher.read(); if (data) encrypted += data.toString(&#x27;hex&#x27;);&#125;);cipher.on(&#x27;end&#x27;, () =&gt; &#123; console.log(encrypted); // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504&#125;);cipher.write(&#x27;some clear text data&#x27;);cipher.end();// 使用Cipher和管道流const crypto = require(&#x27;crypto&#x27;);const fs = require(&#x27;fs&#x27;);const cipher = crypto.createCipher(&#x27;aes192&#x27;, &#x27;a password&#x27;);const input = fs.createReadStream(&#x27;test.js&#x27;);const output = fs.createWriteStream(&#x27;test.enc&#x27;);input.pipe(cipher).pipe(output);// 使用cipher.update()和cipher.final()方法const crypto = require(&#x27;crypto&#x27;);const cipher = crypto.createCipher(&#x27;aes192&#x27;, &#x27;a password&#x27;);let encrypted = cipher.update(&#x27;some clear text data&#x27;, &#x27;utf8&#x27;, &#x27;hex&#x27;);encrypted += cipher.final(&#x27;hex&#x27;);console.log(encrypted);// Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504 cipher.final([outputEncoding])outputEncoding 返回任何加密的内容。如果 outputEncoding 参数是’latin1’, ‘base64’ 或者 ‘hex’，返回字符串。 如果没有提供 outputEncoding，则返回Buffer。一旦cipher.final()方法已被调用，Cipher 对象就不能再用于加密数据。如果试图再次调用cipher.final()，将会抛出一个错误。 cipher.setAAD(buffer)buffer 返回方法链。当使用经过验证的加密模式(目前只支持GCM)时，cipher.setAAD()方法设置用于additional authenticated data(附加验证的data(AAD))输入参数的值。cipher.setAAD()法必须在cipher.update()之前调用。 cipher.getAuthTag()#当使用经验证的加密模式时(目前只有GCM支持),cipher.getAuthTag()方法返回一个Buffer，此Buffer包含已从给定数据计算后的authentication tag。cipher.getAuthTag()方法只能在使用cipher.final()方法完全加密后调用。 cipher.setAutoPadding([autoPadding])autoPadding 默认为 true.返回方法链。当使用块加密算法时，Cipher类会自动添加padding到输入数据中，来适配相应块大小。可调用cipher.setAutoPadding(false)禁用默认padding。当autoPadding是false时，整个输入数据的长度必须是cipher块大小的倍数，否则cipher.final()将抛出一个错误。 禁用自动填充对于非标准填充是有用的，例如使用0x0代替PKCS填充。cipher.setAutoPadding()必须在cipher.final()之前被调用。 cipher.update(data[, inputEncoding][, outputEncoding])用data更新密码。如果给出了inputEncoding的论证，它的值必须是’utf8’, ‘ascii’, 或者’latin1’，而data参数是使用指定编码的字符串。如果不给出inputEncoding的参数，则data必须是Buffer，TypedArray， 或者DataView。如果data是一个Buffer，TypedArray， 或者 DataView， 那么inputEncoding就被忽略了。outputEncoding指定了加密数据的输出格式，可以是’latin1’， ‘base64’ 或者 ‘hex’。如果指定了outputEncoding，则返回使用指定编码的字符串。如果没有outputEncoding被提供，会返回Buffer。cipher.update()方法可以用新数据多次调用，直到cipher.final()被调用。在cipher.final()之后调用cipher.update()将抛出错误。 Class: DecipherDecipher类的实例用于解密数据。这个类可以用在以下两种方法中的一种: 作为stream，既可读，又可写，加密数据的编写是为了在可读的方面生成未加密的数据 使用decipher.update()和decipher.final()方法产生未加密的数据。crypto.createDecipher()或crypto.createDecipheriv()的方法 用于创建Decipher实例。Decipher对象不能直接使用new关键字创建。12345678910111213141516171819202122232425262728293031323334353637383940// 使用Decipher对象作为流const crypto = require(&#x27;crypto&#x27;);const decipher = crypto.createDecipher(&#x27;aes192&#x27;, &#x27;a password&#x27;);let decrypted = &#x27;&#x27;;decipher.on(&#x27;readable&#x27;, () =&gt; &#123; const data = decipher.read(); if (data) decrypted += data.toString(&#x27;utf8&#x27;);&#125;);decipher.on(&#x27;end&#x27;, () =&gt; &#123; console.log(decrypted); // Prints: some clear text data&#125;);const encrypted = &#x27;ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504&#x27;;decipher.write(encrypted, &#x27;hex&#x27;);decipher.end();// 使用Decipher和管道流const crypto = require(&#x27;crypto&#x27;);const fs = require(&#x27;fs&#x27;);const decipher = crypto.createDecipher(&#x27;aes192&#x27;, &#x27;a password&#x27;);const input = fs.createReadStream(&#x27;test.enc&#x27;);const output = fs.createWriteStream(&#x27;test.js&#x27;);input.pipe(decipher).pipe(output);// 使用decipher.update()和decipher.final()方法const crypto = require(&#x27;crypto&#x27;);const decipher = crypto.createDecipher(&#x27;aes192&#x27;, &#x27;a password&#x27;);const encrypted = &#x27;ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504&#x27;;let decrypted = decipher.update(encrypted, &#x27;hex&#x27;, &#x27;utf8&#x27;);decrypted += decipher.final(&#x27;utf8&#x27;);console.log(decrypted);// Prints: some clear text data decipher.final([outputEncoding])outputEncoding 返回任何剩余的解密内容。如果outputEncoding参数是’latin1’，’ascii’或’utf8’之一，则返回一个字符串。 如果未提供输出编码，则返回Buffer。一旦调用了decipher.final()方法，Decipher对象就不能再用于解密数据。 试图不止一次调用decipher.final()会导致错误被抛出。 decipher.setAAD(buffer)buffer | | 返回的一个方法链。当使用经过验证的加密模式（当前仅支持GCM）时，decipher.setAAD()方法会设置用于附加验证数据(AAD)输入参数的值。decipher.setAAD() 必须在decipher.update()之前被调用。 decipher.setAuthTag(buffer)buffer | | 返回的一个方法链。When using an authenticated encryption mode (only GCM is currently supported), the decipher.setAuthTag() method is used to pass in the received authentication tag. If no tag is provided, or if the cipher text has been tampered with, decipher.final() will throw, indicating that the cipher text should be discarded due to failed authentication.(当使用经过身份验证的加密模式(目前只支持GCM)时，使用decipher.setAuthTag()方法传入接收到的身份验证标记。如果没有提供标记，或者密文已经被篡改，则decipher.final()将抛出，表明由于身份验证失败，密文应该被丢弃。)decipher.setAuthTag()必须在decipher.final()之前被调用。 decipher.setAutoPadding([autoPadding]) autoPadding 默认为 true. 返回方法链。When data has been encrypted without standard block padding, calling decipher.setAutoPadding(false) will disable automatic padding to prevent decipher.final() from checking for and removing padding.(当数据加密时没有标准块填充，调用decipher.setAutoPadding(false)将禁用自动填充，以防止decipher.final()检查和删除填充。)Turning auto padding off will only work if the input data’s length is a multiple of the ciphers block size.(关闭自动填充只有当输入数据的长度是密码块大小的倍数时才会工作。) decipher.setAutoPadding()必须在decipher.final()之前被调用。 decipher.update(data[, inputEncoding][, outputEncoding]) data | | | inputEncoding outputEncoding 使用新数据更新解密。如果给出inputEncoding参数，它的值必须是’latin1’, ‘base64’或’hex’中的一个，data参数是使用指定编码的字符串。如果未给出inputEncoding参数，则data必须是Buffer。如果data是Buffer，则忽略inputEncoding。outputEncoding指定加密数据的输出格式，可以是’latin1’, ‘ascii’或’utf8’。如果指定了outputEncoding，则返回使用指定编码的字符串。如果未提供outputEncoding，则返回Buffer。可以使用新数据多次调用decipher.update()方法，直到调用decipher.final()。在decipher.final()之后调用decipher.update()会导致抛出错误。 Class: DiffieHellmanDiffieHellman类是一个用来创建Diffie-Hellman键交换的工具。 DiffieHellman类的实例可以使用crypto.createDiffieHellman()方法。 1234567891011121314151617const crypto = require(&#x27;crypto&#x27;);const assert = require(&#x27;assert&#x27;);// Generate Alice&#x27;s keys...const alice = crypto.createDiffieHellman(2048);const aliceKey = alice.generateKeys();// Generate Bob&#x27;s keys...const bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator());const bobKey = bob.generateKeys();// Exchange and generate the secret...const aliceSecret = alice.computeSecret(bobKey);const bobSecret = bob.computeSecret(aliceKey);// OKconsole.log(assert.strictEqual(aliceSecret.toString(&#x27;hex&#x27;), bobSecret.toString(&#x27;hex&#x27;))); diffieHellman.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding]) otherPublicKey | | | inputEncoding outputEncoding Computes the shared secret using otherPublicKey as the other party’s public key and returns the computed shared secret. The supplied key is interpreted using the specified inputEncoding, and secret is encoded using specified outputEncoding. Encodings can be ‘latin1’, ‘hex’, or ‘base64’. If the inputEncoding is not provided, otherPublicKey is expected to be a Buffer, TypedArray, or DataView.If outputEncoding is given a string is returned; otherwise, a Buffer is returned.(使用otherPublicKey作为另一方的公钥计算共享密钥，并返回计算出的共享密钥。提供的key使用指定的inputEncoding进行解释，secret使用指定的outputEncoding进行编码。编码可以是’latin1’， ‘hex’或’base64’。如果inputEncoding未提供，otherPublicKey将被期望为Buffer、TypedArray或DataView。如果给出outputEncoding，则返回一个字符串;否则，返回Buffer。) diffieHellman.generateKeys([encoding]) encoding Generates private and public Diffie-Hellman key values, and returns the public key in the specified encoding. This key should be transferred to the other party. Encoding can be ‘latin1’, ‘hex’, or ‘base64’. If encoding is provided a string is returned; otherwise a Buffer is returned.(生成私有和公共的Diffie-Hellman密钥值，并返回指定编码的公钥。这把钥匙应该移交给对方。Encoding可以是’latin1’， ‘hex’或’base64’。如果提供了编码，则返回字符串;否则返回Buffer。) diffieHellman.getGenerator([encoding]) encoding Returns the Diffie-Hellman generator in the specified encoding, which can be ‘latin1’, ‘hex’, or ‘base64’. If encoding is provided a string is returned; otherwise a Buffer is returned.(返回指定编码的Diffie-Hellman生成器，可以是’latin1’、’hex’或’base64’。如果提供了编码，则返回字符串;否则返回Buffer。) diffieHellman.getPrime([encoding]) encoding Returns the Diffie-Hellman prime in the specified encoding, which can be ‘latin1’, ‘hex’, or ‘base64’. If encoding is provided a string is returned; otherwise a Buffer is returned.(返回指定编码的Diffie-Hellman素数，可以是’latin1’、’hex’或’base64’。如果提供了编码，则返回字符串;否则返回Buffer。) diffieHellman.getPrivateKey([encoding]) encoding Returns the Diffie-Hellman private key in the specified encoding, which can be ‘latin1’, ‘hex’, or ‘base64’. If encoding is provided a string is returned; otherwise a Buffer is returned.(返回指定编码的Diffie-Hellman私钥，可以是’latin1’、’hex’或’base64’。如果提供了编码，则返回字符串;否则返回Buffer。) diffieHellman.getPublicKey([encoding]) encoding Returns the Diffie-Hellman public key in the specified encoding, which can be ‘latin1’, ‘hex’, or ‘base64’. If encoding is provided a string is returned; otherwise a Buffer is returned.(返回指定编码的Diffie-Hellman公钥，可以是’latin1’、’hex’或’base64’。如果提供了编码，则返回字符串;否则返回Buffer。) diffieHellman.setPrivateKey(privateKey[, encoding]) privateKey | | | encoding Sets the Diffie-Hellman private key. If the encoding argument is provided and is either ‘latin1’, ‘hex’, or ‘base64’, privateKey is expected to be a string. If no encoding is provided, privateKey is expected to be a Buffer, TypedArray, or DataView.(设置Diffie-Hellman私钥。如果encoding参数是’latin1’， ‘hex’或’base64’， privateKey将是一个字符串。如果没有提供编码，privateKey应该是Buffer、TypedArray或DataView。) diffieHellman.setPublicKey(publicKey[, encoding]) publicKey | | | encoding Sets the Diffie-Hellman public key. If the encoding argument is provided and is either ‘latin1’, ‘hex’ or ‘base64’, publicKey is expected to be a string. If no encoding is provided, publicKey is expected to be a Buffer, TypedArray, or DataView.(设置Diffie-Hellman公钥。如果encoding参数是’latin1’， ‘hex’或’base64’， publicKey将是一个字符串。如果没有提供编码，则publicKey应该是Buffer、TypedArray或DataView。) diffieHellman.verifyErrorA bit field containing any warnings and/or errors resulting from a check performed during initialization of the DiffieHellman object.The following values are valid for this property (as defined in constants module):(一个位字段，包含在DiffieHellman对象初始化期间执行的检查所导致的任何警告和/或错误。以下值对该属性有效(在constants模块中定义)) DH_CHECK_P_NOT_SAFE_PRIME DH_CHECK_P_NOT_PRIME DH_UNABLE_TO_CHECK_GENERATOR DH_NOT_SUITABLE_GENERATOR Class: ECDHECDH类是创建椭圆曲线Diffie-Hellman（Elliptic Curve Diffie-Hellman (ECDH)）键交换的实用工具。 ECDH类的实例可以使用crypto.createECDH()方法。 1234567891011121314151617const crypto = require(&#x27;crypto&#x27;);const assert = require(&#x27;assert&#x27;);// Generate Alice&#x27;s keys...const alice = crypto.createECDH(&#x27;secp521r1&#x27;);const aliceKey = alice.generateKeys();// Generate Bob&#x27;s keys...const bob = crypto.createECDH(&#x27;secp521r1&#x27;);const bobKey = bob.generateKeys();// Exchange and generate the secret...const aliceSecret = alice.computeSecret(bobKey);const bobSecret = bob.computeSecret(aliceKey);assert.strictEqual(aliceSecret.toString(&#x27;hex&#x27;), bobSecret.toString(&#x27;hex&#x27;));// OK ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])作用参考diffieHellman.computeSecret ecdh.generateKeys([encoding[, format]]) encoding format Defaults to uncompressed.Generates private and public EC Diffie-Hellman key values, and returns the public key in the specified format and encoding. This key should be transferred to the other party.The format argument specifies point encoding and can be ‘compressed’ or ‘uncompressed’. If format is not specified, the point will be returned in ‘uncompressed’ format.The encoding argument can be ‘latin1’, ‘hex’, or ‘base64’. If encoding is provided a string is returned; otherwise a Buffer is returned.(生成私有和公共EC Diffie-Hellman key值，并返回指定格式和编码的公钥。这把钥匙应该移交给对方。format参数指定点编码，可以是’compressed’或’uncompressed’。如果未指定format，则该点将以“未压缩”格式返回。encoding参数可以是’latin1’， ‘hex’或’base64’。如果提供了编码，则返回字符串;否则返回Buffer。) ecdh.getPrivateKey([encoding])作用参考diffieHellman.getPrivateKey ecdh.getPublicKey([encoding][, format])作用参考diffieHellman.getPublicKey、ecdh.generateKeys ecdh.setPrivateKey(privateKey[, encoding]) privateKey | | | encoding Sets the EC Diffie-Hellman private key. The encoding can be ‘latin1’, ‘hex’ or ‘base64’. If encoding is provided, privateKey is expected to be a string; otherwise privateKey is expected to be a Buffer, TypedArray, or DataView.If privateKey is not valid for the curve specified when the ECDH object was created, an error is thrown. Upon setting the private key, the associated public point (key) is also generated and set in the ECDH object.(设置EC Diffie-Hellman私钥。编码可以是’latin1’， ‘hex’或’base64’。如果提供了编码，privateKey应该是一个字符串;否则privateKey将被期望为Buffer, TypedArray或DataView。如果privateKey对于创建ECDH对象时指定的曲线无效，则抛出错误。在设置私钥之后，还会生成相关的公共点(密钥)，并在ECDH对象中进行设置。) Class: HashHash类是用于创建数据哈希值的工具类。它能用以下方法使用： 作为一个stream，它既可读又可写，数据被写入要在可读的方面生成一个计算散列摘要 使用hash.update()和hash.digest()方法产生计算后的哈希。crypto.createHash()方法用于创建Hash实例。Hash不能直接使用new关键字创建对象。12345678910111213141516171819202122232425262728// 使用Hash对象作为流:const crypto = require(&#x27;crypto&#x27;);const hash = crypto.createHash(&#x27;sha256&#x27;);hash.on(&#x27;readable&#x27;, () =&gt; &#123; const data = hash.read(); if (data) &#123; console.log(data.toString(&#x27;hex&#x27;)); // Prints: // 6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50 &#125;&#125;);hash.write(&#x27;some data to hash&#x27;);hash.end();// 使用 Hash 和管道流const crypto = require(&#x27;crypto&#x27;);const fs = require(&#x27;fs&#x27;);const hash = crypto.createHash(&#x27;sha256&#x27;);const input = fs.createReadStream(&#x27;test.js&#x27;);input.pipe(hash).pipe(process.stdout);// 使用hash.update()和hash.digest()const crypto = require(&#x27;crypto&#x27;);const hash = crypto.createHash(&#x27;sha256&#x27;);hash.update(&#x27;some data to hash&#x27;);console.log(hash.digest(&#x27;hex&#x27;));// Prints:// 6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50 hash.digest([encoding]) encoding Calculates the digest of all of the data passed to be hashed (using the hash.update() method). The encoding can be ‘hex’, ‘latin1’ or ‘base64’. If encoding is provided a string will be returned; otherwise a Buffer is returned.The Hash object can not be used again after hash.digest() method has been called. Multiple calls will cause an error to be thrown.(计算传递给散列的所有数据的摘要(使用hash.update()方法)。编码可以是’hex’， ‘latin1’或’base64’。如果提供了编码，则返回一个字符串;否则返回Buffer。Hash对象在调用Hash .digest()方法后不能再次使用。多次调用将导致抛出错误。) hash.update(data[, inputEncoding]) data | | | inputEncoding Updates the hash content with the given data, the encoding of which is given in inputEncoding and can be ‘utf8’, ‘ascii’ or ‘latin1’. If encoding is not provided, and the data is a string, an encoding of ‘utf8’ is enforced. If data is a Buffer, TypedArray, or DataView, then inputEncoding is ignored.This can be called many times with new data as it is streamed.(用给定的数据更新哈希内容，其编码在inputEncoding中给出，可以是’utf8’， ‘ascii’或’latin1’。如果没有提供编码，并且数据是字符串，则强制使用’utf8’编码。如果data是Buffer、TypedArray或DataView，则inputEncoding将被忽略。在流化新数据时，可以多次调用这个函数。) Class: HmacHmac类是用于创建加密Hmac摘要的工具。它可以有两种用法: 作为stream,它既可读又可写，数据被写入要在可读的方面生成一个经过计算的HMAC摘要。 使用hmac.update()和hmac.digest()方法产生计算后的HMAC摘要。crypto.createHmac()方法用来创建Hmac实例。Hmac不能直接使用new关键字创建对象。1234567891011121314151617181920212223242526272829// 使用Hmac对象作为流:const crypto = require(&#x27;crypto&#x27;);const hmac = crypto.createHmac(&#x27;sha256&#x27;, &#x27;a secret&#x27;);hmac.on(&#x27;readable&#x27;, () =&gt; &#123; const data = hmac.read(); if (data) &#123; console.log(data.toString(&#x27;hex&#x27;)); // Prints: // 7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e &#125;&#125;);hmac.write(&#x27;some data to hash&#x27;);hmac.end();// 使用Hmac和管道流const crypto = require(&#x27;crypto&#x27;);const fs = require(&#x27;fs&#x27;);const hmac = crypto.createHmac(&#x27;sha256&#x27;, &#x27;a secret&#x27;);const input = fs.createReadStream(&#x27;test.js&#x27;);input.pipe(hmac).pipe(process.stdout);// 使用hmac.update()和hmac.digest()方法const crypto = require(&#x27;crypto&#x27;);const hmac = crypto.createHmac(&#x27;sha256&#x27;, &#x27;a secret&#x27;);hmac.update(&#x27;some data to hash&#x27;);console.log(hmac.digest(&#x27;hex&#x27;));// Prints:// 7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e hmac.digest([encoding]) encoding Calculates the HMAC digest of all of the data passed using hmac.update(). The encoding can be ‘hex’, ‘latin1’ or ‘base64’. If encoding is provided a string is returned; otherwise a Buffer is returned;The Hmac object can not be used again after hmac.digest() has been called. Multiple calls to hmac.digest() will result in an error being thrown.(计算使用HMAC .update()传递的所有数据的HMAC摘要。编码可以是’hex’， ‘latin1’或’base64’。如果提供了编码，则返回字符串;否则返回Buffer;Hmac对象在调用Hmac .digest()后不能再使用。多次调用hmac.digest()将导致抛出错误。) hmac.update(data[, inputEncoding]) data | | | inputEncoding Updates the Hmac content with the given data, the encoding of which is given in inputEncoding and can be ‘utf8’, ‘ascii’ or ‘latin1’. If encoding is not provided, and the data is a string, an encoding of ‘utf8’ is enforced. If data is a Buffer, TypedArray, or DataView, then inputEncoding is ignored.This can be called many times with new data as it is streamed.(用给定的数据更新Hmac内容，这些数据的编码在inputEncoding中给出，可以是’utf8’， ‘ascii’或’latin1’。如果没有提供编码，并且数据是字符串，则强制使用’utf8’编码。如果data是Buffer、TypedArray或DataView，则inputEncoding将被忽略。在流化新数据时，可以多次调用这个函数。) Class: Sign“Sign”类是生成签名的实用工具。它有两种使用方式: 作为一个可写的stream，在这里，要签署的数据是写出来的，sign.sign()方法用于生成并返回签名 使用sign.update()和sign.sign()方法生产签名。crypto.createSign()方法用于创建Sign实例。Sign实例不能直接使用new关键字创建。1234567891011121314151617181920212223242526// 使用“符号”对象作为流:const crypto = require(&#x27;crypto&#x27;);const sign = crypto.createSign(&#x27;SHA256&#x27;);sign.write(&#x27;some data to sign&#x27;);sign.end();const privateKey = getPrivateKeySomehow();console.log(sign.sign(privateKey, &#x27;hex&#x27;));// Prints: the calculated signature using the specified private key and// SHA-256. For RSA keys, the algorithm is RSASSA-PKCS1-v1_5 (see padding// parameter below for RSASSA-PSS). For EC keys, the algorithm is ECDSA.// 使用sign.update()和sign.sign()方法：const crypto = require(&#x27;crypto&#x27;);const sign = crypto.createSign(&#x27;SHA256&#x27;);sign.update(&#x27;some data to sign&#x27;);const privateKey = getPrivateKeySomehow();console.log(sign.sign(privateKey, &#x27;hex&#x27;));// Prints: the calculated signature// 使用ECDSA与SHA256进行签名const crypto = require(&#x27;crypto&#x27;);const sign = crypto.createSign(&#x27;RSA-SHA256&#x27;);sign.update(&#x27;some data to sign&#x27;);const privateKey = getPrivateKeySomehow();console.log(sign.sign(privateKey, &#x27;hex&#x27;));// Prints: the calculated signature sign.sign(privateKey[, outputFormat]) privateKey | key passphrase outputFormat Calculates the signature on all the data passed through using either sign.update() or sign.write().(使用sign.update()或sign.write()对传递的所有数据计算签名。)The privateKey argument can be an object or a string. If privateKey is a string, it is treated as a raw key with no passphrase. If privateKey is an object, it must contain one or more of the following properties:(privateKey参数可以是一个对象或字符串。如果privateKey是一个字符串，它将被视为没有密码短语的原始密钥。如果privateKey是一个对象，它必须包含以下一个或多个属性) key: - PEM encoded private key (required) passphrase: - passphrase for the private key padding: - Optional padding value for RSA, one of the following: crypto.constants.RSA_PKCS1_PADDING (default) crypto.constants.RSA_PKCS1_PSS_PADDINGNote that RSA_PKCS1_PSS_PADDING will use MGF1 with the same hash function used to sign the message as specified in section 3.1 of RFC 4055. saltLength: - salt length for when padding is RSA_PKCS1_PSS_PADDING. The special value crypto.constants.RSA_PSS_SALTLEN_DIGEST sets the salt length to the digest size, crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN (default) sets it to the maximum permissible value.The outputFormat can specify one of ‘latin1’, ‘hex’ or ‘base64’. If outputFormat is provided a string is returned; otherwise a Buffer is returned.(outputFormat可以指定’latin1’， ‘hex’或’base64’中的一个。如果提供了outputFormat，则返回一个字符串;否则返回Buffer。)The Sign object can not be again used after sign.sign() method has been called. Multiple calls to sign.sign() will result in an error being thrown.(Sign对象在调用Sign . Sign()方法后不能再次使用。多次调用sign.sign()将导致抛出错误。) sign.update(data[, inputEncoding]) data | | | inputEncoding Updates the Sign content with the given data, the encoding of which is given in inputEncoding and can be ‘utf8’, ‘ascii’ or ‘latin1’. If encoding is not provided, and the data is a string, an encoding of ‘utf8’ is enforced. If data is a Buffer, TypedArray, or DataView, then inputEncoding is ignored.This can be called many times with new data as it is streamed.(用给定的数据更新Sign内容，其编码在inputEncoding中给出，可以是’utf8’， ‘ascii’或’latin1’。如果没有提供编码，并且数据是字符串，则强制使用’utf8’编码。如果data是Buffer、TypedArray或DataView，则inputEncoding将被忽略。在流化新数据时，可以多次调用这个函数。) Class: VerifyVerify类是验证签名的工具。它可以两种方式使用: 作为可写的stream，使用书面数据来验证提供的签名 使用verify.update()和verify.verify()的方法来验证签名。crypto.createVerify()方法用于创建Verify实例。 Verify对象不能直接使用new关键字创建。123456789101112131415161718// 使用“验证”对象作为流:const crypto = require(&#x27;crypto&#x27;);const verify = crypto.createVerify(&#x27;SHA256&#x27;);verify.write(&#x27;some data to sign&#x27;);verify.end();const publicKey = getPublicKeySomehow();const signature = getSignatureToVerify();console.log(verify.verify(publicKey, signature));// Prints: true or false// 使用verify.update()和verify.verify()方法const crypto = require(&#x27;crypto&#x27;);const verify = crypto.createVerify(&#x27;SHA256&#x27;);verify.update(&#x27;some data to sign&#x27;);const publicKey = getPublicKeySomehow();const signature = getSignatureToVerify();console.log(verify.verify(publicKey, signature));// Prints: true or false verify.update(data[, inputEncoding]) data | | | inputEncoding Updates the Verify content with the given data, the encoding of which is given in inputEncoding and can be ‘utf8’, ‘ascii’ or ‘latin1’. If encoding is not provided, and the data is a string, an encoding of ‘utf8’ is enforced. If data is a Buffer, TypedArray, or DataView, then inputEncoding is ignored.This can be called many times with new data as it is streamed.(用给定的数据更新Verify内容，其编码在inputEncoding中给出，可以是’utf8’， ‘ascii’或’latin1’。如果没有提供编码，并且数据是字符串，则强制使用’utf8’编码。如果data是Buffer、TypedArray或DataView，则inputEncoding将被忽略。在流化新数据时，可以多次调用这个函数。) verify.verify(object, signature[, signatureFormat]) object | signature | | | signatureFormat Verifies the provided data using the given object and signature. The object argument can be either a string containing a PEM encoded object, which can be an RSA public key, a DSA public key, or an X.509 certificate, or an object with one or more of the following properties:(使用给定对象和签名验证提供的数据。object参数可以是一个包含PEM编码对象的字符串，该对象可以是RSA公钥、DSA公钥或X.509证书，也可以是具有以下一个或多个属性的对象:) key: - PEM encoded public key (required) padding: - Optional padding value for RSA, one of the following: crypto.constants.RSA_PKCS1_PADDING (default) crypto.constants.RSA_PKCS1_PSS_PADDINGNote that RSA_PKCS1_PSS_PADDING will use MGF1 with the same hash function used to verify the message as specified in section 3.1 of RFC 4055. saltLength: - salt length for when padding is RSA_PKCS1_PSS_PADDING. The special value crypto.constants.RSA_PSS_SALTLEN_DIGEST sets the salt length to the digest size, crypto.constants.RSA_PSS_SALTLEN_AUTO (default) causes it to be determined automatically.The signature argument is the previously calculated signature for the data, in the signatureFormat which can be ‘latin1’, ‘hex’ or ‘base64’. If a signatureFormat is specified, the signature is expected to be a string; otherwise signature is expected to be a Buffer, TypedArray, or DataView.(signature参数是之前为数据计算的签名，signatureFormat可以是’latin1’， ‘hex’或’base64’。如果指定了signatureFormat，则期望签名是一个字符串;否则签名应该是Buffer、TypedArray或DataView。)Returns true or false depending on the validity of the signature for the data and public key.(根据数据和公钥的签名的有效性返回true或false。)The verify object can not be used again after verify.verify() has been called. Multiple calls to verify.verify() will result in an error being thrown.(在调用verify.verify()之后，验证对象不能再次使用。多次调用verify.verify()将导致抛出错误。) crypto module methods and propertiescrypto.constantsReturns an object containing commonly used constants for crypto and security related operations. The specific constants currently defined are described in Crypto Constants.(返回一个对象，其中包含用于加密和安全相关操作的常用常量。当前定义的特定常数在Crypto constants中描述。) crypto.DEFAULT_ENCODINGThe default encoding to use for functions that can take either strings or buffers. The default value is ‘buffer’, which makes methods default to Buffer objects.The crypto.DEFAULT_ENCODING mechanism is provided for backwards compatibility with legacy programs that expect ‘latin1’ to be the default encoding.New applications should expect the default to be ‘buffer’. This property may become deprecated in a future Node.js release.(可接受字符串或缓冲区的函数所使用的默认编码。默认值是’buffer’，它使方法默认为buffer对象。加密。提供DEFAULT_ENCODING机制是为了向后兼容那些期望’latin1’为默认编码的遗留程序。新应用程序应该期望默认值为’buffer’。这个属性在未来的Node.js版本中可能会被弃用。) crypto.fipsProperty for checking and controlling whether a FIPS compliant crypto provider is currently in use. Setting to true requires a FIPS build of Node.js.(属性，用于检查和控制当前是否正在使用符合FIPS的加密提供程序。设置为true需要Node.js的FIPS版本。) crypto.createCipher(algorithm, password[, options]) algorithm password | | | options stream.transform optionsCreates and returns a Cipher object that uses the given algorithm and password. Optional options argument controls stream behavior.(创建并返回使用给定算法和密码的Cipher对象。参数可选options控制流行为。)The algorithm is dependent on OpenSSL, examples are ‘aes192’, etc. On recent OpenSSL releases, openssl list-cipher-algorithms will display the available cipher algorithms.(该算法依赖于OpenSSL，例如’aes192’等。在最新的OpenSSL版本中，OpenSSL list-cipher-algorithms将显示可用的密码算法。)The password is used to derive the cipher key and initialization vector (IV). The value must be either a ‘latin1’ encoded string, a Buffer, a TypedArray, or a DataView.(密码用于导出密码密钥和初始化向量(IV)。该值必须是’latin1’编码的字符串、Buffer、TypedArray或DataView。)The implementation of crypto.createCipher() derives keys using the OpenSSL function EVP_BytesToKey with the digest algorithm set to MD5, one iteration, and no salt. The lack of salt allows dictionary attacks as the same password always creates the same key. The low iteration count and non-cryptographically secure hash algorithm allow passwords to be tested very rapidly.(crypto.createCipher()的实现使用OpenSSL函数evp_bytickey派生密钥，并将摘要算法设置为MD5，一次迭代，无盐。盐的缺乏使得字典攻击成为可能，因为相同的密码总是创建相同的密钥。低迭代次数和非加密安全的哈希算法允许非常快速地测试密码。)In line with OpenSSL’s recommendation to use PBKDF2 instead of EVP_BytesToKey it is recommended that developers derive a key and IV on their own using crypto.pbkdf2() and to use crypto.createCipheriv() to create the Cipher object. Users should not use ciphers with counter mode (e.g. CTR, GCM, or CCM) in crypto.createCipher(). A warning is emitted when they are used in order to avoid the risk of IV reuse that causes vulnerabilities. For the case when IV is reused in GCM, see Nonce-Disrespecting Adversaries for details.(根据OpenSSL的建议，使用PBKDF2而不是EVP_BytesToKey，建议开发人员使用crypto.pbkdf2()自己派生密钥和IV，并使用crypto.createCipheriv()创建Cipher对象。用户不应该在cipher . createcipher()中使用带有计数器模式的密码(例如CTR、GCM或CCM)。在使用它们时发出警告，以避免IV重用导致漏洞的风险。对于在GCM中重用IV的情况，请参阅nonce - disrespect Adversaries了解详细信息。) 所谓加Salt方法，就是加点“佐料”（Salt这个单词就是盐的意思）。其基本想法是这样的：当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。 crypto.createCipheriv(algorithm, key, iv[, options]) algorithm key | | | iv | | | options stream.transform optionsCreates and returns a Cipher object, with the given algorithm, key and initialization vector (iv). Optional options argument controls stream behavior.(使用给定的算法、密钥和初始化向量(iv)创建并返回Cipher对象。可选options参数控制流行为。)The algorithm is dependent on OpenSSL, examples are ‘aes192’, etc. On recent OpenSSL releases, openssl list-cipher-algorithms will display the available cipher algorithms.(该算法依赖于OpenSSL，例如’aes192’等。在最新的OpenSSL版本中，OpenSSL list-cipher-algorithms将显示可用的密码算法。)The key is the raw key used by the algorithm and iv is an initialization vector. Both arguments must be ‘utf8’ encoded strings, Buffers, TypedArray, or DataViews.(key是算法使用的原始键，iv是初始化向量。两个参数都必须是’utf8’编码的字符串、Buffers、TypedArray或DataViews。) crypto.createDecipher(algorithm, password[, options]) algorithm password | | | options stream.transform optionsCreates and returns a Decipher object that uses the given algorithm and password (key). Optional options argument controls stream behavior.(创建并返回使用给定算法和密码(密钥)的Decipher对象。参数可选options控制流行为。)The implementation of crypto.createDecipher() derives keys using the OpenSSL function EVP_BytesToKey with the digest algorithm set to MD5, one iteration, and no salt. The lack of salt allows dictionary attacks as the same password always creates the same key. The low iteration count and non-cryptographically secure hash algorithm allow passwords to be tested very rapidly.(crypto.createDecipher()的实现使用OpenSSL函数EVP_BytesToKey派生密钥，并将摘要算法设置为MD5，一次迭代，无盐。盐的缺乏使得字典攻击成为可能，因为相同的密码总是创建相同的密钥。低迭代次数和非加密安全的哈希算法允许非常快速地测试密码。)In line with OpenSSL’s recommendation to use PBKDF2 instead of EVP_BytesToKey it is recommended that developers derive a key and IV on their own using crypto.pbkdf2() and to use crypto.createDecipheriv() to create the Decipher object.(根据OpenSSL的建议，使用PBKDF2而不是EVP_BytesToKey，建议开发人员使用crypto.pbkdf2()自己派生密钥和IV，并使用crypto.createDecipheriv()来创建Decipher对象。) crypto.createDecipheriv(algorithm, key, iv[, options]) algorithm key | | | iv | | | options stream.transform options crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding]) prime | | | primeEncoding generator | | | | Defaults to 2. generatorEncoding crypto.createDiffieHellman(primeLength[, generator]) primeLength generator | | | | Defaults to 2. crypto.createECDH(curveName) curveName Use crypto.getCurves() to obtain a list of available curve names. On recent OpenSSL releases, openssl ecparam -list_curves will also display the name and description of each available elliptic curve. crypto.createHash(algorithm[, options]) algorithm options stream.transform optionsOn recent releases of OpenSSL, openssl list-message-digest-algorithms will display the available digest algorithms. crypto.createHmac(algorithm, key[, options]) algorithm key | | | options stream.transform optionsOn recent releases of OpenSSL, openssl list-message-digest-algorithms will display the available digest algorithms.The key is the HMAC key used to generate the cryptographic HMAC hash. crypto.createSign(algorithm[, options]) algorithm options stream.Writable optionsCreates and returns a Sign object that uses the given algorithm. Use crypto.getHashes() to obtain an array of names of the available signing algorithms. Optional options argument controls the stream.Writable behavior. crypto.createVerify(algorithm[, options]) algorithm options stream.Writable optionsCreates and returns a Verify object that uses the given algorithm. Use crypto.getHashes() to obtain an array of names of the available signing algorithms. Optional options argument controls the stream.Writable behavior. crypto.getCiphers()Returns an array with the names of the supported cipher algorithms. crypto.getCurves()Returns an array with the names of the supported elliptic curves. crypto.getDiffieHellman(groupName) groupName Creates a predefined DiffieHellman key exchange object. The supported groups are: ‘modp1’, ‘modp2’, ‘modp5’ (defined in RFC 2412, but see Caveats) and ‘modp14’, ‘modp15’, ‘modp16’, ‘modp17’, ‘modp18’ (defined in RFC 3526). crypto.getHashes()Returns an array of the names of the supported hash algorithms, such as RSA-SHA256. crypto.pbkdf2(password, salt, iterations, keylen, digest, callback) password salt iterations keylen digest callback err derivedKey The iterations argument must be a number set as high as possible. The higher the number of iterations, the more secure the derived key will be, but will take a longer amount of time to complete.The salt should also be as unique as possible. It is recommended that the salts are random and their lengths are at least 16 bytes. See NIST SP 800-132 for details. crypto.pbkdf2Sync(password, salt, iterations, keylen, digest) password salt iterations keylen digest 同crypto.pbkdf2 crypto.privateDecrypt(privateKey, buffer) privateKey | key A PEM encoded private key. passphrase An optional passphrase for the private key. padding &lt;crypto.constants&gt; An optional padding value defined in crypto.constants, which may be: crypto.constants.RSA_NO_PADDING, RSA_PKCS1_PADDING, or crypto.constants.RSA_PKCS1_OAEP_PADDING. buffer | | Returns: A new Buffer with the decrypted content.privateKey can be an object or a string. If privateKey is a string, it is treated as the key with no passphrase and will use RSA_PKCS1_OAEP_PADDING. crypto.privateEncrypt(privateKey, buffer) privateKey | key A PEM encoded private key. passphrase An optional passphrase for the private key. padding &lt;crypto.constants&gt; An optional padding value defined in crypto.constants, which may be: crypto.constants.RSA_NO_PADDING or RSA_PKCS1_PADDING. buffer | | Returns: A new Buffer with the encrypted content.privateKey can be an object or a string. If privateKey is a string, it is treated as the key with no passphrase and will use RSA_PKCS1_PADDING. crypto.publicDecrypt(key, buffer) key | key A PEM encoded public or private key. passphrase An optional passphrase for the private key. padding &lt;crypto.constants&gt; An optional padding value defined in crypto.constants, which may be: crypto.constants.RSA_NO_PADDING or RSA_PKCS1_PADDING. buffer | | Returns: A new Buffer with the decrypted content.key can be an object or a string. If key is a string, it is treated as the key with no passphrase and will use RSA_PKCS1_PADDING.Because RSA public keys can be derived from private keys, a private key may be passed instead of a public key.(因为RSA公钥可以从私钥派生，所以传递的是私钥而不是公钥。) crypto.publicEncrypt(key, buffer) key | key A PEM encoded public or private key. passphrase An optional passphrase for the private key. padding &lt;crypto.constants&gt; An optional padding value defined in crypto.constants, which may be: crypto.constants.RSA_NO_PADDING, RSA_PKCS1_PADDING, or crypto.constants.RSA_PKCS1_OAEP_PADDING. buffer | | Returns: A new Buffer with the encrypted content. crypto.randomBytes(size[, callback]) size callback err buf 生成加密强伪随机数据. size参数是指示要生成的字节数的数值。如果提供 callback回调函数 ,这些字节是异步生成的并且使用两个参数调用callback函数：err和buf。12345const crypto = require(&#x27;crypto&#x27;);crypto.randomBytes(256, (err, buf) =&gt; &#123; if (err) throw err; console.log(`$&#123;buf.length&#125; bytes of random data: $&#123;buf.toString(&#x27;hex&#x27;)&#125;`);&#125;); 如果未提供 callback回调函数, 则同步地生成随机字节并返回为Buffer。1234// Synchronousconst buf = crypto.randomBytes(256);console.log( `$&#123;buf.length&#125; bytes of random data: $&#123;buf.toString(&#x27;hex&#x27;)&#125;`); crypto.randomFillSync(buffer[, offset][, size]) buffer | Must be supplied. offset Defaults to 0. size Defaults to buffer.length - offset.123456789const buf = Buffer.alloc(10);console.log(crypto.randomFillSync(buf).toString(&#x27;hex&#x27;));crypto.randomFillSync(buf, 5);console.log(buf.toString(&#x27;hex&#x27;));// The above is equivalent to the following:crypto.randomFillSync(buf, 5, 5);console.log(buf.toString(&#x27;hex&#x27;)); crypto.randomFill(buffer[, offset][, size], callback) buffer | 必须被支持. offset Defaults to 0. size Defaults to buffer.length - offset. callback function(err, buf) {}.If the callback function is not provided, an error will be thrown.12345678910111213141516const buf = Buffer.alloc(10);crypto.randomFill(buf, (err, buf) =&gt; &#123; if (err) throw err; console.log(buf.toString(&#x27;hex&#x27;));&#125;);crypto.randomFill(buf, 5, (err, buf) =&gt; &#123; if (err) throw err; console.log(buf.toString(&#x27;hex&#x27;));&#125;);// The above is equivalent to the following:crypto.randomFill(buf, 5, 5, (err, buf) =&gt; &#123; if (err) throw err; console.log(buf.toString(&#x27;hex&#x27;));&#125;); crypto.setEngine(engine[, flags]) engine flags &lt;crypto.constants&gt; Defaults to crypto.constants.ENGINE_METHOD_ALL.Load and set the engine for some or all OpenSSL functions (selected by flags).The flags is a bit field taking one of or a mix of the following flags (defined in crypto.constants): crypto.constants.ENGINE_METHOD_RSA crypto.constants.ENGINE_METHOD_DSA crypto.constants.ENGINE_METHOD_DH crypto.constants.ENGINE_METHOD_RAND crypto.constants.ENGINE_METHOD_ECDH crypto.constants.ENGINE_METHOD_ECDSA crypto.constants.ENGINE_METHOD_CIPHERS crypto.constants.ENGINE_METHOD_DIGESTS crypto.constants.ENGINE_METHOD_STORE crypto.constants.ENGINE_METHOD_PKEY_METHS crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS crypto.constants.ENGINE_METHOD_ALL crypto.constants.ENGINE_METHOD_NONE crypto.timingSafeEqual(a, b) a | | b | | This function is based on a constant-time algorithm. Returns true if a is equal to b, without leaking timing information that would allow an attacker to guess one of the values. This is suitable for comparing HMAC digests or secret values like authentication cookies or capability urls(该函数基于常数时间算法。如果a等于b，则返回true，而不会泄露时间信息，使攻击者能够猜测其中一个值。这适用于比较HMAC摘要或机密值，如身份验证cookie或功能url)a and b must both be Buffers, TypedArrays, or DataViews, and they must have the same length."},{"title":"nodejs基础知识(8)","date":"2023-01-10T05:13:23.000Z","updated":"2023-07-24T09:24:46.498Z","comments":true,"path":"nodejs/nodejs-note-15.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-15.html","excerpt":"","text":"启用–experimental-modules 标志可用于启用加载ES模块的功能。一旦被设置启用，以 .mjs 为后缀的文件将能够作为ES模块加载。 1node --experimental-modules my-app.mjs Error(错误)Node.js 中运行的应用程序一般会遇到以下四类错误： 标准的 JavaScript 错误： : 当调用 eval() 失败时抛出。 : 当 JavaScript 语法错误时抛出。 : 当值不在预期范围内时抛出。 : 当使用未定义的变量时抛出。 : 当传入错误类型的参数时抛出。 : 当全局的 URI 处理函数被误用时抛出。 由底层操作系触发的系统错误，例如试图打开一个不存在的文件、试图通过一个已关闭的 socket 发送数据等。 由应用程序代码触发的用户自定义的错误。 断言错误是错误的一个特殊类别，每当 Node.js 检测到一个不应该发生的异常逻辑时触发。 这类错误通常由 assert 模块引起。所有由 Node.js 引起的 JavaScript 错误与系统错误都继承自或实例化自标准的 JavaScript 类，且保证至少提供类中的属性。 错误的冒泡和捕获Node.js 支持几种当应用程序运行时发生的错误的冒泡和处理的机制。 如何报告和处理这些错误完全取决于错误的类型和被调用的 API 的风格。所有 JavaScript 错误都会被作为异常处理，异常会立即产生并使用标准的 JavaScript throw 机制抛出一个错误。 这些都是使用 JavaScript 语言提供的 try / catch 语句处理的。 1234567// 抛出一个 ReferenceError，因为 z 为 undefinedtry &#123; const m = 1; const n = m + z;&#125; catch (err) &#123; // 在这里处理错误。&#125; JavaScript 的 throw 机制的任何使用都会引起异常，异常必须使用 try / catch 处理，否则 Node.js 进程会立即退出。除了少数例外，同步的 API（任何不接受 callback 函数的阻塞方法，例如 [fs.readFileSync]）会使用 throw 报告错误。异步的 API 中发生的错误可能会以多种方式进行报告: 大多数的异步方法都接受一个 callback 函数，该函数会接受一个 Error 对象传入作为第一个参数。 如果第一个参数不是 null 而是一个 Error 实例，则说明发生了错误，应该进行处理。123456789const fs = require(&#x27;fs&#x27;); fs.readFile(&#x27;一个不存在的文件&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.error(&#x27;读取文件出错！&#x27;, err); return; &#125; // 否则处理数据 &#125;); 当一个异步方法被一个 EventEmitter 对象调用时，错误会被分发到对象的 ‘error’ 事件上。12345678910const net = require(&#x27;net&#x27;);const connection = net.connect(&#x27;localhost&#x27;);// 添加一个 &#x27;error&#x27; 事件句柄到一个流：connection.on(&#x27;error&#x27;, (err) =&gt; &#123; // 如果连接被服务器重置，或无法连接，或发生任何错误，则错误会被发送到这里。 console.error(err);&#125;);connection.pipe(process.stdout); Node.js API 中有一小部分普通的异步方法仍可能使用 throw 机制抛出异常，且必须使用 try / catch 处理。对于所有的 EventEmitter 对象，如果没有提供一个 ‘error’ 事件句柄，则错误会被抛出，并造成 Node.js 进程报告一个未处理的异常且随即崩溃，除非： 适当地使用 domain 模块或已经注册了一个 [process.on(‘uncaughtException’)] 事件的句柄。1234567891011121314// THIS WILL NOT WORK:const fs = require(&#x27;fs&#x27;);try &#123; fs.readFile(&#x27;/some/file/that/does-not-exist&#x27;, (err, data) =&gt; &#123; // mistaken assumption: throwing here... if (err) &#123; throw err; &#125; &#125;);&#125; catch (err) &#123; // This will not catch the throw! console.error(err);&#125; Error 类一个通用的 JavaScript Error 对象，它不表示错误发生的具体情况。 Error 对象会捕捉一个“堆栈跟踪”，详细说明被实例化的 Error 对象在代码中的位置，并可能提供错误的文字描述。只对于加密，如果在抛出错误时可以使用 Error 对象，则会将OpenSSL错误堆栈放入到名为 opensslErrorStack 的单独属性中。所有由 Node.js 产生的错误，包括所有系统的和 JavaScript 的错误都实例化自或继承自 Error 类。 new Error(message)message 新建一个 Error 实例，并设置 error.message 属性以提供文本信息。 如果 message 传的是一个对象，则会调用 message.toString() 生成文本信息。 error.stack 属性表示被调用的 new Error() 在代码中的位置。 堆栈跟踪是基于 V8 的堆栈跟踪 API 的。 堆栈跟踪只会取（a）异步代码执行的开头或（b）Error.stackTraceLimit 属性给出的栈帧中的最小项。 Error.captureStackTrace(targetObject[, constructorOpt]) targetObject constructorOpt 在 targetObject 上创建一个 .stack 属性，当访问时返回一个表示代码中调用 Error.captureStackTrace() 的位置的字符串。123const myObject = &#123;&#125;;Error.captureStackTrace(myObject);myObject.stack; // 类似 `new Error().stack` 可选的 constructorOpt 参数接受一个函数。 如果提供了，则 constructorOpt 之上包括自身在内的全部栈帧都会被生成的堆栈跟踪省略。constructorOpt 参数用在向最终用户隐藏错误生成的具体细节时非常有用。1234567function MyError() &#123; Error.captureStackTrace(this, MyError);&#125;// 没传入 MyError 到 captureStackTrace，MyError 帧会显示在 .stack 属性。// 通过传入构造函数，可以省略该帧，且保留其下面的所有帧。new MyError().stack; Error.stackTraceLimitError.stackTraceLimit 属性指定了堆栈跟踪收集的栈帧数量（无论是 new Error().stack 或 Error.captureStackTrace(obj) 产生的）。默认值为 10 ，但可设为任何有效的 JavaScript 数值。 值改变后的变化会影响所有捕获到的堆栈跟踪。如果设为一个非数值或负数，则堆栈跟踪不会捕捉任何栈帧。 error.codeerror.code 属性是标识错误类别的字符标签。 error.messageerror.message 属性是错误的字符串描述，通过调用 new Error(message) 设置。 传给构造函数的 message 也会出现在 Error 的堆栈跟踪的第一行。 但是，Error 对象创建后改变这个属性可能不会改变堆栈跟踪的第一行（比如当 error.stack 在该属性被改变之前被读取）。 error.stackerror.stack 属性是一个字符串，描述代码中 Error 被实例化的位置。第一行会被格式化为 : ，且带上一系列栈帧（每一行都以 “at “ 开头）。 每一帧描述了一个代码中导致错误生成的调用点。 V8 引擎会试图显示每个函数的名称（变量名、函数名、或对象的方法名），但偶尔也可能找不到一个合适的名称。 如果 V8 引擎没法确定一个函数的名称，则只显示帧的位置信息。 否则，在位置信息的旁边会显示明确的函数名。帧只由 JavaScript 函数产生。 例如，同步地执行一个名为 cheetahify 的 C++ 插件，且插件自身调用一个 JavaScript 函数，代表 cheetahify 回调的栈帧不会出现在堆栈跟踪里 123456789Error at new MyError (C:\\Users\\xxx\\Desktop\\learning\\xxxxxxx\\source\\nodejs\\file\\test.js:516:9) at Object.&lt;anonymous&gt; (C:\\Users\\xxx\\Desktop\\learning\\xxxxxxx\\source\\nodejs\\file\\test.js:519:13) at Module._compile (node:internal/modules/cjs/loader:1159:14) at Module._extensions..js (node:internal/modules/cjs/loader:1213:10) at Module.load (node:internal/modules/cjs/loader:1037:32) at Module._load (node:internal/modules/cjs/loader:878:12) at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12) at node:internal/main/run_main_module:23:47 位置信息会是其中之一： native，帧表示一个 V8 引擎内部的调用（比如，[].forEach）。 plain-filename.js:line:column，帧表示一个 Node.js 内部的调用。 /absolute/path/to/file.js:line:column，帧表示一个用户程序或其依赖的调用。代表堆栈跟踪的字符串是在 error.stack 属性被访问时才生成的。堆栈跟踪捕获的帧的数量是由 Error.stackTraceLimit 或当前事件循环中可用的帧数量的最小值界定的。系统级的错误是由扩展的 Error 实例产生的 Class: AssertionErrorError 的子类，表示断言失败。 这种错误通常表示实际值和预期值不相等。比如: 12assert.strictEqual(1, 2);// AssertionError [ERR_ASSERTION]: 1 === 2 RangeError 类Error 的一个子类，表明一个函数的一个给定的参数的值不在可接受的集合或范围内； 无论是一个数字范围还是给定函数参数的选项的集合。例子： 12require(&#x27;net&#x27;).connect(-1);// 抛出 &quot;RangeError: &quot;port&quot; option should be &gt;= 0 and &lt; 65536: -1&quot; Node.js 会生成并以参数校验的形式立即抛出 RangeError 实例。 ReferenceError 类Error 的一个子类，表明试图访问一个未定义的变量。 这些错误通常表明代码有拼写错误或程序已损坏。虽然客户端代码可能产生和传播这些错误，但在实践中，只有 V8 引擎会这么做。 12doesNotExist;// 抛出 ReferenceError，在这个程序中 doesNotExist 不是一个变量。 除非应用程序是动态生成并运行的代码，否则 ReferenceError 实例应该始终被视为代码中或其依赖中的错误。 SyntaxError 类Error 的一个子类，表明程序不是有效的 JavaScript 代码。 这些错误是代码执行的结果产生和传播的。 代码执行可能产生自 eval、Function、require 或 [vm]。 这些错误几乎都表明程序已损坏。 12345try &#123; require(&#x27;vm&#x27;).runInThisContext(&#x27;binary ! isNotOk&#x27;);&#125; catch (err) &#123; // err 是一个 SyntaxError&#125; SyntaxError 实例在创建它们的上下文中是不可恢复的。 它们只可被其他上下文捕获。 TypeError 类Error 的一个子类，表明提供的参数不是一个被允许的类型。 例如，将一个函数传给一个期望字符串的参数会被视为一个 TypeError。 12require(&#x27;url&#x27;).parse(() =&gt; &#123; &#125;);// 抛出 TypeError，因为它期望的是一个字符串 Node.js 会生成并以参数校验的形式立即抛出 TypeError 实例。 系统错误类error.codeerror.code 属性是一个表示错误码的字符串，总是 E 带上一串大写字母。 error.errno | error.errno 属性是一个数值或字符串。 如果返回一个数值，则数值是一个负数，对应 libuv 错误处理 中定义的错误码。 详见 uv-errno.h 头文件（Node.js 源代码中的 deps/uv/include/uv-errno.h）。 如果返回一个字符串，则同 error.code。 error.syscallerror.syscall 属性是一个字符串，描述失败的 系统调用。 error.path错误出现时 (比如 在 fs 或 child_process), error.path属性是一个字符串，包含了相关不可用路径名。 error.address错误出现时 (比如 在 net 或 dgram), error.address 属性是对链接失败的地址的描述。 error.port错误出现时 (比如 在 net 或 dgram), error.port是一个链接端口不可用的端口值 常见的系统错误详细列表地址 EACCES (拒绝访问): 试图以被一个文件的访问权限禁止的方式访问一个文件。 EADDRINUSE (地址已被使用): 试图绑定一个服务器（[net]、[http] 或 [https]）到本地地址，但因另一个本地系统的服务器已占用了该地址而导致失败。 ECONNREFUSED (连接被拒绝): 无法连接，因为目标机器积极拒绝。 这通常是因为试图连接到外部主机上的废弃的服务。 ECONNRESET (连接被重置): 一个连接被强行关闭。 这通常是因为连接到远程 socket 超时或重启。 常发生于 [http] 和 [net] 模块。 EEXIST (文件已存在): 一个操作的目标文件已存在，而要求目标不存在。 EISDIR (是一个目录): 一个操作要求一个文件，但给定的路径是一个目录。 EMFILE (系统打开了太多文件): 已达到系统文件描述符允许的最大数量，且描述符的请求不能被满足直到至少关闭其中一个。 当一次并行打开多个文件时会发生这个错误，尤其是在进程的文件描述限制数量较低的操作系统（如 macOS）。 要解决这个限制，可在运行 Node.js 进程的同一 shell 中运行 ulimit -n 2048。 ENOENT (无此文件或目录): 通常是由 [fs] 操作引起的，表明指定的路径不存在，即给定的路径找不到文件或目录。 ENOTDIR (不是一个目录): 给定的路径虽然存在，但不是一个目录。 通常是由 [fs.readdir] 引起的。 ENOTEMPTY (目录非空): 一个操作的目标是一个非空的目录，而要求的是一个空目录。 通常是由 [fs.unlink] 引起的。 EPERM (操作不被允许): 试图执行一个需要更高权限的操作。 EPIPE (管道损坏): 写入一个管道、socket 或 FIFO 时没有进程读取数据。 常见于 [net] 和 [http] 层，表明远端要写入的流已被关闭。 ETIMEDOUT (操作超时): 一个连接或发送的请求失败，因为连接方在一段时间后没有做出合适的响应。 常见于 [http] 或 [net]。 往往标志着 socket.end() 没有被正确地调用。 Node.js Error Codes ERR_ARG_NOT_ITERABLE需要可遍历的参数（也就是可使用 for…of 遍历的值）。 ERR_ASYNC_CALLBACK试图注册不是 AsyncHooks 回调的函数。 ERR_ASYNC_TYPE异步资源的类型不合法。 如果使用公共嵌入的 API，则用户可以定义自己的类型。 ERR_ENCODING_INVALID_ENCODED_DATA提供给 util.TextDecoder() API 的数据不符合指定的编码。 ERR_ENCODING_NOT_SUPPORTED提供给 util.TextDecoder() API 的字符编码不是WHATWG支持的字符编码。 ERR_FALSY_VALUE_REJECTION通过util.callbackify()调用的Promise被拒绝，值是假的。 ERR_HTTP_HEADERS_SENT当消息头已发送后，还试图添加消息头。 ERR_HTTP_INVALID_CHARHTTP 响应的状态信息中存在非法字符。 ERR_HTTP_INVALID_STATUS_CODE状态码超出正常范围（100-999）。 ERR_HTTP_TRAILER_INVALID即使传输编码不支持，也设置了Trailer头。 ERR_HTTP2_CONNECT_AUTHORITY对于使用CONNECT方法的HTTP/2请求，:authority伪报头是必需的。 ERR_HTTP2_CONNECT_PATH通过CONNECT方法发送的HTTP/2请求时，:path 伪header 被禁用 ERR_HTTP2_CONNECT_SCHEME通过CONNECT方法发送HTTP/2请求时，:scheme伪header 被禁用。 ERR_HTTP2_FRAME_ERROR通过 HTTP/2 会话发送单个数据帧失败。 ERR_HTTP2_HEADER_REQUIREDHTTP/2 消息缺少必需的消息头。 ERR_HTTP2_HEADER_SINGLE_VALUE为只需一个值的 HTTP/2 消息头提供了多个值。 ERR_HTTP2_HEADERS_AFTER_RESPOND在发起HTTP/2响应后指定了额外的报头。 ERR_HTTP2_HEADERS_OBJECT需要一个HTTP/2 Headers对象 ERR_HTTP2_HEADERS_SENT尝试发送多个响应标头。 ERR_HTTP2_INFO_HEADERS_AFTER_RESPONDHTTP/2信息头必须只在调用http2stream.prototype.response()方法之前发送。 ERR_HTTP2_INFO_STATUS_NOT_ALLOWED信息性HTTP状态码(1xx)不能设置为HTTP/2响应上的响应状态码。 events(事件)所有能触发事件的对象都是 EventEmitter 类的实例。 这些对象开放了一个 eventEmitter.on() 函数，允许将一个或多个函数绑定到会被对象触发的命名事件上。 事件名称通常是驼峰式的字符串，但也可以使用任何有效的 JavaScript 属性名。当 EventEmitter 对象触发一个事件时，所有绑定在该事件上的函数都被同步地调用。 监听器的返回值会被丢弃。 123456789const EventEmitter = require(&#x27;events&#x27;);class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter();myEmitter.on(&#x27;event&#x27;, () =&gt; &#123; console.log(&#x27;触发了一个事件！&#x27;);&#125;);myEmitter.emit(&#x27;event&#x27;); 给监听器传入参数与 this eventEmitter.emit() 方法允许将任意参数传给监听器函数。 当一个普通的监听器函数被 EventEmitter 调用时，标准的 this 关键词会被设置指向监听器所附加的 EventEmitter。 也可以使用 ES6 的箭头函数作为监听器。但是这样 this 关键词就不再指向 EventEmitter 实例12345678910111213141516171819const myEmitter = new MyEmitter();myEmitter.on(&#x27;event&#x27;, function(a, b) &#123; console.log(a, b, this); // 打印: // a b MyEmitter &#123; // domain: null, // _events: &#123; event: [Function] &#125;, // _eventsCount: 1, // _maxListeners: undefined &#125;&#125;);myEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;);// 箭头函数const myEmitter = new MyEmitter();myEmitter.on(&#x27;event&#x27;, (a, b) =&gt; &#123; console.log(a, b, this); // 打印: a b &#123;&#125;&#125;);myEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;); 异步与同步EventEmitter 会按照监听器注册的顺序同步地调用所有监听器。 所以需要确保事件的正确排序且避免竞争条件或逻辑错误。 监听器函数可以使用 setImmediate() 或 process.nextTick() 方法切换到异步操作模式： 1234567const myEmitter = new MyEmitter();myEmitter.on(&#x27;event&#x27;, (a, b) =&gt; &#123; setImmediate(() =&gt; &#123; console.log(&#x27;这个是异步发生的&#x27;); &#125;);&#125;);myEmitter.emit(&#x27;event&#x27;, &#x27;a&#x27;, &#x27;b&#x27;); 只处理事件一次当使用 eventEmitter.on() 方法注册监听器时，监听器会在每次触发命名事件时被调用。使用 eventEmitter.once() 方法时可以注册一个对于特定事件最多被调用一次的监听器。 当事件被触发时，监听器会被注销，然后再调用。 1234567891011121314151617181920const myEmitter = new MyEmitter();let m = 0;myEmitter.on(&#x27;event&#x27;, () =&gt; &#123; console.log(++m);&#125;);myEmitter.emit(&#x27;event&#x27;);// 打印: 1myEmitter.emit(&#x27;event&#x27;);// 打印: 2// onceconst myEmitter = new MyEmitter();let m = 0;myEmitter.once(&#x27;event&#x27;, () =&gt; &#123; console.log(++m);&#125;);myEmitter.emit(&#x27;event&#x27;);// 打印: 1myEmitter.emit(&#x27;event&#x27;);// 忽略 错误事件当 EventEmitter 实例中发生错误时，会触发一个 ‘error’ 事件。 这在 Node.js 中是特殊情况。如果 EventEmitter 没有为 ‘error’ 事件注册至少一个监听器，则当 ‘error’ 事件触发时，会抛出错误、打印堆栈跟踪、且退出 Node.js 进程。为了防止 Node.js 进程崩溃，可以在使用 domain 模块。 （注意，domain 模块已被废弃。）作为最佳实践，应该始终为 ‘error’ 事件注册监听器。 1234567891011const myEmitter = new MyEmitter();myEmitter.emit(&#x27;error&#x27;, new Error(&#x27;whoops!&#x27;));// 抛出错误，并使 Node.js 崩溃const myEmitter = new MyEmitter();myEmitter.on(&#x27;error&#x27;, (err) =&gt; &#123; console.error(&#x27;有错误&#x27;);&#125;);myEmitter.emit(&#x27;error&#x27;, new Error(&#x27;whoops!&#x27;));// 打印: 有错误 EventEmitter 类当新的监听器被添加时，所有的 EventEmitter 会触发 ‘newListener’ 事件；当移除已存在的监听器时，则触发 ‘removeListener’。 ‘newListener’ 事件 eventName 要监听的事件的名称 listener 事件的句柄函数EventEmitter 实例会在一个监听器被添加到其内部监听器数组之前触发自身的 ‘newListener’ 事件。注册了 ‘newListener’ 事件的监听器会传入事件名与被添加的监听器的引用。事实上，在添加监听器之前触发事件有一个微妙但重要的副作用： 在’newListener’ 回调函数中, 一个监听器的名字如果和已有监听器名称相同, 则在被插入到EventEmitter实例的内部监听器数组时, 该监听器会被添加到其它同名监听器的前面。1234567891011121314151617const myEmitter = new MyEmitter();// 只处理一次，所以不会无限循环myEmitter.once(&#x27;newListener&#x27;, (event, listener) =&gt; &#123; if (event === &#x27;event&#x27;) &#123; // 在开头插入一个新的监听器 myEmitter.on(&#x27;event&#x27;, () =&gt; &#123; console.log(&#x27;B&#x27;); &#125;); &#125;&#125;);myEmitter.on(&#x27;event&#x27;, () =&gt; &#123; console.log(&#x27;A&#x27;);&#125;);myEmitter.emit(&#x27;event&#x27;);// 打印:// B// A ‘removeListener’ 事件 eventName 事件名 listener 事件句柄函数‘removeListener’ 事件在 listener 被移除后触发。 EventEmitter.defaultMaxListeners每个事件默认可以注册最多 10 个监听器。 单个 EventEmitter 实例的限制可以使用 emitter.setMaxListeners(n) 方法改变。 所有 EventEmitter 实例的默认值可以使用 EventEmitter.defaultMaxListeners 属性改变。 如果这个值不是正数, 那将抛出 TypeError错误.设置 EventEmitter.defaultMaxListeners 要谨慎，因为会影响所有 EventEmitter 实例，包括之前创建的。 因而，调用 emitter.setMaxListeners(n) 优先于 EventEmitter.defaultMaxListeners。注意，这不是一个硬性限制。 EventEmitter 实例允许添加更多的监听器，但会向 stderr 输出跟踪警告，表明检测到一个可能的 EventEmitter 内存泄漏。 对于任何单个 EventEmitter 实例，emitter.getMaxListeners() 和 emitter.setMaxListeners() 方法可用于暂时地消除此警告： 12345emitter.setMaxListeners(emitter.getMaxListeners() + 1);emitter.once(&#x27;event&#x27;, () =&gt; &#123; // 做些操作 emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));&#125;); –trace-warnings 命令行标志可用于显示此类警告的堆栈跟踪。触发的警告可以使用 process.on(‘warning’) 检查，还有额外的 emitter、type 和 count 属性，分别代表事件触发器实例的引用、事件的名称、和附加的监听器的数量。其 name 属性设置为 MaxListenersExceededWarning。 emitter.addListener(eventName, listener) eventName listener emitter.on(eventName, listener) 的别名。 emitter.emit(eventName[, …args]) eventName …args 按监听器的注册顺序，同步地调用每个注册到名为 eventName 事件的监听器，并传入提供的参数。如果事件有监听器，则返回 true ，否则返回 false。 emitter.eventNames()返回一个列出触发器已注册监听器的事件的数组。 数组中的值为字符串或符号。 12345678910const EventEmitter = require(&#x27;events&#x27;);const myEE = new EventEmitter();myEE.on(&#x27;foo&#x27;, () =&gt; &#123;&#125;);myEE.on(&#x27;bar&#x27;, () =&gt; &#123;&#125;);const sym = Symbol(&#x27;symbol&#x27;);myEE.on(sym, () =&gt; &#123;&#125;);console.log(myEE.eventNames());// 打印: [ &#x27;foo&#x27;, &#x27;bar&#x27;, Symbol(symbol) ] emitter.getMaxListeners()返回 EventEmitter 当前的最大监听器限制值，该值可以通过 emitter.setMaxListeners(n) 设置或默认为 EventEmitter.defaultMaxListeners。 emitter.listenerCount(eventName) eventName 正在被监听的事件名返回正在监听名为 eventName 的事件的监听器的数量。 emitter.listeners(eventName) eventName 返回名为 eventName 的事件的监听器数组的副本。12345server.on(&#x27;connection&#x27;, (stream) =&gt; &#123; console.log(&#x27;someone connected!&#x27;);&#125;);console.log(util.inspect(server.listeners(&#x27;connection&#x27;)));// 打印: [ [Function] ] emitter.on(eventName, listener) eventName 事件名 listener 回调函数添加 listener 函数到名为 eventName 的事件的监听器数组的末尾。 不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次。返回一个 EventEmitter 引用，可以链式调用。默认情况下，事件监听器会按照添加的顺序依次调用。 emitter.prependListener() 方法可用于将事件监听器添加到监听器数组的开头。1234567const myEE = new EventEmitter();myEE.on(&#x27;foo&#x27;, () =&gt; console.log(&#x27;a&#x27;));myEE.prependListener(&#x27;foo&#x27;, () =&gt; console.log(&#x27;b&#x27;));myEE.emit(&#x27;foo&#x27;);// 打印:// b// a emitter.once(eventName, listener) eventName 事件名 listener 回调函数添加一个单次 listener 函数到名为 eventName 的事件。 下次触发 eventName 事件时，监听器会被移除，然后调用。返回一个 EventEmitter 引用，可以链式调用。默认情况下，事件监听器会按照添加的顺序依次调用。 emitter.prependOnceListener() 方法可用于将事件监听器添加到监听器数组的开头。12345678const myEE = new EventEmitter();myEE.once(&#x27;foo&#x27;, () =&gt; console.log(&#x27;a&#x27;));myEE.prependOnceListener(&#x27;foo&#x27;, () =&gt; console.log(&#x27;b&#x27;));myEE.emit(&#x27;foo&#x27;);myEE.emit(&#x27;foo&#x27;);// 打印:// b// a emitter.prependListener(eventName, listener) eventName 事件名 listener 回调函数添加 listener 函数到名为 eventName 的事件的监听器数组的开头。 不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次。返回一个 EventEmitter 引用，可以链式调用。 emitter.prependOnceListener(eventName, listener) eventName 事件名 listener 回调函数添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头。 下次触发 eventName 事件时，监听器会被移除，然后调用。返回一个 EventEmitter 引用，可以链式调用。 emitter.removeAllListeners([eventName]) eventName 移除全部或指定 eventName 的监听器。 注意，在代码中移除其他地方添加的监听器是一个不好的做法，尤其是当 EventEmitter 实例是其他组件或模块（如 socket 或文件流）创建的。返回一个 EventEmitter 引用，可以链式调用。 emitter.removeListener(eventName, listener) eventName listener 从名为 eventName 的事件的监听器数组中移除指定的 listener。 removeListener 最多只会从监听器数组里移除一个监听器实例。 如果任何单一的监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener 才能移除每个实例。注意，一旦一个事件被触发，所有绑定到它的监听器都会按顺序依次触发。 这意味着，在事件触发后、最后一个监听器完成执行前，任何 removeListener() 或 removeAllListeners() 调用都不会从 emit() 中移除它们。 随后的事件会像预期的那样发生。 123456789101112131415161718192021222324252627const myEmitter = new MyEmitter();const callbackA = () =&gt; &#123; console.log(&#x27;A&#x27;); myEmitter.removeListener(&#x27;event&#x27;, callbackB);&#125;;const callbackB = () =&gt; &#123; console.log(&#x27;B&#x27;);&#125;;myEmitter.on(&#x27;event&#x27;, callbackA);myEmitter.on(&#x27;event&#x27;, callbackB);// callbackA 移除了监听器 callbackB，但它依然会被调用。// 触发是内部的监听器数组为 [callbackA, callbackB]myEmitter.emit(&#x27;event&#x27;);// 打印:// A// B// callbackB 被移除了。// 内部监听器数组为 [callbackA]myEmitter.emit(&#x27;event&#x27;);// 打印:// A 因为监听器是使用内部数组进行管理的，所以调用它会改变在监听器被移除后注册的任何监听器的位置索引。 虽然这不会影响监听器的调用顺序，但意味着由 emitter.listeners() 方法返回的监听器数组副本需要被重新创建。返回一个 EventEmitter 引用，可以链式调用。 emitter.setMaxListeners(n) n 默认情况下，如果为特定事件添加了超过 10 个监听器，则 EventEmitter 会打印一个警告。 此限制有助于寻找内存泄露。 但是，并不是所有的事件都要被限为 10 个。 emitter.setMaxListeners() 方法允许修改指定的 EventEmitter 实例的限制。 值设为 Infinity（或 0）表明不限制监听器的数量。返回一个 EventEmitter 引用，可以链式调用。"},{"title":"nodejs基础知识(9)","date":"2023-01-10T05:13:23.000Z","updated":"2023-07-24T09:24:46.499Z","comments":true,"path":"nodejs/nodejs-note-16.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-16.html","excerpt":"","text":"fs (文件系统)通过 require(‘fs’) 使用该模块。所有的方法都有异步和同步的形式。 异步方法的最后一个参数都是一个回调函数。 传给回调函数的参数取决于具体方法，但回调函数的第一个参数都会保留给异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。 使用同步方法，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。12345678910111213// 异步方法const fs = require(&#x27;fs&#x27;);fs.unlink(&#x27;/tmp/hello&#x27;, (err) =&gt; &#123; if (err) throw err; console.log(&#x27;成功删除 /tmp/hello&#x27;);&#125;);// 同步方法const fs = require(&#x27;fs&#x27;);fs.unlinkSync(&#x27;/tmp/hello&#x27;);console.log(&#x27;成功删除 /tmp/hello&#x27;); 注意：异步方法的执行先后顺序不能保证，正确的做法是使用回调函数进行关联 在繁忙的进程中，建议使用异步的方法。 同步的方法会阻塞整个进程，直到完成（停止所有连接）。可以使用文件名的相对路径。 路径是相对 process.cwd() 的。 注意: 在 Windows 上，使用 w 选项(通过 fs.open 或 fs.writeFile) 打开已有隐藏文件将会失败，错误信息为 EPERM 。已有隐藏文件可以通过 r+ 选项打开。调用 fs.ftruncate 可以用来重置文件内容。 WHATWG对于大多数 fs 模块的函数， path 或者 filename 参数可以当作一个 WHATWG URL 对象传入。 只有 URL 对象使用被支持的 file: 协议。 1234const fs = require(&#x27;fs&#x27;);const &#123; URL &#125; = require(&#x27;url&#x27;);const fileUrl = new URL(&#x27;file:///tmp/hello&#x27;);fs.readFileSync(fileUrl); 注意： file: URLS 必须是绝对路径。 在 Windows 上， 携带主机名的 file: URLs 被转换为 UNC 路径 有硬盘盘符的 file: URLs 会被转换成 本地绝对路径。 既没有主机名，也没有盘符的 file: URLs 在转换时会抛出错误。 注意： 携带盘符的 file: URLs 必须使用 : 作为盘符后的分隔符。使用其他符号会抛出错误。 在其他所有的平台上， 都不支持携带主机名的 file: URLs，且会抛出错误。 当 file: URL 包含已经编码的斜线符号会在所有平台抛出错误。 在 Windows 上， 携带已编码的反斜线 file: URLs 在编码时会抛出错误。 fs.FSWatcher 类从 fs.watch() 返回的对象是该类型。提供给 fs.watch() 的 listener 回调会接收返回的 FSWatcher 的 change 事件。该对象本身可触发以下事件： ‘change’ 事件eventType fs 变化的类型filename | 变化的文件名（如果是相关的/可用的）当一个被监视的目录或文件有变化时触发。 详见 fs.watch()。filename 参数可能不会被提供，这依赖于操作系统支持。 如果提供了 filename，则若 fs.watch() 被调用时 encoding 选项被设置为 ‘buffer’ 则它会是一个 Buffer，否则 filename 是一个字符串。 1234567// 例子，处理 fs.watch 监听器fs.watch(&#x27;./tmp&#x27;, &#123; encoding: &#x27;buffer&#x27; &#125;, (eventType, filename) =&gt; &#123; if (filename) &#123; console.log(filename); // 输出: &lt;Buffer ...&gt; &#125;&#125;); ‘error’ 事件error 当发生错误时触发。 watcher.close()停止监听 fs.FSWatcher 的变化。 fs.ReadStream 类ReadStream 是一个可读流。 ‘close’ 事件当 ReadStream 底层的文件描述符被关闭时触发。 ‘open’ 事件fd 被 ReadStream 使用的整数文件描述符。当 ReadStream 的文件被打开时触发。 readStream.bytesRead已读取的字节数。 readStream.path流正在读取的文件的路径，指定在 fs.createReadStream() 的第一个参数。 如果 path 传入的是一个字符串，则 readStream.path 是一个字符串。 如果 path 传入的是一个 Buffer，则 readStream.path 是一个 Buffer。 fs.Stats 类从 fs.stat()、fs.lstat() 和 fs.fstat() 及其同步版本返回的对象都是该类型。 stats.isFile() stats.isDirectory() stats.isBlockDevice() stats.isCharacterDevice() stats.isSymbolicLink() (仅对 fs.lstat() 有效) stats.isFIFO() stats.isSocket()对于一个普通文件，util.inspect(stats) 会返回一个类似如下的字符串：12345678910111213141516171819Stats &#123; dev: 2114, ino: 48064969, mode: 33188, nlink: 1, uid: 85, gid: 100, rdev: 0, size: 527, blksize: 4096, blocks: 8, atimeMs: 1318289051000.1, mtimeMs: 1318289051000.1, ctimeMs: 1318289051000.1, birthtimeMs: 1318289051000.1, atime: Mon, 10 Oct 2011 23:24:11 GMT, mtime: Mon, 10 Oct 2011 23:24:11 GMT, ctime: Mon, 10 Oct 2011 23:24:11 GMT, birthtime: Mon, 10 Oct 2011 23:24:11 GMT &#125; Stat 时间值stat 对象中的时间有以下语义： atime “访问时间” - 文件数据最近被访问的时间。 会被 mknod(2)、 utimes(2) 和 read(2) 系统调用改变。 mtime “修改时间” - 文件数据最近被修改的时间。 会被 mknod(2)、 utimes(2) 和 write(2) 系统调用改变。 ctime “变化时间” - 文件状态最近更改的时间（修改索引节点数据） 会被 chmod(2)、 chown(2)、 link(2)、 mknod(2)、 rename(2)、 unlink(2)、 utimes(2)、 read(2) 和 write(2) 系统调用改变。 birthtime “创建时间” - 文件创建的时间。 当文件被创建时设定一次。 在创建时间不可用的文件系统中，该字段可能被替代为 ctime 或 1970-01-01T00:00Z（如 Unix 的纪元时间戳 0）。 注意，该值在此情况下可能会大于 atime 或 mtime。 在 Darwin 和其它的 FreeBSD 衍生系统中，如果 atime 被使用 utimes(2) 系统调用显式地设置为一个比当前 birthtime 更早的值，也会有这种情况。 fs.WriteStream 类WriteStream 一个可写流。 ‘close’ 事件当 WriteStream 底层的文件描述符被关闭时触发。 ‘open’ 事件fd 被 WriteStream 使用的整数文件描述符。当 WriteStream 的文件被打开时触发。 writeStream.bytesWritten已写入的字节数。 不包括仍在排队等待写入的数据。 writeStream.path流正在写入的文件的路径，指定在 fs.createWriteStream() 的第一个参数。 如果 path 传入的是一个字符串，则 writeStream.path 是一个字符串。 如果 path 传入的是一个 Buffer，则 writeStream.path 是一个 Buffer。 fs.access(path[, mode], callback) path | | mode Default: fs.constants.F_OK callback err 测试 path 指定的文件或目录的用户权限。 mode 是一个可选的整数，指定要执行的可访问性检查。 以下常量定义了 mode 的可能值。 可以创建由两个或更多个值的位或组成的掩码（例如 fs.constants.W_OK | fs.constants.R_OK）。 fs.constants.F_OK - path 文件对调用进程可见。 这在确定文件是否存在时很有用，但不涉及 rwx 权限。 如果没指定 mode，则默认为该值。 fs.constants.R_OK - path 文件可被调用进程读取。 fs.constants.W_OK - path 文件可被调用进程写入。 fs.constants.X_OK - path 文件可被调用进程执行。 对 Windows 系统没作用（相当于 fs.constants.F_OK）。最后一个参数 callback 是一个回调函数，会带有一个可能的错误参数被调用。 如果可访问性检查有任何的失败，则错误参数会是一个 Error 对象。 下面的例子会检查 /etc/passwd 文件是否可以被当前进程读取和写入。123fs.access(&#x27;/etc/passwd&#x27;, fs.constants.R_OK | fs.constants.W_OK, (err) =&gt; &#123; console.log(err ? &#x27;no access!&#x27; : &#x27;can read/write&#x27;);&#125;); 不建议在调用 fs.open() 、 fs.readFile() 或 fs.writeFile() 之前使用 fs.access() 检查一个文件的可访问性。 如此处理会造成紊乱情况，因为其他进程可能在两个调用之间改变该文件的状态。 作为替代，用户代码应该直接打开/读取/写入文件，当文件无法访问时再处理错误。 12345678910fs.open(&#x27;myfile&#x27;, &#x27;r&#x27;, (err, fd) =&gt; &#123; if (err) &#123; if (err.code === &#x27;ENOENT&#x27;) &#123; console.error(&#x27;myfile does not exist&#x27;); return; &#125; throw err; &#125; readMyData(fd);&#125;); 通常，仅在文件不会被直接使用时才检查一个文件的可访问性，例如当它的可访问性是来自另一个进程的信号。 fs.accessSync(path[, mode])参数说明同上如果可访问性检查有任何的失败，则错误参数会是一个 Error 对象。 否则返回 undefined。 123456try &#123; fs.accessSync(&#x27;etc/passwd&#x27;, fs.constants.R_OK | fs.constants.W_OK); console.log(&#x27;can read/write&#x27;);&#125; catch (err) &#123; console.error(&#x27;no access!&#x27;);&#125; fs.appendFile(file, data[, options], callback) file | | | 文件名或文件描述符 data | options | encoding | 默认为 ‘utf8’ mode 默认为 0o666 flag 默认为 ‘a’ callback err 异步地追加数据到一个文件，如果文件不存在则创建文件。 data 可以是一个字符串或 Buffer。如果 options 是一个字符串，则它指定了字符编码。1234fs.appendFile(&#x27;message.txt&#x27;, &#x27;data to append&#x27;, &#x27;utf8&#x27;, (err) =&gt; &#123; if (err) throw err; console.log(&#x27;The &quot;data to append&quot; was appended to file!&#x27;);&#125;); file 可能是一个被打开用来追加数据的数字文件描述符（通过 fs.open() 或者 fs.openSync()）。这样的文件描述符将不会被自动关闭。123456789fs.open(&#x27;message.txt&#x27;, &#x27;a&#x27;, (err, fd) =&gt; &#123; if (err) throw err; fs.appendFile(fd, &#x27;data to append&#x27;, &#x27;utf8&#x27;, (err) =&gt; &#123; fs.close(fd, (err) =&gt; &#123; if (err) throw err; &#125;); if (err) throw err; &#125;);&#125;); fs.appendFileSync(file, data[, options])参数说明同上 1234567891011121314151617try &#123; fs.appendFileSync(&#x27;message.txt&#x27;, &#x27;data to append&#x27;, &#x27;utf8&#x27;); console.log(&#x27;The &quot;data to append&quot; was appended to file!&#x27;);&#125; catch (err) &#123; /* Handle the error */&#125;let fd;try &#123; fd = fs.openSync(&#x27;message.txt&#x27;, &#x27;a&#x27;); fs.appendFileSync(fd, &#x27;data to append&#x27;, &#x27;utf8&#x27;);&#125; catch (err) &#123; /* Handle the error */&#125; finally &#123; if (fd !== undefined) fs.closeSync(fd);&#125; fs.chmod(path, mode, callback) path | | mode callback err 异步地改变文件的权限。 完成回调只有一个可能的异常参数。 File modesmode 参数会在 fs.chmod() 和 fs.chmodSync()方法中用到，它是用下面的常量进行逻辑或(logical OR)操作后的数字掩码：一个构造 mode 的更简单的方式是使用3位八进制串（比如，765）。最左侧的数字（例中的7）代表了文件所有者的权限。中间一位（例中的6）代表了组的权限。最右侧的数字（例中的5）代表其他人的权限。例如，八进制值 0o765 表示： 文件所有者可以进行读、写和执行。 文件所属组可以读和写。 其他人可以对文件进行读和执行。 fs.chmodSync(path, mode)同步地改变文件的权限。 返回 undefined。 fs.chmod()的同步版本。 fs.chown(path, uid, gid, callback) path | | uid gid callback err 异步地改变文件的所有者和群组。 完成回调只有一个可能的异常参数。 fs.chownSync(path, uid, gid)同步地改变文件的所有者和群组。 返回 undefined。 fs.chown() 的同步版本。 fs.close(fd, callback)fd callback err 异步的 close(2)。 完成回调只有一个可能的异常参数。 fs.closeSync(fd)同步的 close(2)。返回 undefined。 fs.constants返回一个包含常用文件系统操作的常量的对象。 具体的常量定义在 FS Constants 中描述。 fs.copyFile(src, dest[, flags], callback) src | | 要被拷贝的源文件名称 dest | | 拷贝操作的目标文件名 flags 拷贝操作修饰符 默认: 0 callback 异步的将 src 拷贝到 dest。Asynchronously copies src to dest. 默认情况下，如果 dest 已经存在会被覆盖。回调函数没有给出除了异常以外的参数。Node.js 不能保证拷贝操作的原子性。如果目标文件打开后出现错误，Node.js 将尝试删除它。flags 是一个可选的整数，用于指定行为的拷贝操作。唯一支持的 flag 是 fs.constants.COPYFILE_EXCL ，如果 dest 已经存在，则会导致拷贝操作失败。1234567891011121314const fs = require(&#x27;fs&#x27;);// 默认情况下，destination.txt 将创建或覆盖fs.copyFile(&#x27;source.txt&#x27;, &#x27;destination.txt&#x27;, (err) =&gt; &#123; if (err) throw err; console.log(&#x27;source.txt was copied to destination.txt&#x27;);&#125;);// 如果第三个参数是数字，那么肯定是 flags，代码如下const fs = require(&#x27;fs&#x27;);const &#123; COPYFILE_EXCL &#125; = fs.constants;// 使用 COPYFILE_EXCL ，如果 destination.txt 文件存在，操作将失败。fs.copyFile(&#x27;source.txt&#x27;, &#x27;destination.txt&#x27;, COPYFILE_EXCL, callback); fs.copyFileSync(src, dest[, flags])参数说明同上 fs.createReadStream(path[, options]) path | | options | flags encoding fd mode autoClose start end highWaterMark 返回一个新建的 ReadStream 对象（详见可读流）。不同于在一个可读流上设置的 highWaterMark 默认值（16 kb），该方法在相同参数下返回的流具有 64 kb 的默认值。options 是一个带有以下默认值的对象或字符串：12345678const defaults = &#123; flags: &#x27;r&#x27;, encoding: null, fd: null, mode: 0o666, autoClose: true, highWaterMark: 64 * 1024&#125;; options 可以包括 start 和 end 值，使其可以从文件读取一定范围的字节而不是整个文件。 start 和 end 都是包括在内的，并且起始值是 0。 如果指定了 fd 且 start 不传或为 undefined，则 fs.createReadStream() 从当前文件位置按顺序地读取。 encoding 可以是任何可以被 Buffer 接受的值。 如果指定了 fd，则 ReadStream 会忽略 path 参数并且会使用指定的文件描述符。 这意味着不会触发 ‘open’ 事件。 注意，fd 应该是阻塞的；非阻塞的 fd 们应该传给 net.Socket。 如果 autoClose 为 false，则文件描述符不会被关闭，即使有错误。 应用程序需要负责关闭它，并且确保没有文件描述符泄漏。 如果 autoClose 被设置为 true（默认），则在 error 或 end 时，文件描述符会被自动关闭。 mode 用于设置文件模式（权限和粘结位），但仅限创建文件时。如果 options 是一个字符串，则它指定了字符编码。 fs.createWriteStream(path[, options]) path | | options | flags encoding fd mode autoClose start 返回一个新建的 WriteStream 对象（详见可写流）。options 是一个带有以下默认值的对象或字符串：1234567const defaults = &#123; flags: &#x27;w&#x27;, encoding: &#x27;utf8&#x27;, fd: null, mode: 0o666, autoClose: true&#125;; options 也可以包括一个 start 选项，使其可以写入数据到文件某个位置。 如果是修改一个文件而不是覆盖它，则需要flags 模式为 r+ 而不是默认的 w 模式。 fs.existsSync(path)path | | fs.exists() 的同步版本。 如果路径存在，则返回 true，否则返回 false。注意，虽然 fs.exists() 是废弃的，但 fs.existsSync() 不是。 （fs.exists() 的回调接收的参数与其他 Node.js 回调不一致，fs.existsSync() 不使用回调。） fs.fchmod(fd, mode, callback) fd mode callback err 更改文件权限（文件描述符）。异步的 fchmod(2)。 完成回调只有一个可能的异常参数。 fs.fchmodSync(fd, mode) fd mode 同步的 fchmod(2)。返回 undefined。 fs.fchown(fd, uid, gid, callback) fd uid gid callback err 更改给定文件描述符的所有者和组。异步的 fchown(2)。 完成回调只有一个可能的异常参数。 fs.fchownSync(fd, uid, gid) fd uid gid 同步的 fchown(2)。返回 undefined。 fs.fdatasync(fd, callback) fd callback err 文件数据同步。异步的 fdatasync(2)。 完成回调只有一个可能的异常参数。 fs.fdatasyncSync(fd) fd 同步的 fdatasync(2)。返回 undefined。 fs.mkdtemp(prefix[, options], callback)创建一个唯一的临时目录。生成六位随机字符附加到一个要求的 prefix 后面，然后创建一个唯一的临时目录。创建的目录路径会作为字符串传给回调的第二个参数。可选的 options 参数可以是一个字符串并指定一个字符编码，或是一个对象且由一个 encoding 属性指定使用的字符编码。注意：fs.mkdtemp() 方法会直接附加六位随机选择的字符串到 prefix 字符串。 例如，指定一个目录 /tmp，如果目的是要在 /tmp 里创建一个临时目录，则 prefix 必须 以一个指定平台的路径分隔符（require(‘path’).sep）结尾。 1234567const &#123; sep &#125; = require(&#x27;path&#x27;);fs.mkdtemp(`$&#123;tmpDir&#125;$&#123;sep&#125;`, (err, folder) =&gt; &#123; if (err) throw err; console.log(folder); // 会输出类似于 `/tmp/abc123`。 // 一个新的临时目录会被创建在 /tmp 目录里。&#125;); fs.watch(filename[, options][, listener])说明: fs.watch API 不是 100％ 跨平台一致的，且在某些情况下不可用。递归选项只支持 macOS 和 Windows。 可用性特性依赖于底层操作系统提供的一种方法来通知文件系统的变化。 在 Linux 系统中，使用 inotify。 在 BSD 系统中，使用 kqueue。 在 macOS 系统中，对文件使用 kqueue，对目录使用 FSEvents。 在 SunOS 系统（包括 Solaris 和 SmartOS）中，使用 event ports。 在 Windows 系统中，该特性依赖 ReadDirectoryChangesW。 在 Aix 系统中，该特性依赖 AHAFS 必须是启动的。 文件名参数回调中提供的 filename 参数仅在 Linux、macOS、Windows、以及 AIX 系统上支持。 即使在支持的平台中，filename 也不能保证提供。 因此，不要以为 filename 参数总是在回调中提供，如果它是空的，需要有一定的后备逻辑。 fs.watchFile(filename[, options], listener)注意：fs.watch() 比 fs.watchFile 和 fs.unwatchFile 更高效。 可能的话，应该使用 fs.watch 而不是 fs.watchFile 和 fs.unwatchFile。注意: 当 fs.watchFile() 所监听的文件消失并重新出现时，第二个回调函数中返回的 previousstat (文件重新出现)将与第一个回调函数的 previousstat (消失)相同。这种情况会发生在: 该文件被删除，然后又恢复 文件重命名两次，但第二次重命名与其原名称相同 fs.write(fd, buffer[, offset[, length[, position]]], callback)注意，多次对同一文件使用 fs.write 且不等待回调，是不安全的。 对于这种情况，强烈推荐使用 fs.createWriteStream。在 Linux 上，当文件以追加模式打开时，指定位置的写入是不起作用的。 内核会忽略位置参数，并总是将数据追加到文件的末尾。 fs.writeFile(file, data[, options], callback)注意，多次对同一文件使用 fs.writeFile 且不等待回调，是不安全的。 对于这种情况，强烈推荐使用 fs.createWriteStream。注意：如果 file 指定为一个文件描述符，则它不会被自动关闭。 fs 常量以下常量由 fs.constants 输出。注意：不是所有的常量在每一个操作系统上都是可用的。 文件访问常量：以下常量用于 fs.access()。 文件打开常量以下常量用于 fs.open()。 文件类型常量以下常量用于 fs.Stats 对象中用于决定一个文件的类型的 mode 属性。 文件模式常量以下常量用于 fs.Stats 对象中用于决定一个文件访问权限的 mode 属性。"},{"title":"nodejs基础知识(10)","date":"2023-01-18T01:58:35.000Z","updated":"2023-07-24T09:24:46.499Z","comments":true,"path":"nodejs/nodejs-note-18.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-18.html","excerpt":"","text":"Inspectorinspector.console 1require(&#x27;node:inspector&#x27;).console.log(&#x27;a message&#x27;); 检查器控制台与Node.js控制台没有API平等性。 inspector.url() Returns: | 返回活动检查器的URL，如果没有则未定义12345678910111213node --inspect -p &#x27;inspector.url()&#x27;Debugger listening on ws://127.0.0.1:9229/967be145-cb64-4ab0-8aa7-c4bc4aab37b9For help, see: https://nodejs.org/en/docs/inspectorws://127.0.0.1:9229/967be145-cb64-4ab0-8aa7-c4bc4aab37b9node --inspect=localhost:3000 -p &#x27;inspector.url()&#x27;Debugger listening on ws://localhost:3000/3bc267b0-4ecd-4106-a1ff-6d2d9fa6fe79Debugger listening on ws://localhost:3000/3bc267b0-4ecd-4106-a1ff-6d2d9fa6fe79For help, see: https://nodejs.org/en/docs/inspectorws://localhost:3000/3bc267b0-4ecd-4106-a1ff-6d2d9fa6fe79node -p &#x27;inspector.url()&#x27;undefined inspector.waitForDebugger()阻塞，直到客户端(现有的或以后连接的)发送Runtime.runIfWaitingForDebugger命令。如果没有活动检查器，则会引发异常。 Class: inspector.Session new inspector.Session()创建新的inspector.session实例。在将消息分派到检查器后端之前，需要通过session.connect()连接检查器会话。 Event: ‘inspectorNotification’ 信息对象v8检查器收到任务通知时执行123session.on(&#x27;inspectorNotification&#x27;, (message) =&gt; console.log(message.method));// Debugger.paused// Debugger.resumed Event: ; 信息对象当接收到方法字段设置为值的检查器通知时触发。 表示某个具体方法，如下添加Debugger.paused监听事件 1234session.on(&#x27;Debugger.paused&#x27;, (&#123; params &#125;) =&gt; &#123; console.log(params.hitBreakpoints);&#125;);// [ &#x27;/the/file/that/has/the/breakpoint.js:11:0&#x27; ] session.connectToMainThread()将会话连接到主线程检查器后端。如果没有在Worker线程上调用此API，则会抛出异常。 session.disconnect()立即关闭会话。所有挂起的消息回调都将被调用并报错。需要调用Session.connect()才能再次发送消息。重新连接的会话将丢失所有检查器状态，例如启用的代理或配置的断点。 session.post(method[, params][, callback]) method params callback 向检查器后端发布消息。 callback 将在接收到响应时收到通知。 callback 是接受两个可选参数（错误和特定于消息的结果）的函数。123session.post(&#x27;Runtime.evaluate&#x27;, &#123; expression: &#x27;2 + 2&#x27; &#125;, (error, &#123; result &#125;) =&gt; console.log(result));// 输出：&#123; type: &#x27;number&#x27;, value: 4, description: &#x27;4&#x27; &#125; CPU 分析器代码示例 123456789101112131415161718const inspector = require(&#x27;node:inspector&#x27;);const fs = require(&#x27;node:fs&#x27;);const session = new inspector.Session();session.connect();session.post(&#x27;Profiler.enable&#x27;, () =&gt; &#123; session.post(&#x27;Profiler.start&#x27;, () =&gt; &#123; // 在此处调用测量中的业务逻辑... // 一段时间之后... session.post(&#x27;Profiler.stop&#x27;, (err, &#123; profile &#125;) =&gt; &#123; // 将分析文件写入磁盘、上传等 if (!err) &#123; fs.writeFileSync(&#x27;./profile.cpuprofile&#x27;, JSON.stringify(profile)); &#125; &#125;); &#125;);&#125;); 堆分析器代码示例 1234567891011121314151617const inspector = require(&#x27;node:inspector&#x27;);const fs = require(&#x27;node:fs&#x27;);const session = new inspector.Session();const fd = fs.openSync(&#x27;profile.heapsnapshot&#x27;, &#x27;w&#x27;);session.connect();session.on(&#x27;HeapProfiler.addHeapSnapshotChunk&#x27;, (m) =&gt; &#123; fs.writeSync(fd, m.params.chunk);&#125;);session.post(&#x27;HeapProfiler.takeHeapSnapshot&#x27;, null, (err, r) =&gt; &#123; console.log(&#x27;HeapProfiler.takeHeapSnapshot done:&#x27;, err, r); session.disconnect(); fs.closeSync(fd);&#125;); Internationalization构建 Node.js 的选项为了控制在 Node.js 中如何使用 ICU，在编译期间提供了四个 configure 选项。 BUILDING.md 中记录了有关如何编译 Node.js 的其他详细信息。 –with-intl=none/–without-intl–with-intl=system-icu–with-intl=small-icu–with-intl=full-icu（默认）每个 configure 选项的可用 Node.js 和 JavaScript 特性概述：“(不识别区域设置)” 表示该函数执行其操作就像函数的非 Locale 版本一样，如果存在的话。 比如在 none 模式下，Date.prototype.toLocaleString() 的操作和 Date.prototype.toString() 是一样的。 禁用全部国际化特性（none）如果选择此选项，则 ICU 将被禁用，并且上述大多数国际化特性在生成的 node 二进制文件中将不可用。 使用预装的 ICU 构建（system-icu）Node.js 可以链接到系统上已安装的 ICU。 事实上，大多数 Linux 发行版已经安装了 ICU，这个选项可以复用操作系统中其他组件使用的相同数据集。system-icu 完全支持仅需要 ICU 库本身的功能，例如 String.prototype.normalize() 和 WHATWG 网址解析器。 另外需要 ICU 语言环境数据的特性，例如 Intl.DateTimeFormat 可能完全或部分支持，具体取决于系统上安装的 ICU 数据的完整性。 嵌入 ICU 数据的有界集（small-icu）此选项静态地生成针对 ICU 库的二进制链接，并在 node 可执行文件中包含 ICU 数据的子集（通常只有英文区域设置）。small-icu 完全支持仅需要 ICU 库本身的功能，例如 String.prototype.normalize() 和 WHATWG 网址解析器。 另外需要 ICU 语言环境数据的特性，比如 Intl.DateTimeFormat，一般只适用于英文语言环境： 12345678const january = new Date(9e8);const english = new Intl.DateTimeFormat(&#x27;en&#x27;, &#123; month: &#x27;long&#x27; &#125;);const spanish = new Intl.DateTimeFormat(&#x27;es&#x27;, &#123; month: &#x27;long&#x27; &#125;);console.log(english.format(january));// 打印 &quot;January&quot;console.log(spanish.format(january));// 在 small-icu 上打印 &quot;M01&quot; 或 &quot;January&quot;，具体取决于用户的默认语言环境// 应该打印 &quot;enero&quot; 此模式提供了特性和二进制大小之间的平衡。如果使用 small-icu 选项，则仍然可以在运行时提供额外的语言环境数据，以便 JS 方法适用于所有 ICU 语言环境。 假设数据文件存储在 /some/directory，它可以通过以下任一方式提供给 ICU： NODE_ICU_DATA 环境变量：env NODE_ICU_DATA=/some/directory node –icu-data-dir 命令行参数：node –icu-data-dir=/some/directory（如果两者都指定，则 –icu-data-dir 命令行参数优先。）ICU 能够自动查找和加载多种数据格式，但数据必须适合 ICU 版本，并且文件命名正确。 数据文件最常见的名称是 icudt6X[bl].dat，其中 6X 表示预期的 ICU 版本，而 b 或 l 表示系统的字节序。full-icu npm 模块通过检测运行中的 node 可执行文件的 ICU 版本并下载相应的数据文件，可以大大简化 ICU 数据安装。 通过 npm i full-icu 安装模块后，数据文件将在 ./node_modules/full-icu 可用。 然后可以将此路径传给 NODE_ICU_DATA 或 –icu-data-dir，如上所示以启用完整的 Intl 支持。 嵌入整个 ICU（full-icu）此选项使生成的二进制链接与 ICU 静态地关联并包含全套 ICU 数据。 以这种方式创建的二进制文件没有进一步的外部依赖项并支持所有语言环境，但可能相当大。 如果没有传入 –with-intl 标志，则这是默认行为。 官方的二进制文件也是以这种模式构建的。 检测国际化支持要验证是否启用了 ICU（system-icu、small-icu 或 full-icu），只需检查 Intl 是否存在就足够了： 1const hasICU = typeof Intl === &#x27;object&#x27;; 或者，检查 process.versions.icu，一个仅在启用 ICU 时定义的属性，也可以工作： 1const hasICU = typeof process.versions.icu === &#x27;string&#x27;; 要检查对非英语语言环境（即 full-icu 或 system-icu）的支持，Intl.DateTimeFormat 可能是一个很好的区分因素： 123456789const hasFullICU = (() =&gt; &#123; try &#123; const january = new Date(9e8); const spanish = new Intl.DateTimeFormat(&#x27;es&#x27;, &#123; month: &#x27;long&#x27; &#125;); return spanish.format(january) === &#x27;enero&#x27;; &#125; catch (err) &#123; return false; &#125;&#125;)(); 有关 Intl 支持的更详细的测试，以下资源可能会有所帮助： btest402: 一般用于检查是否正确地构建了支持 Intl 的 Node.js。 Test262: ECMAScript 的官方一致性测试套件包括一个专门针对 ECMA-402 的部分。 moduleModule 对象 module.builtinModules &lt;string[]&gt;Node.js 提供的所有模块的名称列表。 可用于验证模块是否由第三方维护。 module.createRequire(filename) filename | 用于构造 require 函数的文件名。 必须是文件网址对象、文件网址字符串、或绝对路径字符串。 返回: require 函数12345import &#123; createRequire &#125; from &#x27;node:module&#x27;;const require = createRequire(import.meta.url);// sibling-module.js 是 CommonJS 模块。const siblingModule = require(&#x27;./sibling-module&#x27;); module.isBuiltin(moduleName) moduleName 模块名称返回: 如果模块是内置的，则返回 true，否则返回 false module.syncBuiltinESMExports()module.syncBuiltinESMExports() 方法更新内置的 ES 模块的所有实时绑定，以匹配 CommonJS 导出的属性。 它不会在 ES 模块中添加或删除导出的名称。 1234567891011121314151617181920212223242526const fs = require(&#x27;node:fs&#x27;);const assert = require(&#x27;node:assert&#x27;);const &#123; syncBuiltinESMExports &#125; = require(&#x27;node:module&#x27;);fs.readFile = newAPI;delete fs.readFileSync;function newAPI() &#123; // ...&#125;fs.newAPI = newAPI;syncBuiltinESMExports();import(&#x27;node:fs&#x27;).then((esmFS) =&gt; &#123; // 它将现有的 readFile 属性与新值同步 assert.strictEqual(esmFS.readFile, newAPI); // readFileSync 已从所需的 fs 中删除 assert.strictEqual(&#x27;readFileSync&#x27; in fs, false); // syncBuiltinESMExports() 不会从 esmFS 中删除 readFileSync assert.strictEqual(&#x27;readFileSync&#x27; in esmFS, true); // syncBuiltinESMExports() 不添加名称 assert.strictEqual(esmFS.newAPI, undefined);&#125;); Source Map V3 的支持与源映射缓存交互的助手。 当启用源映射解析并且在模块的页脚中找到源映射包含指令时，则会填充此缓存。要启用源映射解析，则 Node.js 必须使用标志 –enable-source-maps 运行、或者通过设置 NODE_V8_COVERAGE=dir 启用代码覆盖率。 module.findSourceMap(path) path 返回: &lt;module.SourceMap&gt;path 是文件的解析路径，应为其获取相应的源映射。 module.SourceMap 类 new SourceMap(payload) payload 创建新的 sourceMap 实例。payload 是键匹配 Source map v3 格式的对象： file: version: sources: &lt;string[]&gt; sourcesContent: &lt;string[]&gt; names: &lt;string[]&gt; mappings: sourceRoot: sourceMap.payload 返回: 用于构造 SourceMap 实例的有效负载的获取器。 sourceMap.findEntry(lineNumber, columnNumber) lineNumber columnNumber 返回: 给定生成的源文件中的行号和列号，返回表示原始文件中位置的对象。 返回的对象包含以下键： generatedLine: generatedColumn: originalSource: originalLine: originalColumn: name:"},{"title":"nodejs基础知识(10)","date":"2023-01-13T05:24:11.000Z","updated":"2023-07-24T09:24:46.499Z","comments":true,"path":"nodejs/nodejs-note-17.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-17.html","excerpt":"","text":"HTTP要使用 HTTP 服务器与客户端，需要 require(‘http’)。Node.js 中的 HTTP 接口被设计成支持协议的许多特性。 比如，大块编码的消息。 这些接口不缓冲完整的请求或响应，用户能够以流的形式处理数据。HTTP 消息头由一个对象表示，例如： 12345&#123; &#x27;content-length&#x27;: &#x27;123&#x27;, &#x27;content-type&#x27;: &#x27;text/plain&#x27;, &#x27;connection&#x27;: &#x27;keep-alive&#x27;, &#x27;host&#x27;: &#x27;mysite.com&#x27;, &#x27;accept&#x27;: &#x27;*/*&#x27; &#125; 键名是小写的，键值不能修改。 http.Agent 类Agent 负责为 HTTP 客户端管理连接的持续与复用。 它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的 socket 连接直到队列为空，此时 socket 会被销毁或被放入一个连接池中，在连接池中等待被有着相同主机与端口的请求再次使用。 是否被销毁或被放入连接池取决于 keepAlive 选项。 http.ClientRequest 类该对象在 http.request() 内部被创建并返回。 它表示着一个正在处理的请求，其请求头已进入队列。 请求头仍可使用 setHeader(name, value)、getHeader(name) 和 removeHeader(name) API 进行修改。 实际的请求头会与第一个数据块一起发送或当调用 request.end() 时发送。 要获取响应，需为 ‘response’ 事件添加一个监听器到请求对象上。 当响应头被接收到时，’response’ 事件会从请求对象上被触发 。 ‘response’ 事件被执行时带有一个参数，该参数是一个 http.IncomingMessage 实例。 在 ‘response’ 事件期间，可以添加监听器到响应对象上，比如监听 ‘data’ 事件。 如果没有添加 ‘response’ 事件处理函数，则响应会被整个丢弃。 如果添加了 ‘response’ 事件处理函数，则必须消耗完响应对象的数据，可通过调用 response.read()、或添加一个 ‘data’ 事件处理函数、或调用 .resume() 方法。 数据被消耗完时会触发 ‘end’ 事件。 在数据被读取完之前会消耗内存，可能会造成 ‘process out of memory’ 错误。 注意：Node.js 不会检查 Content-Length 与已传输的请求主体的长度是否相等。 request.socket &lt;net.Socket&gt;引用底层socket。 通常用户不想访问此属性。 特别地，由于协议解析器连接到socket的方式，socket将不会触发’readable’事件。 在response.end()之后，该属性为null。 也可以通过request.connection来访问socket。123456789101112const http = require(&#x27;http&#x27;);const options = &#123; host: &#x27;nodejs.cn&#x27;,&#125;;const req = http.get(options);req.end();req.once(&#x27;response&#x27;, (res) =&gt; &#123; const ip = req.socket.localAddress; const port = req.socket.localPort; console.log(`你的IP地址是 $&#123;ip&#125;，你的源端口是 $&#123;port&#125;。`); // 你的IP地址是 192.168.22.168，你的源端口是 62687。&#125;); http.Server 类该类继承自 net.Server，且具有一些额外的事件： ‘checkContinue’ 事件 request &lt;http.IncomingMessage&gt; response &lt;http.ServerResponse&gt;每当接收到一个带有 HTTP Expect: 100-continue 请求头的请求时触发。 如果该事件未被监听，则服务器会自动响应 100 Continue。处理该事件时，如果客户端应该继续发送请求主体，则调用 response.writeContinue()，否则生成一个适当的 HTTP 响应（例如 400 错误请求）。 注意，当该事件被触发且处理后，’request’ 事件不会被触发。 ‘clientError’ 事件 exception socket &lt;net.Socket&gt;如果客户端触发了一个 ‘error’ 事件，则它会被传递到这里。 该事件的监听器负责关闭或销毁底层的 socket。默认情况下，请求异常时会立即销毁 socket。socket 参数是发生错误的 net.Socket 对象。123456789const http = require(&#x27;http&#x27;);const server = http.createServer((req, res) =&gt; &#123; res.end();&#125;);server.on(&#x27;clientError&#x27;, (err, socket) =&gt; &#123; socket.end(&#x27;HTTP/1.1 400 Bad Request\\r\\n\\r\\n&#x27;);&#125;);server.listen(8000); 当 ‘clientError’ 事件发生时，不会有 request 或 response 对象，所以发送的任何 HTTP 响应，包括响应头和内容，必须被直接写入到 socket 对象。 注意，确保响应是一个被正确格式化的 HTTP 响应消息。 ‘connect’ 事件 request &lt;http.IncomingMessage&gt; HTTP 请求，同 ‘request’ 事件。 socket &lt;net.Socket&gt; 服务器与客户端之间的网络 socket。 head 流的第一个数据包，可能为空。每当客户端发送 HTTP CONNECT 请求时触发。 如果该事件未被监听，则发送 CONNECT 请求的客户端会关闭连接。当该事件被触发后，请求的 socket 上没有 ‘data’ 事件监听器，这意味着需要绑定 ‘data’ 事件监听器，用来处理 socket 上被发送到服务器的数据。 ‘upgrade’ 事件 request &lt;http.IncomingMessage&gt; HTTP 请求，同 ‘request’ 事件。 socket &lt;net.Socket&gt; 服务器与客户端之间的网络 socket。 head 流的第一个数据包，可能为空。每当客户端发送 HTTP upgrade 请求时触发。 如果该事件未被监听，则发送 upgrade 请求的客户端会关闭连接。当该事件被触发后，请求的 socket 上没有 ‘data’ 事件监听器，这意味着需要绑定 ‘data’ 事件监听器，用来处理 socket 上被发送到服务器的数据。 server.maxHeadersCount 默认为 2000。限制请求头的最大数量，默认为 2000。 如果设为 0，则没有限制。 server.setTimeout([msecs][, callback]) msecs 默认为 120000 (2 分钟)。 callback 设置 socket 的超时时间。 如果发生超时，则触发服务器对象的 ‘timeout’ 事件，并传入 socket 作为一个参数。 默认情况下，服务器的超时时间是 2 分钟，且超时后的 socket 会被自动销毁。 但是，如果你为服务器的 ‘timeout’ 事件分配了一个回调函数，则超时必须被显式地处理。返回 server。 server.timeout 超时时间，以毫秒为单位。默认为 120000 (2 分钟)。socket 被认定为超时的空闲毫秒数。 值设为 0 可禁用请求连接的超时行为。注意，socket 的超时逻辑是在连接上设定的，所以改变这个值只影响服务器新建的连接，而不会影响任何已存在的连接。 server.keepAliveTimeout 超时毫秒. 默认为 5000 (5秒).服务器完成最后的响应之后需要等待的额外的传入数据的活跃毫秒数, socket 才能被销毁.如果服务器在 keep-alive 计时已激活时接收到新的数据, 他会重置常规的非活动计时, 即server.timeout.值为 0 时禁用传入连接 keep-alive 的超时行为。 注意: scoket 的超时逻辑上取决于服务器连接, 所以改变这个值只影响服务器的新连接, 不影响任何已存在的连接. http.ServerResponse 类该对象在 HTTP 服务器内部被创建。 它作为第二个参数被传入 ‘request’ 事件。这个类实现了（而不是继承自）可写流 接口。 ‘finish’ 事件当响应已被发送时触发。 更具体地说，当响应头和响应主体的最后一部分已被交给操作系统通过网络进行传输时，触发该事件。 这并不意味着客户端已接收到任何东西。该事件触发后，响应对象上不再触发其他事件。 response.addTrailers(headers) headers 该方法会添加 HTTP 尾部响应头（一种在消息尾部的响应头）到响应。 仅当响应使用分块编码时，尾部响应头才会被发送；否则（比如请求为 HTTP/1.0），尾部响应头会被丢弃。注意，发送尾部响应头之前，需先发送 Trailer 响应头，并在值里带上尾部响应头字段的列表。 1234response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27;,&#x27;Trailer&#x27;: &#x27;Content-MD5&#x27; &#125;);response.write(fileData);response.addTrailers(&#123; &#x27;Content-MD5&#x27;: &#x27;7895bf4b8828b55ceaf47747b4bca667&#x27; &#125;);response.end(); 如果尾部响应头字段的名称或值包含无效字符，则抛出 TypeError 错误。 response.getHeader(name) name 返回: 读取一个已入队列但尚未发送到客户端的响应头。 注意，名称不区分大小写。const contentType = response.getHeader(‘content-type’); response.headersSent 返回一个布尔值（只读）。 如果响应头已被发送则为 true，否则为 false。 response.removeHeader(name) name 从隐式发送的队列中移除一个响应头。 response.sendDate 当为 true 时，如果响应头里没有日期响应头，则日期响应头会被自动生成并发送。默认为 true 该属性只可在测试时被禁用，因为HTTP响应需要包含日期响应头 response.setHeader(name, value) name value | &lt;string[]&gt;为一个隐式的响应头设置值。 如果该响应头已存在，则值会被覆盖。 如果要发送多个名称相同的响应头，则使用字符串数组。如果响应头字段的名称或值包含无效字符，则抛出 TypeError 错误。response.setHeader() 设置的响应头会与 response.writeHead() 设置的响应头合并，且 response.writeHead() 的优先。1234567// 返回 content-type = text/plainconst server = http.createServer((req, res) =&gt; &#123; res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html&#x27;); res.setHeader(&#x27;X-Foo&#x27;, &#x27;bar&#x27;); res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;); res.end(&#x27;ok&#x27;);&#125;); response.statusCode 当使用隐式的响应头时（没有显式地调用 response.writeHead()），该属性控制响应头刷新时将被发送到客户端的状态码。 response.statusCode = 404; 响应头被发送到客户端后，该属性表示被发出的状态码。 response.write(chunk[, encoding][, callback]) chunk | encoding callback 返回: 如果该方法被调用且 response.writeHead() 没有被调用，则它会切换到隐式响应头模式并刷新隐式响应头。该方法会发送一块响应主体。 它可被多次调用，以便提供连续的响应主体片段。请注意在http模块中，当请求是HEAD请求时，响应主体被省略。 类似地，204和304响应 不能 包括消息体。chunk 可以是一个字符串或一个 buffer。 如果 chunk 是一个字符串，则第二个参数指定如何将它编码成一个字节流。 encoding 默认为 ‘utf8’。 当数据块被刷新时，callback 会被调用。注意：这是原始的 HTTP 主体，且与可能被使用的高级主体编码无关。 response.write() 首次被调用时，会发送缓冲的响应头信息和响应主体的第一块数据到客户端。 response.write() 第二次被调用时，Node.js 能够确定数据会被接收，于是开始传输新数据。 也就是说，响应的完成取决于响应主体的第一块数据。如果全部数据被成功刷新到内核缓冲区，则返回 true。 如果全部或部分数据还在内存中排队，则返回 false。 当缓冲区再次空闲时，则触发 ‘drain’ 事件。 http.IncomingMessage 类IncomingMessage 对象由 http.Server 或 http.ClientRequest 创建，并作为第一个参数分别递给 ‘request’ 和 ‘response’ 事件。 它可以用来访问响应状态、消息头、以及数据。它实现了 可读流 接口 message.httpVersion 在服务器请求中，该属性返回客户端发送的 HTTP 版本。 在客户端响应中，该属性返回连接到的服务器的 HTTP 版本。 可能的值有 '1.1' 或 '1.0'。 message.httpVersionMajor 返回 HTTP 版本的第一个整数值，message.httpVersionMinor 返回 HTTP 版本的第二个整数值。 message.rawHeaders 接收到的原始的请求头或响应头列表。 注意，键和值在同一个列表中。 偶数位的是键，奇数位的是对应的值。头信息的名称不会被转换为小写，重复的也不会被合并。 12345678910console.log(request.rawHeaders);//// [ &#x27;user-agent&#x27;,// &#x27;this is invalid because there can be only one&#x27;,// &#x27;User-Agent&#x27;,// &#x27;curl/7.22.0&#x27;,// &#x27;Host&#x27;,// &#x27;127.0.0.1:8000&#x27;,// &#x27;ACCEPT&#x27;,// &#x27;*/*&#x27; ] http2检查是否支持HTTP2 123456let http2;try &#123; http2 = require(&#x27;node:http2&#x27;);&#125; catch (err) &#123; console.error(&#x27;http2 support is disabled!&#x27;);&#125; 服务端代码举例 1234567891011121314151617181920212223const http2 = require(&#x27;node:http2&#x27;);const fs = require(&#x27;node:fs&#x27;);const server = http2.createSecureServer(&#123; key: fs.readFileSync(&#x27;localhost-privkey.pem&#x27;), cert: fs.readFileSync(&#x27;localhost-cert.pem&#x27;),&#125;);server.on(&#x27;error&#x27;, (err) =&gt; console.error(err));server.on(&#x27;stream&#x27;, (stream, headers) =&gt; &#123; // stream is a Duplex stream.respond(&#123; &#x27;content-type&#x27;: &#x27;text/html; charset=utf-8&#x27;, &#x27;:status&#x27;: 200, &#125;); stream.end(&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;);&#125;);server.listen(8443);// 生成证书和键的命令openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj &#x27;/CN=localhost&#x27; \\ -keyout localhost-privkey.pem -out localhost-cert.pem 客户端代码举例 1234567891011121314151617181920212223const http2 = require(&#x27;node:http2&#x27;);const fs = require(&#x27;node:fs&#x27;);const client = http2.connect(&#x27;https://localhost:8443&#x27;, &#123; ca: fs.readFileSync(&#x27;localhost-cert.pem&#x27;),&#125;);client.on(&#x27;error&#x27;, (err) =&gt; console.error(err));const req = client.request(&#123; &#x27;:path&#x27;: &#x27;/&#x27; &#125;);req.on(&#x27;response&#x27;, (headers, flags) =&gt; &#123; for (const name in headers) &#123; console.log(`$&#123;name&#125;: $&#123;headers[name]&#125;`); &#125;&#125;);req.setEncoding(&#x27;utf8&#x27;);let data = &#x27;&#x27;;req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; data += chunk; &#125;);req.on(&#x27;end&#x27;, () =&gt; &#123; console.log(`\\n$&#123;data&#125;`); client.close();&#125;);req.end(); Class: Http2Session用户代码一般不直接创建Http2Session。在服务器端，当收到一个新的http2连接时会创建HTTP2Session。在客户端，使用HTTP2.connect()方法时创建http2session。 每个Http2Session实例创建时，只与一个net.Socket或tls.TLSSocket相关联。当Socket或Http2Session某一个被销毁时，两者都将被销毁。 Event: ‘frameError’ type The frame type. code The error code. id The stream id (or 0 if the frame isn’t associated with a stream).当试图在会话上发送帧发生错误时，将触发’frameError’事件。如果无法发送的帧与特定的Http2Stream相关联，则尝试在Http2Stream上发出’frameError’事件。如果’frameError’事件与某个流相关联，该流将在’frameError’事件发生后立即关闭并销毁。如果该事件没有与流关联，Http2Session将在’frameError’事件之后立即关闭。 Event: ‘localSettings’ settings &lt;HTTP/2 Settings Object&gt; A copy of the SETTINGS frame received.localSettings事件在收到一个确认设置帧时执行当使用http2session.settings()提交新的设置时，修改后的设置仅在localSettings事件执行后生效12345session.settings(&#123; enablePush: false &#125;);session.on(&#x27;localSettings&#x27;, (settings) =&gt; &#123; /* Use the new settings */&#125;); Event: ‘timeout’在使用Http2Session.settimeout()方法设置此Http2Session的超时时间之后，如果在配置的毫秒数之后Http2Session上没有活动，则会触发’timeout’事件。它的侦听器不期望任何参数。 http2session.alpnProtocol | 如果Http2Session还没有连接到socket，Value将是undefined，如果Http2Session没有连接到TLSSocket, Value将是h2c，或者将返回被连接的TLSSocket自己的alpnProtocol属性的值。 http2session.destroy([error][, code]) error 如果Http2Session由于错误而被销毁，则返回Error对象。 code HTTP/2在最终超时帧中发送的错误码。如果未指定，且error没有定义，则默认为INTERNAL_ERROR，否则默认为NO_ERROR。立即终止Http2Session和相关的net.Socket或tls.TLSSocket。一旦销毁，Http2Session将发出’close’事件。如果error未定义，则’error’事件将在’close’事件之前立即触发。如果有任何剩余的与Http2Session相关联的开放Http2Streams，它们也将被销毁。 http2session.encrypted | Value is undefined if the Http2Session session socket has not yet been connected, true if the Http2Session is connected with a TLSSocket, and false if the Http2Session is connected to any other kind of socket or stream.如果Http2Session会话未连接socket，则为undefined;如果Http2Session与TLSSocket连接，则为true;如果Http2Session连接到任何其他类型的socket或流，则为false。 http2session.pendingSettingsAck 指示Http2Session当前是否正在等待对发送的SETTINGS帧的确认。将在调用http2session.settings()方法后为true。当所有发送的设置帧被确认后，将为false。 http2session.ref()在这个Http2Session实例的底层net.Socket上调用ref()。与之相反的是http2session.unref() http2session.setLocalWindowSize(windowSize) windowSize 设置本地端点的窗口大小。windowSize是要设置的总窗口大小，而不是增量。123456789const http2 = require(&#x27;node:http2&#x27;);const server = http2.createServer();const expectedWindowSize = 2 ** 20;server.on(&#x27;connect&#x27;, (session) =&gt; &#123; // Set local window size to be 2 ** 20 session.setLocalWindowSize(expectedWindowSize);&#125;); http2session.state提供有关Http2Session当前状态的杂项信息。 - effectiveLocalWindowSize Http2Session的当前本地(接收)流控制窗口大小。 - effectiveRecvDataLength 自上次流控制WINDOW_UPDATE以来已接收的当前字节数。 - nextStreamID 下次由此Http2Session创建新的Http2Stream时使用的数字标识符。 - localWindowSize 远端对等端在不接收WINDOW_UPDATE的情况下可以发送的字节数。 - lastProcStreamID 最近接收报头或数据帧的Http2Stream的数字id。 - remoteWindowSize Http2Session在没有接收WINDOW_UPDATE的情况下可以发送的字节数。 - outboundQueueSize 当前在此Http2Session的出站队列中的帧数。 - deflateDynamicTableSize 出站报头压缩状态表的当前大小(以字节为单位)。 - inflateDynamicTableSize 入站报头压缩状态表的当前大小(以字节为单位)。 http2session.type The http2session.type will be equal to http2.constants.NGHTTP2_SESSION_SERVER if this Http2Session instance is a server, and http2.constants.NGHTTP2_SESSION_CLIENT if the instance is a client. http2session.type将等于http2.constants.NGHTTP2_SESSION_SERVER(如果这个Http2Session实例是一个服务器),等于http2.constants.NGHTTP2_SESSION_CLIENT(如果实例是客户端)。 Class: ServerHttp2SessionExtends: Class: ClientHttp2SessionExtends: Event: ‘altsvc’ alt origin streamId 当客户端接收到altsvc帧时，就会触发’altsvc’事件。该事件由ALTSVC值、起源和流ID触发。如果在ALTSVC帧中没有提供origin, origin将是一个空字符串。12345678const http2 = require(&#x27;node:http2&#x27;);const client = http2.connect(&#x27;https://example.org&#x27;);client.on(&#x27;altsvc&#x27;, (alt, origin, streamId) =&gt; &#123; console.log(alt); console.log(origin); console.log(streamId);&#125;); Event: ‘origin’ origins &lt;string[]&gt;当客户端接收到一个origin帧时，就会触发’origin’事件。该事件由一个源字符串数组触发。http2session.originSet将被更新以包含接收到的起源。1234567const http2 = require(&#x27;node:http2&#x27;);const client = http2.connect(&#x27;https://example.org&#x27;);client.on(&#x27;origin&#x27;, (origins) =&gt; &#123; for (let n = 0; n &lt; origins.length; n++) console.log(origins[n]);&#125;); ‘origin’事件仅在使用安全TLS连接时触发。 Class: Http2StreamExtends: &lt;stream.Duplex&gt; Http2Stream Lifecycle创建 服务器端创建ServerHttp2Stream时机： 接收到一个新的HTTP/2报头帧，其中包含先前未使用的流ID; 调用http2stream.pushStream()方法 客户端创建ClientHttp2Stream时机 调用http2session.request()方法在客户端，由Http2Session .request()返回的Http2Stream实例可能不会立即准备好使用，如果父Http2Session还没有完全建立。在这种情况下，在Http2Stream上调用的操作将被缓冲，直到’ready’事件被触发。用户代码很少(如果有的话)需要直接处理’ready’事件。Http2Stream的就绪状态可以通过检查Http2Stream .id的值来确定。如果该值为undefined，则流还没有准备好使用。 销毁Http2Stream实例销毁时机： 流的RST_STREAM帧被连接的对等端接收，并且(仅对于客户端流)挂起的数据已经被读取。 调用http2stream.close()方法，并且(仅针对客户端流)已读取挂起的数据。 http2stream.destroy()或http2session.destroy()方法被调用。当Http2Stream实例被销毁时，将尝试发送一个RST_STREAM帧给连接的对等体。当Http2Stream实例被销毁时，’close’事件将被触发。因为Http2Stream是stream.Duplex的一个实例。如果流数据当前正在流动，’end’事件也将被触发。如果调用http2stream.destroy()时传递了一个error作为第一个参数，’error’事件也可能被触发。Http2Stream被销毁后，Http2Stream .destroyed属性将为true, Http2Stream .destroyed属性将为true。属性将指定RST_STREAM错误码。Http2Stream实例一旦被销毁就不再可用。 http2stream.priority(options) options exclusive 当为true且parent标识父流时，此流将成为父流的唯一直接依赖项，所有其他现有依赖项都将成为此流的依赖项。默认值:false。 parent 指定此流所依赖的流的数字标识符。 weight 指定一个流相对于具有相同父流的其他流的相对依赖关系。取值为1 ~ 256之间的数字。 silent 当为true时，在本地改变优先级，而不向连接的对等体发送优先级帧。更新此Http2Stream实例的优先级。 http2stream.sendTrailers(headers) headers &lt;HTTP/2 Headers Object&gt;向连接的HTTP/2对等端发送一个尾随报头帧。此方法将导致Http2Stream立即关闭，并且只能在’wantTrailers’事件触发后调用。当发送请求或发送响应时，必须设置options.waitForTrailers选项，以便在最后的数据帧之后保持Http2Stream打开，以便可以发送trailers。123456789const http2 = require(&#x27;node:http2&#x27;);const server = http2.createServer();server.on(&#x27;stream&#x27;, (stream) =&gt; &#123; stream.respond(undefined, &#123; waitForTrailers: true &#125;); stream.on(&#x27;wantTrailers&#x27;, () =&gt; &#123; stream.sendTrailers(&#123; xyz: &#x27;abc&#x27; &#125;); &#125;); stream.end(&#x27;Hello World&#x27;);&#125;); HTTP/1规范禁止trailers包含HTTP/2伪报头字段(例如:’:method’， ‘:path’，等等)。 Class: ClientHttp2StreamExtends Event: ‘response’ headers &lt;HTTP/2 Headers Object&gt; flags 当从连接的HTTP/2服务器接收到此流的响应报头帧时，会触发’response’事件。监听器返回两个参数:一个包含接收到的HTTP/2 Headers对象的对象，以及与头部相关的标志。123456const http2 = require(&#x27;node:http2&#x27;);const client = http2.connect(&#x27;https://localhost&#x27;);const req = client.request(&#123; &#x27;:path&#x27;: &#x27;/&#x27; &#125;);req.on(&#x27;response&#x27;, (headers, flags) =&gt; &#123; console.log(headers[&#x27;:status&#x27;]);&#125;); Class: ServerHttp2Stream http2stream.respondWithFile(path[, headers[, options]]) path | | headers &lt;HTTP/2 Headers Object&gt; options statCheck onError 在发送之前发生错误时调用的回调函数。 waitForTrailers 当为true时，Http2Stream将在最后一个数据帧被发送后发出’wantTrailers’事件。 offset 开始读取的偏移位置。 length fd要发送的数据量发送一个常规文件作为响应。该路径必须指定一个常规文件，否则将在Http2Stream对象上触发’error’事件。当使用时，Http2Stream对象的Duplex接口将自动关闭。可以指定options.statCheck函数，让用户代码有机会基于fs设置额外的内容标头。给定文件的统计细节:如果在试图读取文件数据时发生错误，Http2Stream将使用RST_STREAM帧和标准INTERNAL_ERROR代码关闭。如果定义了onError回调函数，则将调用它。否则流将被破坏。options.statCheck函数也可以通过返回false来取消发送操作。内容长度报头字段将被自动设置。偏移量和长度选项可用于将响应限制到特定的范围子集。options.onError函数还可以用于处理在文件传递开始之前可能发生的所有错误。默认行为是销毁流。如果设置了options.waitForTrailers选项，’wantTrailers’事件将在最后一块要发送的有效负载数据排队后立即触发。然后可以使用http2stream.sendTrailers()方法向对等端发送尾随报头字段。如果设置了options.waitForTrailers, Http2Stream将不会在传输最后一个数据帧时自动关闭。用户代码必须调用Http2Stream.sendTrailers()或Http2Stream.close()来关闭Http2Stream。 Class: Http2ServerExtends: &lt;net.Server&gt;使用http2.createServer()后创建的Http2Server实例。Http2Server类不由node:http2模块直接导出 Event: ‘stream’ stream 对流的引用 headers &lt;HTTP/2 Headers Object&gt; header对象 flags 相关的数字标志 rawHeaders 一个数组，其中包含原始标头名称和它们各自的值。当与服务器相关的Http2Session触发’stream’事件时，就会触发’stream’事件。可以查看Http2Session的’stream’事件 server.updateSettings([settings]) settings &lt;HTTP/2 Settings Object&gt;用于更新server的设置遇到错误的设置值抛出ERR_HTTP2_INVALID_SETTING_VALUE错误遇到错误的设置参数抛出ERR_INVALID_ARG_TYPE错误 Class: Http2SecureServer Event: ‘unknownProtocol’ socket &lt;stream.Duplex&gt;‘unknownProtocol’事件在连接的客户端无法协商允许的协议(即HTTP/2或HTTP/1.1)时触发。事件处理程序接收socket进行处理。如果没有为此事件注册侦听器，则连接将被终止。超时可以使用传递给http2.createSecureServer()的’unknownProtocolTimeout’选项指定。 http2.createServer([options][, onRequestHandler])由于目前还没有已知的浏览器支持未加密的HTTP/2，因此在与浏览器客户端通信时，必须使用http2.createSecureServer()。 1234567891011121314151617const http2 = require(&#x27;node:http2&#x27;);// Create an unencrypted HTTP/2 server.// Since there are no browsers known that support// unencrypted HTTP/2, the use of `http2.createSecureServer()`// is necessary when communicating with browser clients.const server = http2.createServer();server.on(&#x27;stream&#x27;, (stream, headers) =&gt; &#123; stream.respond(&#123; &#x27;content-type&#x27;: &#x27;text/html; charset=utf-8&#x27;, &#x27;:status&#x27;: 200, &#125;); stream.end(&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;);&#125;);server.listen(80); http2.createSecureServer(options[, onRequestHandler])返回一个创建和管理Http2Session实例的tls服务器实例。 1234567891011121314151617181920const http2 = require(&#x27;node:http2&#x27;);const fs = require(&#x27;node:fs&#x27;);const options = &#123; key: fs.readFileSync(&#x27;server-key.pem&#x27;), cert: fs.readFileSync(&#x27;server-cert.pem&#x27;),&#125;;// Create a secure HTTP/2 serverconst server = http2.createSecureServer(options);server.on(&#x27;stream&#x27;, (stream, headers) =&gt; &#123; stream.respond(&#123; &#x27;content-type&#x27;: &#x27;text/html; charset=utf-8&#x27;, &#x27;:status&#x27;: 200, &#125;); stream.end(&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;);&#125;);server.listen(80); http2.constantsError codes for RST_STREAM and GOAWAY http2.getDefaultSettings() Returns: &lt;HTTP/2 Settings Object&gt;返回一个包含Http2Session实例默认设置的对象。此方法每次调用时返回一个新的对象实例，因此返回的实例可以安全地修改以供使用。 http2.getPackedSettings([settings]) settings &lt;HTTP/2 Settings Object&gt; Returns: 返回一个Buffer实例，该实例包含HTTP/2规范中指定的给定HTTP/2设置的序列化表示。这将用于HTTP2-Settings报头字段。与http2.getUnpackedSettings(buf)作用相反 Headers object头文件在JavaScript对象上表示为own-properties。属性键将被序列化为小写。属性值应该是字符串(如果不是，它们将被强制转换为字符串)或字符串数组(以便每个报头字段发送多个值)。 1234567const headers = &#123; &#x27;:status&#x27;: &#x27;200&#x27;, &#x27;content-type&#x27;: &#x27;text-plain&#x27;, &#x27;ABC&#x27;: [&#x27;has&#x27;, &#x27;more&#x27;, &#x27;than&#x27;, &#x27;one&#x27;, &#x27;value&#x27;],&#125;;stream.respond(headers); 传递给回调函数的头对象将有一个空原型。这意味着正常的JavaScript对象方法，如object .prototype. tostring()和object .prototype. hasownproperty()将无法工作。对于传入的报头: :status头转化为数字. 以下属性已废弃 :status, :method, :authority, :scheme, :path, :protocol, age, authorization, access-control-allow-credentials, access-control-max-age, access-control-request-method, content-encoding, content-language, content-length, content-location, content-md5, content-range, content-type, date, dnt, etag, expires, from, host, if-match, if-modified-since, if-none-match, if-range, if-unmodified-since, last-modified, location, max-forwards, proxy-authorization, range, referer,retry-after, tk, upgrade-insecure-requests, user-agent or x-content-type-options set-cookie总是一个数组，新值添加到数组中 多个cookie报头, 值使用 ‘; ‘连接，其他报头，值用’, ‘连接 Sensitive headersHTTP2报头可以被标记为敏感的，这意味着HTTP/2报头压缩算法永远不会索引它们。这对于低熵的报头值是有意义的，并且可能被攻击者认为是有价值的，例如Cookie或授权。要实现这一点，将头名称添加到[http2. conf]文件中。属性作为数组: 123456789const headers = &#123; &#x27;:status&#x27;: &#x27;200&#x27;, &#x27;content-type&#x27;: &#x27;text-plain&#x27;, &#x27;cookie&#x27;: &#x27;some-cookie&#x27;, &#x27;other-sensitive-header&#x27;: &#x27;very secret data&#x27;, [http2.sensitiveHeaders]: [&#x27;cookie&#x27;, &#x27;other-sensitive-header&#x27;],&#125;;stream.respond(headers); 对于某些报头，如授权和短Cookie报头，此标志是自动设置的。此属性也为接收的报头设置。它将包含所有标记为敏感的头文件的名称，包括自动标记为敏感的头文件。 Error handling在使用node:http2模块时，可能会出现几种类型的错误条件: 当传入不正确的参数、选项或设置值时，将发生验证错误。这些将始终由同步抛出报告。 状态错误发生在在不正确的时间尝试操作时(例如，尝试在流关闭后向流发送数据)。这些将使用同步抛出或通过Http2Stream、Http2Session或HTTP/2 Server对象上的’error’事件报告，这取决于错误发生的时间和地点。 HTTP/2会话异常失败时，内部错误。这些将通过Http2Session或HTTP/2 Server对象上的’error’事件报告。 当违反各种HTTP/2协议约束时，就会发生协议错误。这些将使用同步抛出或通过Http2Stream、Http2Session或HTTP/2 Server对象上的’error’事件报告，这取决于错误发生的时间和地点。 报头名称和值中的无效字符处理HTTP/2实现比HTTP/1实现更严格地处理HTTP报头名称和值中的无效字符。报头字段名是不区分大小写的，并且在线路上严格以小写字符串传输。Node.js提供的API允许头名称设置为混合大小写字符串(例如Content-Type)，但会在传输时将其转换为小写(例如Content-Type)。报头字段名必须只包含以下一个或多个ASCII字符:a-z, a-z, 0-9， !， #， $， %， &amp;， ‘， *， +， -， .， ^， _， ‘(反引号)，|，和~。在HTTP报头字段名中使用无效字符将导致流关闭，并报告协议错误。报头字段值的处理更为宽松，但不应包含换行或回车字符，并应根据HTTP规范的要求限制为US-ASCII字符。 在HTTP/2中，请求路径、主机名、协议和方法表示为特殊的头，前缀为:字符(例如:path)。这些特殊的头文件将包含在request.headers对象中。必须注意不要无意中修改这些特殊的标头，否则可能会发生错误。例如，从请求中删除所有头部将导致错误发生: 注意：:authority和主机HTTP/2要求请求具有:authority伪报头或主机报头。直接构建HTTP/2请求时优先使用:authority，从HTTP/1转换时使用主机(例如，在代理中)。如果:authority不存在，兼容性API回落到主机。但是，如果不使用兼容性API(或直接使用req.headers)，需要自己实现任何回退行为。 https判断是否支持crypto 123456let https;try &#123; https = require(&#x27;node:https&#x27;);&#125; catch (err) &#123; console.error(&#x27;https support is disabled!&#x27;);&#125; Class: https.Agent new Agent([options]) options 要在代理上设置的一组可配置选项。可以具有与http.Agent(options)相同的字段。还有： maxCachedSessions TLS缓存的最大会话数。使用0禁用TLS会话缓存。默认值:100。 servername 服务器名指示要发送到服务器的扩展名的值。使用空字符串”禁用发送扩展名。Default:目标服务器的主机名，除非目标服务器是使用IP地址指定的，在这种情况下，默认为’’(无扩展名)。 Event: ‘keylog’ line ASCII文本行，NSS SSLKEYLOGFILE格式。 tlsSocket &lt;tls.TLSSocket&gt; 生成的tls.TLSSocket实例keylog事件在此代理管理的连接生成密钥材料或接收密钥材料时触发(通常在握手完成之前，但不一定)。可以存储此密钥材料以进行调试，因为它允许对捕获的TLS流量进行解密。每个socket可能会触发多次。 https.request(options[, callback])https.request(url[, options][, callback]) url | options | | 与http.request()选项一致, 存在如下默认值差异: protocol Default: ‘https:’ port Default: 443 agent Default: https.globalAgent callback Returns: &lt;http.ClientRequest&gt;以下来自tls.connect()的额外属性也可以添加到options中：ca, cert, ciphers, clientCertEngine, crl, dhparam, ecdhCurve, honorCipherOrder, key, passphrase, pfx, rejectUnauthorized, secureOptions, secureProtocol, servername, sessionIdContext, highWaterMark.options可以是一个对象、一个字符串或者一个URL对象。如果options是字符串，会自动使用new URL()解析。如果是一个URL对象，会自动转换为一个普通的options对象。https.request()返回一个http.ClientRequest类的实例。 ClientRequest实例是一个可写流。如果需要使用POST请求上传文件，可以写入ClientRequest的对象中。"},{"title":"nodejs基础知识(10)","date":"2023-01-18T05:32:50.000Z","updated":"2023-07-24T09:24:46.499Z","comments":true,"path":"nodejs/nodejs-note-19.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-19.html","excerpt":"","text":"CommonJS启用Node.js 有两个模块系统：CommonJS 模块和 ECMAScript 模块。默认情况下，Node.js 会将以下内容视为 CommonJS 模块： 扩展名为 .cjs 的文件； 当最近的父 package.json 文件包含值为 “commonjs” 的顶层字段 “type” 时，则扩展名为 .js 的文件。 当最近的父 package.json 文件不包含顶层字段 “type” 时，则扩展名为 .js 的文件。 包作者应该包括 “type” 字段，即使在所有源都是 CommonJS 的包中也是如此。 明确包的 type 将使构建工具和加载器更容易确定包中的文件应该如何解释。 扩展名不是 .mjs、.cjs、.json、.node、或 .js 的文件（当最近的父 package.json 文件包含值为 “module” 的顶层字段 “type” 时，这些文件只有在它们是 require 的，而不是用作程序的命令行入口点）。调用 require() 始终使用 CommonJS 模块加载器。 调用 import() 始终使用 ECMAScript 模块加载器。 访问主模块当文件直接从 Node.js 运行时，则 require.main 被设置为其 module。 这意味着可以通过测试 require.main === module 来确定文件是否被直接运行。对于文件 foo.js，如果通过 node foo.js 运行，则为 true，如果通过 require(‘./foo’) 运行，则为 false。当入口点不是 CommonJS 模块时，则 require.main 为 undefined，且主模块不可达。 require的伪代码高级算法 模块缓存的注意事项模块根据其解析的文件名进行缓存。 由于模块可能会根据调用模块的位置（从 node_modules 文件夹加载）解析为不同的文件名，因此如果 require(‘foo’) 解析为不同的文件，则不能保证 require(‘foo’) 将始终返回完全相同的对象。此外，在不区分大小写的文件系统或操作系统上，不同的解析文件名可以指向同一个文件，但缓存仍会将它们视为不同的模块，并将多次重新加载文件。 例如，require(‘./foo’) 和 require(‘./FOO’) 返回两个不同的对象，而不管 ./foo 和 ./FOO 是否是同一个文件。 核心模块Node.js 有些模块编译成二进制文件。 这些模块在本文档的其他地方有更详细的描述。核心模块在 Node.js 源代码中定义，位于 lib/ 文件夹中。可以使用 node: 前缀来识别核心模块，在这种情况下它会绕过 require 缓存。 例如，require(‘node:http’) 将始终返回内置的 HTTP 模块，即使有该名称的 require.cache 条目。如果某些核心模块的标识符传给 require()，则总是优先加载它们。 例如，require(‘http’) 将始终返回内置的 HTTP 模块，即使存在该名称的文件。 不使用 node: 前缀可以加载的核心模块列表暴露为 module.builtinModules。 循环当有循环 require() 调用时，模块在返回时可能尚未完成执行。举例如下： 12345678910111213141516171819202122232425262728293031// &lt;!-- a.js: --&gt;console.log(&#x27;a starting&#x27;);exports.done = false;const b = require(&#x27;./b.js&#x27;);console.log(&#x27;in a, b.done = %j&#x27;, b.done);exports.done = true;console.log(&#x27;a done&#x27;);// &lt;!-- b.js: --&gt;console.log(&#x27;b starting&#x27;);exports.done = false;const a = require(&#x27;./a.js&#x27;);console.log(&#x27;in b, a.done = %j&#x27;, a.done);exports.done = true;console.log(&#x27;b done&#x27;);// &lt;!-- main.js: --&gt;console.log(&#x27;main starting&#x27;);const a = require(&#x27;./a.js&#x27;);const b = require(&#x27;./b.js&#x27;);console.log(&#x27;in main, a.done = %j, b.done = %j&#x27;, a.done, b.done);// $ node main.js// main starting// a starting// b starting// in b, a.done = false// b done// in a, b.done = true// a done// in main, a.done = true, b.done = true 当 main.js 加载 a.js 时，a.js 依次加载 b.js。 此时，b.js 尝试加载 a.js。 为了防止无限循环，将 a.js 导出对象的未完成副本返回给 b.js 模块。 然后 b.js 完成加载，并将其 exports 对象提供给 a.js 模块。到 main.js 加载这两个模块时，它们都已完成。 文件模块如果找不到确切的文件名，Node.js 将尝试加载所需的文件名，并添加扩展名：.js、.json，最后是 .node。 当加载具有不同扩展名的文件（例如 .cjs）时，则必须将其全名传给 require()，包括其文件扩展名（例如 require(‘./file.cjs’)）。.json 文件被解析为 JSON 文本文件，.node 文件被解释为加载了 process.dlopen() 的已编译插件模块。 使用任何其他扩展名（或根本没有扩展名）的文件被解析为 JavaScript 文本文件。以 ‘/‘ 为前缀的必需模块是文件的绝对路径。 例如，require(‘/home/marco/foo.js’) 将在 /home/marco/foo.js 加载文件。以 ‘./‘ 为前缀的必需模块与调用 require() 的文件相关。 也就是说，circle.js 必须和 foo.js 在同一个目录下，require(‘./circle’) 才能找到它。如果没有前导 ‘/‘、’./‘ 或 ‘../‘ 来指示文件，则该模块必须是核心模块或从 node_modules 文件夹加载。如果给定路径不存在，则 require() 将抛出 MODULE_NOT_FOUND 错误。 目录作为模块可以通过三种方式将文件夹作为参数传给 require()。 在文件夹的根目录创建 package.json 文件，指定 main 模块。 一个示例 package.json 文件可能如下所示：1&#123; &quot;name&quot; : &quot;some-library&quot;, &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125; 如果这是在 ./some-library 的文件夹中，则 require(‘./some-library’) 将尝试加载 ./some-library/lib/some-library.js。 目录中不存在 package.json 文件，或者 “main” 条目丢失或无法解析，则 Node.js 将尝试从该目录中加载 index.js 或 index.node 文件。 例如，如果前面的示例中没有 package.json 文件，则 require(‘./some-library’) 将尝试加载：12./some-library/index.js./some-library/index.node 如果这些尝试失败，Node.js 将报告整个模块丢失，并显示默认错误：1Error: Cannot find module &#x27;some-library&#x27; 在上述所有三种情况下，import(‘./some-library’) 调用都将导致 ERR_UNSUPPORTED_DIR_IMPORT 错误。 使用包子路径导出或子路径导入可以提供与文件夹作为模块相同的包含组织优势，并且适用于 require 和 import。 从 node_modules 目录加载如果传给 require() 的模块标识符不是核心模块，并且不以 ‘/‘、’../‘ 或 ‘./‘ 开头，则 Node.js 从当前模块的目录开始，并添加 /node_modules，并尝试从该位置加载模块。 Node.js 不会将 node_modules 附加到已经以 node_modules 结尾的路径。如果在那里找不到它，则它移动到父目录，依此类推，直到到达文件系统的根目录。例如，如果 ‘/home/ry/projects/foo.js’ 处的文件调用 require(‘bar.js’)，则 Node.js 将按以下顺序查找以下位置： /home/ry/projects/node_modules/bar.js /home/ry/node_modules/bar.js /home/node_modules/bar.js /node_modules/bar.js这允许程序本地化它们的依赖项，这样它们就不会发生冲突。通过在模块名称后包含路径后缀，可以要求与模块一起分发的特定文件或子模块。 例如，require(‘example-module/path/to/file’) 将相对于 example-module 所在的位置解析 path/to/file。 后缀路径遵循相同的模块解析语义。 模块作用域__dirname 当前模块的目录名。 这与 __filename 的 path.dirname() 相同。 示例：从 /Users/mjr 运行 node example.js 1234console.log(__dirname);// 打印: /Users/mjrconsole.log(path.dirname(__filename));// 打印: /Users/mjr __filename 当前模块的文件名。 这是当前模块文件的已解析符号链接的绝对路径。 对于主程序，这不一定与命令行中使用的文件名相同 示例：从 /Users/mjr 运行 node example.js 1234console.log(__filename);// 打印: /Users/mjr/example.jsconsole.log(__dirname);// 打印: /Users/mjr require.cache 模块在需要时缓存在此对象中。 通过从此对象中删除键值，下一次 require 将重新加载模块。 这不适用于原生插件，因为重新加载会导致错误。 添加或替换条目也是可能的。 在本地模块之前检查此缓存，如果将匹配本地模块的名称添加到缓存中，则只有 node: 前缀的 require 调用将接收本地模块。 小心使用！ require.main | Module 对象代表 Node.js 进程启动时加载的入口脚本，如果程序的入口点不是 CommonJS 模块，则为 undefined。 module.path 模块的目录名称。 这通常与 module.id 的 path.dirname() 相同。 module.paths &lt;string[]&gt;模块的搜索路径。"},{"title":"深入浅出nodejs阅读笔记(2)","date":"2022-11-19T13:10:12.000Z","updated":"2023-07-24T09:24:46.499Z","comments":true,"path":"nodejs/nodejs-note-2.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-2.html","excerpt":"","text":"为什么要异步 I/O 用户体验 资源分配 异步I/O与非阻塞I/O操作系统内核对于I/O只有两种方式：阻塞与非阻塞。在调用阻塞I/O时，应用程序需要等待I/O完成才返回结果阻塞I/O的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。以读取磁盘上的一段文件为例，系统内核在完成磁盘寻道、读取数据、复制数据到内存中之后，这个调用才结束。 阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用。为了提高性能，内核提供了非阻塞I/O。非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回 操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。此处非阻塞I/O与阻塞I/O的区别在于阻塞I/O完成整个获取数据的过程，而非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取 阻塞I/O造成CPU等待浪费，非阻塞带来的麻烦却是需要轮询去确认是否完全完成数据获取，它会让CPU处理状态判断，是对CPU资源的浪费现存的轮询技术主要有以下这些： read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。 select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断 select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符 poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。 epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高 kqueue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在 Node 的异步 I/O 事件循环进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程 观察者每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件 请求对象请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理 事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。Windows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事件循环，以此完成异步I/O的过程。Linux下通过epoll实现这个过程FreeBSD下通过kqueue实现Solaris下通过Event ports实现 不同的是线程池在Windows下由内核（IOCP）直接提供，*nix系列下由libuv自行实现 非 I/O 的异步 API 定时器调用setTimeout()或者setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。 定时器的问题在于，它并非精确的（在容忍范围内）。尽管事件循环十分快，但是如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。譬如通过setTimeout()设定一个任务在10毫秒后执行，但是在9毫秒后，有一个任务占用了5毫秒的CPU时间片，再次轮到定时器执行时，时间就已经过期4毫秒 process.nextTick()12345678910111213process.nextTick = function(callback) &#123; // on the way out, don&#x27;t bother. // it won&#x27;t get fired anyway if (process._exiting) return; if (tickDepth &gt;= process.maxTickDepth) maxTickWarn(); var tock = &#123; callback: callback &#125;; if (process.domain) tock.domain = process.domain; nextTickQueue.push(tock); if (nextTickQueue.length) &#123; process._needTickCallback(); &#125; &#125;; 每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效 setImmediate()process.nextTick()中的回调函数执行的优先级要高于setImmediate()。这里的原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者，setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。 process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果则是保存在链表中。在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。 1234567891011121314151617181920212223242526// 加入两个nextTick()的回调函数process.nextTick(function () &#123; console.log(&#x27;nextTick延迟执行1&#x27;); &#125;); process.nextTick(function () &#123; console.log(&#x27;nextTick延迟执行2&#x27;); &#125;); // 加入两个setImmediate()的回调函数setImmediate(function () &#123; console.log(&#x27;setImmediate延迟执行1&#x27;); // 进入下次循环 process.nextTick(function () &#123; console.log(&#x27;强势插入&#x27;); &#125;); &#125;); setImmediate(function () &#123; console.log(&#x27;setImmediate延迟执行2&#x27;); &#125;); console.log(&#x27;正常执行&#x27;); // 其执行结果如下：// 正常执行// nextTick延迟执行1 // nextTick延迟执行2 // setImmediate延迟执行1 // 强势插入// setImmediate延迟执行2 异步编程 高阶函数:高阶函数则是可以把函数作为参数，或是将函数作为返回值的函数 偏函数用法: 偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。 异步编程的优势与难点 优势非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用。对于网络应用而言，并行带来的想象空间更大，延展而开的是分布式和云 难点 异常处理 函数嵌套过深 阻塞代码 多线程编程 异步转同步 异步编程解决方案 事件发布/订阅模式。 Node自身提供的events模块（http://nodejs.org/docs/latest/api/events.html）是发布/订阅模式的一个简单实现，Node中部分模块都继承自它，这个模块比前端浏览器中的大量DOM事件简单，不存在事件冒泡，也不存在preventDefault()、stopPropagation()和stopImmediatePropagation()等控制事件传递的方法。它具有 addListener/on() 、 once() 、 removeListener() 、removeAllListeners()和emit()等基本的事件监听模式的方法实现 如果对一个事件添加了超过10个侦听器，将会得到一条警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏，所以存在这样一条警告。调用emitter.setMaxListeners(0)；可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。 为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理 继承events模块 利用事件队列解决雪崩问题 多异步之间的协作方案12345678910111213141516171819var count = 0; var results = &#123;&#125;; var done = function (key, value) &#123; results[key] = value; count++; if (count === 3) &#123; // 渲染页面 render(results); &#125; &#125;; fs.readFile(template_path, &quot;utf8&quot;, function (err, template) &#123; done(&quot;template&quot;, template); &#125;); db.query(sql, function (err, data) &#123; done(&quot;data&quot;, data); &#125;); l10n.get(function (err, resources) &#123; done(&quot;resources&quot;, resources); &#125;); EventProxy的原理12345678910111213141516171819202122// Trigger an event, firing all bound callbacks. Callbacks are passed the // same arguments as `trigger` is, apart from the event name. // Listening for `&quot;all&quot;` passes the true event name as the first argument trigger : function(eventName) &#123; var list, calls, ev, callback, args; var both = 2; if (!(calls = this._callbacks)) return this; while (both--) &#123; ev = both ? eventName : &#x27;all&#x27;; if (list = calls[ev]) &#123; for (var i = 0, l = list.length; i &lt; l; i++) &#123; if (!(callback = list[i])) &#123; list.splice(i, 1); i--; l--; &#125; else &#123; args = both ? Array.prototype.slice.call(arguments, 1) : arguments; callback[0].apply(callback[1] || this, args); &#125; &#125; &#125; &#125; return this; &#125; EventProxy的异常处理 Promise/Deferred模式。 Promises/A Promise/Deferred模式其实包含两部分，即Promise和Deferred。这里暂且不提两者的区别是什么，先看看Promises/A的行为吧。Promises/A提议对单个异步操作做出了这样的抽象定义，具体如下所示。 Promise操作只会处在3种状态的一种：未完成态、完成态和失败态。 Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。 Promise的状态一旦转化，将不能被更改 在API的定义上，Promises/A提议是比较简单的。一个Promise对象只要具备then()方法即可。但是对于then()方法，有以下简单的要求。 接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法 可选地支持progress事件回调作为第三个方法。 then()方法只接受function对象，其余对象将被忽略。 then()方法继续返回Promise对象，以实现链式调用 Promise中的多异步协作1234567891011121314151617Deferred.prototype.all = function (promises) &#123; var count = promises.length; var that = this; var results = []; promises.forEach(function (promise, i) &#123; promise.then(function (data) &#123; count--; results[i] = data; if (count === 0) &#123; that.resolve(results); &#125; &#125;, function (err) &#123; that.reject(err); &#125;); &#125;); return this.promise; &#125;; - 支持序列执行的Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071promise() .then(obj.api1) .then(obj.api2) .then(obj.api3) .then(obj.api4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 尝试改造一下代码以实现链式调用，具体如下所示：var Deferred = function () &#123; this.promise = new Promise(); &#125;; // 完成态Deferred.prototype.resolve = function (obj) &#123; var promise = this.promise; var handler; while ((handler = promise.queue.shift())) &#123; if (handler &amp;&amp; handler.fulfilled) &#123; var ret = handler.fulfilled(obj); if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue; this.promise = ret; return; &#125; &#125; &#125; &#125;; // 失败态Deferred.prototype.reject = function (err) &#123; var promise = this.promise; var handler; while ((handler = promise.queue.shift())) &#123; if (handler &amp;&amp; handler.error) &#123; var ret = handler.error(err); if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue; this.promise = ret; return; &#125; &#125; &#125; &#125;; // 生成回调函数Deferred.prototype.callback = function () &#123; var that = this; return function (err, file) &#123; if (err) &#123; return that.reject(err); &#125; that.resolve(file); &#125;; &#125;; var Promise = function () &#123; // 队列用于存储待执行的回调函数 this.queue = []; this.isPromise = true; &#125;; Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) &#123; var handler = &#123;&#125;; if (typeof fulfilledHandler === &#x27;function&#x27;) &#123; handler.fulfilled = fulfilledHandler; &#125; if (typeof errorHandler === &#x27;function&#x27;) &#123; handler.error = errorHandler; &#125; this.queue.push(handler); return this; &#125;; - 将API Promise化 流程控制库 尾触发与Next 需要手工调用才能持续执行后续调用的，我们将此类方法叫做尾触发，常见的关键词是next。事实上，尾触发目前应用最多的地方是Connect的中间件 尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者Promise完成的，这样业务在纵向和横向都能够各自清晰 async 异步的串行执行1234567891011121314151617181920212223async.series([ function (callback) &#123; fs.readFile(&#x27;file1.txt&#x27;, &#x27;utf-8&#x27;, callback); &#125;, function (callback) &#123; fs.readFile(&#x27;file2.txt&#x27;, &#x27;utf-8&#x27;, callback); &#125; ], function (err, results) &#123; // results =&gt; [file1.txt, file2.txt] &#125;); 这段代码等价于：fs.readFile(&#x27;file1.txt&#x27;, &#x27;utf-8&#x27;, function (err, content) &#123; if (err) &#123; return callback(err); &#125; fs.readFile(&#x27;file2.txt &#x27;, &#x27;utf-8&#x27;, function (err, data) &#123; if (err) &#123; return callback(err); &#125; callback(null, [content, data]); &#125;); &#125;); 异步的并行执行12345678910async.parallel([ function (callback) &#123; fs.readFile(&#x27;file1.txt&#x27;, &#x27;utf-8&#x27;, callback); &#125;, function (callback) &#123; fs.readFile(&#x27;file2.txt&#x27;, &#x27;utf-8&#x27;, callback); &#125; ], function (err, results) &#123; // results =&gt; [file1.txt, file2.txt] &#125;); 异步调用的依赖处理 series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了。所幸，这种典型场景的需求，async提供了waterfall()方法来满足123456789101112131415161718192021async.waterfall([ function (callback) &#123; fs.readFile(&#x27;file1.txt&#x27;, &#x27;utf-8&#x27;, function (err, content) &#123; callback(err, content); &#125;); &#125;, function (arg1, callback) &#123; // arg1 =&gt; file2.txt fs.readFile(arg1, &#x27;utf-8&#x27;, function (err, content) &#123; callback(err, content); &#125;); &#125;, function(arg1, callback)&#123; // arg1 =&gt; file3.txt fs.readFile(arg1, &#x27;utf-8&#x27;, function (err, content) &#123; callback(err, content); &#125;); &#125; ], function (err, result) &#123; // result =&gt; file4.txt &#125;); 自动依赖处理 async提供了一个强大的方法auto()实现复杂业务处理。 Step1234567891011Step( function readFile1() &#123; fs.readFile(&#x27;file1.txt&#x27;, &#x27;utf-8&#x27;, this); &#125;, function readFile2(err, content) &#123; fs.readFile(&#x27;file2.txt&#x27;, &#x27;utf-8&#x27;, this); &#125;, function done(err, content) &#123; console.log(content); &#125; ); Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参数，并调用执行。 并行任务执行 this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务 使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数 结果分组: group() wind 异步任务定义 $await()与任务模型 异步方法转换辅助函数 Wind.Async.Binding.fromCallback Wind.Async.Binding.fromStandard 异步并发控制 bagpipe的解决方案 通过一个队列来控制并发量。 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行。 如果活跃调用达到限定值，调用暂时存放在队列中。 每个异步调用结束时，从队列中取出新的异步调用执行。 1234567891011var Bagpipe = require(&#x27;bagpipe&#x27;); // 设定最大并发数为10var bagpipe = new Bagpipe(10); for (var i = 0; i &lt; 100; i++) &#123; bagpipe.push(async, function () &#123; // 异步回调执行 &#125;); &#125; bagpipe.on(&#x27;full&#x27;, function (length) &#123; console.warn(&#x27;底层系统处理不能及时完成，队列拥堵，目前队列长度为:&#x27; + length); &#125;); 拒绝模式 超时控制 async的解决方案：async也提供了一个方法用于处理异步调用的限制：parallelLimit() parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同时并发一定数量，而不是无限制并发。 parallelLimit()方法的缺陷在于无法动态地增加并行任务。为此，async提供了queue()方法来满足该需求，这对于遍历文件目录等操作十分有效"},{"title":"nodejs基础知识(10)","date":"2023-01-20T01:38:46.000Z","updated":"2023-07-24T09:24:46.500Z","comments":true,"path":"nodejs/nodejs-note-20.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-20.html","excerpt":"","text":"ECMAScript 模块ECMAScript 模块是来打包 JavaScript 代码以供重用的官方标准格式。 模块使用各种 import 和 export 语句定义。Node.js 完全支持当前指定的 ECMAScript 模块，并且提供它们与其原始模块格式 CommonJS 之间的互操作性。 通过 .mjs 文件扩展名、package.json “type” 字段、或 –input-type 标志告诉 Node.js 使用 ECMAScript 模块加载器。 在这些情况之外，Node.js 将使用 CommonJS 模块加载器。 import 说明符import 语句的说明符是 from 关键字之后的字符串，例如 import { sep } from ‘node:path’ 中的 ‘node:path’。 说明符也用于 export from 语句，并作为 import() 表达式的参数。说明符类型： 相对说明符，如 ‘./startup.js’ 或 ‘../config.mjs’。 它们指的是相对于导入文件位置的路径。 文件扩展名对于这些始终是必需的。 裸说明符，如 ‘some-package’ 或 ‘some-package/shuffle’。 它们可以通过包名称来引用包的主要入口点，或者根据示例分别以包名称为前缀的包中的特定功能模块。 包括文件扩展名仅适用于没有 “exports” 字段的包。 绝对说明符，如 ‘file:///opt/nodejs/config.js’。 它们直接且明确地引用完整的路径。 裸说明符解析由 Node.js 模块解析算法处理。 所有其他说明符解析始终仅使用标准的相对网址解析语义进行解析。就像在 CommonJS 中一样，包中的模块文件可以通过在包名称后附加路径来访问，除非包的 package.json 包含 “exports” 字段，在这种情况下，包中的文件只能通过 “exports” 中定义的路径访问。 强制的文件扩展名使用 import 关键字解析相对或绝对的说明符时，必须提供文件扩展名，并完全指定目录索引。 URLES 模块被解析并缓存为 URL。 这意味着特殊字符必须是百分比编码的，比如使用 %23 的 #、使用 %3F 的 ?。支持 file:、node: 和 data: URL 协议。 除非使用自定义的 HTTPS 加载器，否则 Node.js 本身不支持像 ‘https://example.com/app.js&#39; 这样的说明符 file: URL如果用于解析模块的 import 说明符具有不同的查询或片段，则会多次加载模块。 12import &#x27;./foo.mjs?query=1&#x27;; // 加载具有 &quot;?query=1&quot; 查询的 ./foo.mjsimport &#x27;./foo.mjs?query=2&#x27;; // 加载具有 &quot;?query=2&quot; 查询的 ./foo.mjs 可以通过 /、//、或 file:/// 引用卷根。 鉴于网址和路径解析的差异（例如百分比编码细节），建议在导入路径时使用 url.pathToFileURL。 data: 导入data: URL 支持使用以下 MIME 类型导入： text/javascript 用于 ES 模块 pplication/json 用于 JSON application/wasm 用于 Wasm12import &#x27;data:text/javascript,console.log(&quot;hello!&quot;);&#x27;;import _ from &#x27;data:application/json,&quot;world!&quot;&#x27; assert &#123; type: &#x27;json&#x27; &#125;; data: URL 仅解析内置模块的裸说明符和绝对说明符。 解析相对说明符不起作用，因为 data: 不是特殊协议。 例如，尝试从 data:text/javascript,import “./foo”; 加载 ./foo 无法解析，因为 data: URL 没有相对解析的概念。 node: 导入支持 node: URL 作为加载 Node.js 内置模块的替代方法。 此 URL 协议允许有效的绝对的 URL 字符串引用内置模块。 内置模块核心模块提供了其公共 API 的命名导出。 还提供了默认导出，其是 CommonJS 导出的值。 默认导出可用于修改命名导出等。 内置模块的命名导出仅通过调用 module.syncBuiltinESMExports() 进行更新。 1234567891011import EventEmitter from &#x27;node:events&#x27;;import &#123; readFile &#125; from &#x27;node:fs&#x27;;import fs, &#123; readFileSync &#125; from &#x27;node:fs&#x27;;import &#123; syncBuiltinESMExports &#125; from &#x27;node:module&#x27;;import &#123; Buffer &#125; from &#x27;node:buffer&#x27;;fs.readFileSync = () =&gt; Buffer.from(&#x27;Hello, ESM&#x27;);syncBuiltinESMExports();fs.readFileSync === readFileSync;// true import() 表达式import.meta import.meta.url 模块的绝对的 file: URL。这与提供当前模块文件 URL 的浏览器中的定义完全相同。这可以启用有用的模式，使用举例：传入相对路径文件及import.meta.url，返回文件的绝对路径解析结果 与 CommonJS 的互操作性import 声明import 语句可以引用 ES 模块或 CommonJS 模块。 import 语句只允许在 ES 模块中使用，但 CommonJS 支持动态 import() 表达式来加载 ES 模块。 requireCommonJS 模块 require 总是将它引用的文件视为 CommonJS。不支持使用 require 加载 ES 模块，因为 ES 模块具有异步执行。 而是，使用 import() 从 CommonJS 模块加载 ES 模块。 ES 模块和 CommonJS 之间的差异 没有 require、exports 或 module.exports在大多数情况下，可以使用 ES 模块 import 加载 CommonJS 模块。如果需要，可以使用 module.createRequire() 在 ES 模块中构造 require 函数。 没有 __filename 或 __dirname这些 CommonJS 变量在 ES 模块中不可用。__filename 和 __dirname 用例可以通过 import.meta.url 复制。 没有原生模块加载ES 模块导入当前不支持原生模块。它们可以改为加载 module.createRequire() 或 process.dlopen。 没有 require.resolve相对解析可以通过 new URL(‘./local’, import.meta.url) 处理。对于完整的 require.resolve 替换，有标记的实验性 import.meta.resolve API。也可以使用 module.createRequire()。 没有 NODE_PATHNODE_PATH 不是解析 import 说明符的一部分。 如果需要这种行为，则使用符号链接。 没有 require.extensionsrequire.extensions 没有被 import 使用。 期望加载器钩子在未来可以提供这个工作流。 没有 require.cacherequire.cache 没有被 import 使用，因为 ES 模块加载器有自己独立的缓存。 JSON 模块import 可以引用 JSON 文件： 1import packageConfig from &#x27;./package.json&#x27; assert &#123; type: &#x27;json&#x27; &#125;; assert { type: ‘json’ } 语法是强制性的导入的 JSON 只暴露一个 default 导出。 不支持命名导出。 在 CommonJS 缓存中创建缓存条目，以避免重复。 如果 JSON 模块已经从同一路径导入，则在 CommonJS 中返回相同的对象。 顶层的 awaitawait 关键字可以用在 ECMAScript 模块的顶层主体中。如果顶层 await 表达式永远无法解析，则 node 进程将以 13 状态码退出。 package 包模块包是由 package.json 文件描述的文件夹树。 包由包含 package.json 文件的文件夹和所有子文件夹组成，直到包含另一个 package.json 文件的下一个文件夹或名为 node_modules 的文件夹。 当作为初始输入传入、或者当被 import 语句或 import() 表达式引用时，Node.js 会将以下视为ES 模块： 扩展名为 .mjs 的文件。 当最近的父 package.json 文件包含值为 “module” 的顶层 “type” 字段时，扩展名为 .js 的文件。 字符串作为参数传入 –eval，或通过 STDIN 管道传输到 node，带有标志 –input-type=module。 当被 import 语句或 import() 表达式或 require() 表达式引用时，Node.js 会将以下视为 CommonJS： 扩展名为 .cjs 的文件。 当最近的父 package.json 文件包含值为 “commonjs” 的顶层字段 “type” 时，则扩展名为 .js 的文件。 字符串作为参数传入 –eval 或 –print，或通过 STDIN 管道传输到 node，带有标志 –input-type=commonjs。 模块加载器CommonJS 模块加载器： 它是完全同步的。 它负责处理 require() 调用。 它是可修补的。 它支持文件夹作为模块。 当解析说明符时，如果没有找到完全的匹配，则它将尝试添加扩展名（.js、.json，最后是 .node），然后尝试将文件夹作为模块解析。 它将 .json 视为 JSON 文本文件。 .node 文件被解释为加载了 process.dlopen() 的编译插件模块。 它将所有缺少 .json 或 .node 扩展名的文件视为 JavaScript 文本文件。 它不能用于加载 ECMAScript 模块（尽管可以从 CommonJS 模块加载 ECMASCript 模块）。 当用于加载不是 ECMAScript 模块的 JavaScript 文本文件时，则它将作为 CommonJS 模块加载。 ECMAScript 模块加载器： 它是异步的。 负责处理 import 语句和 import() 表达式。 它不是可修补的，可以使用加载器钩子自定义。 它不支持文件夹作为模块，必须完全指定目录索引（例如 ‘./startup/index.js’）。 它不进行扩展名搜索。 当说明符是相对或绝对的文件 URL 时，必须提供文件扩展名。 它可以加载 JSON 模块，但需要导入断言。 它只接受 JavaScript 文本文件的 .js、.mjs 和 .cjs 扩展名。 它可以用来加载 JavaScript CommonJS 模块。 这样的模块通过 es-module-lexer 来尝试识别命名的导出，如果可以通过静态分析确定的话是可用的。 导入的 CommonJS 模块将其 URL 转换为绝对路径，然后通过 CommonJS 模块加载器加载。 package.json 和文件扩展名如果 package.json 文件没有 “type” 字段或type 字段值为 commonjs，则 .js 文件将被视为 CommonJS。如果 package.json “type” 值为”module”，该包中的 .js 文件解释为使用 ES 模块语法。 .mjs 文件总是作为 ES 模块加载，而不管最近的父级 package.json。 在 “type”: “commonjs” 包中，Node.js 可以被指示将特定文件解释为 ES 模块，方法是使用 .mjs 扩展名命名它（因为 .js 和 .cjs 文件都被视为 “commonjs” 包中的 CommonJS）。.cjs 文件总是作为 CommonJS 加载，而不管最近的父级 package.json。 在 “type”: “module” 包中，Node.js 可以通过使用 .cjs 扩展名命名它来指示将特定文件解释为 CommonJS（因为 .js 和 .mjs 文件都被视为 “module” 包中的 ES 模块） –input-type 标志作为参数传给 –eval（或 -e），或通过 STDIN 管道传输到 node 的字符串 设置 –input-type=module 标志时被视为 ES 模块 设置 –input-type=commonjs 标志时被视为 ES 模块(未指定时的默认行为) 包的入口在包的 package.json 文件中，两个字段可以定义包的入口点：”main” 和 “exports”。 这两个字段都适用于 ES 模块和 CommonJS 模块入口点。对于针对当前支持的 Node.js 版本的新包，建议使用 “exports” 字段。对于支持 Node.js 10 及以下的包，”main” 字段是必需的。如果同时定义了 “exports” 和 “main”，则在支持的 Node.js 版本中，”exports” 字段优先于 “main”。 子路径的模式 12345678&#123; &quot;exports&quot;: &#123; &quot;./features/*.js&quot;: &quot;./src/features/*.js&quot; &#125;, &quot;imports&quot;: &#123; &quot;#internal/*.js&quot;: &quot;./src/internal/*.js&quot; &#125;&#125; /* 映射公开嵌套的子路径，因为它只是字符串替换语法，右侧 * 的所有实例都将替换为该值，包括它是否包含任何 / 分隔符。要从模式中排除私有子文件夹，可以使用 null 123456789101112131415161718import featureX from &#x27;es-module-package/features/x.js&#x27;;// 加载 ./node_modules/es-module-package/src/features/x.jsimport featureY from &#x27;es-module-package/features/y/y.js&#x27;;// 加载 ./node_modules/es-module-package/src/features/y/y.js&#123; &quot;exports&quot;: &#123; &quot;./features/*.js&quot;: &quot;./src/features/*.js&quot;, &quot;./features/private-internal/*&quot;: null &#125;&#125;import featureInternal from &#x27;es-module-package/features/private-internal/m.js&#x27;;// 抛出: ERR_PACKAGE_PATH_NOT_EXPORTEDimport featureX from &#x27;es-module-package/features/x.js&#x27;;// 加载 ./node_modules/es-module-package/src/features/x.js 条件导出从最具体到最不具体的顺序列出，因为应该定义条件： “node-addons” - 类似于 “node” 并匹配任何 Node.js 环境。 此条件可用于提供使用原生 C++ 插件的入口点，而不是更通用且不依赖原生插件的入口点。 可以通过 –no-addons 标志禁用此条件。 “node” - 匹配任何 Node.js 环境。 可以是 CommonJS 或 ES 模块文件。 在大多数情况下，不需要明确调用 Node.js 平台。 “import” - 当包通过 import 或 import()，或者通过 ECMAScript 模块加载器的任何顶层导入或解析操作加载时匹配。 无论目标文件的模块格式如何，都适用。 始终与 “require” 互斥。 “require” - 当包通过 require() 加载时匹配。 引用的文件应该可以用 require() 加载，尽管无论目标文件的模块格式如何，条件都匹配。 预期的格式包括 CommonJS、JSON 和原生插件，但不包括 ES 模块，因为 require() 不支持它们。 始终与 “import” 互斥。 “default” - 始终匹配的通用后备。 可以是 CommonJS 或 ES 模块文件。 此条件应始终放在最后。 在 “exports” 对象中，键顺序很重要。 在条件匹配过程中，较早的条目具有更高的优先级并优先于较晚的条目。 一般规则是条件应该按照对象顺序从最具体到最不具体。 社区条件定义 “types” - 类型系统可以使用它来解析给定导出的类型文件。 此条件应始终首先包含在内。 “deno” - 表示 Deno 平台的变体。 “browser” - 任何网络浏览器环境。 “development” - 可用于定义仅开发环境入口点，例如提供额外的调试上下文。 必须始终与 “production” 互斥。 “production” - 可用于定义生产环境入口点。 必须始终与 “development” 互斥。 使用名称来引用包在一个包中，包的 package.json “exports” 字段中定义的值可以通过包的名称引用。注意： 自引用仅在 package.json 具有 “exports” 时可用，并且只允许导入 “exports”（在 package.json 中）允许的内容。 在 ES 模块和 CommonJS 模块中使用 require 时也可以使用自引用。 自引用也适用于作用域包。 在避免或最小化危害的同时编写双包 每种模式都有权衡，但有两种广泛的方法可以满足以下条件： 该软件包可通过 require 和 import 使用。 该包在当前 Node.js 和不支持 ES 模块的旧版本 Node.js 中都可用。 包主入口点，例如 ‘pkg’ 可以被 require 用来解析 CommonJS 文件，也可以被 import 用来解析 ES 模块文件。 （对于导出的路径也是如此，例如 ‘pkg/feature’。） 该包提供命名导出，例如 import { name } from ‘pkg’ 而不是 import pkg from ‘pkg’; pkg.name。 该包可能在其他 ES 模块环境中可用，例如浏览器。 避免或最小化上一节中描述的危害。 双包编写方法 使用 ES 模块封装器在 CommonJS 中编写包或将 ES 模块源代码转换为 CommonJS，并创建定义命名导出的 ES 模块封装文件。 使用条件导出, import 使用 ES 模块封装器，require 使用 CommonJS 入口点。12345678910// ./node_modules/pkg/index.cjsexports.name = &#x27;value&#x27;;// ./node_modules/pkg/wrapper.mjsimport cjsModule from &#x27;./index.cjs&#x27;;export const name = cjsModule.name;import cjsModule from &#x27;./index.cjs&#x27;;export const name = cjsModule.name;export default cjsModule; 此方法适用于以下任何用例： 该包目前是用 CommonJS 编写的，作者不希望将其重构为 ES 模块语法，而是希望为 ES 模块使用者提供命名导出。 该包还有其他依赖它的包，最终用户可能会同时安装这个包和那些其他包。 比如 utilities 包直接在应用中使用，utilities-plus 包给 utilities 增加了一些功能。 因为封装器导出了底层的 CommonJS 文件，所以 utilities-plus 是用 CommonJS 还是 ES 模块语法编写的并不重要；无论哪种方式都可以。 包存储内部状态，包作者宁愿不重构包以隔离其状态管理。 请参阅下一章节。 此方法的变体不需要消费者有条件导出，可以添加一个导出，例如 “./module”，指向包的全 ES 模块语法版本。 如果用户确定 CommonJS 版本不会在应用程序的任何地方加载，例如通过依赖项，或者如果可以加载 CommonJS 版本但不影响 ES 模块版本（例如, 因为包是无状态的）： 12345678// ./node_modules/pkg/package.json&#123; &quot;type&quot;: &quot;module&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &quot;./index.cjs&quot;, &quot;./module&quot;: &quot;./wrapper.mjs&quot; &#125;&#125; 隔离状态 状态是一个问题的原因是因为包的 CommonJS 和 ES 模块版本都可能在应用程序中使用；例如，用户的应用程序代码可以 import ES 模块版本，而依赖项 require CommonJS 版本。 如果发生这种情况，包的两个副本将被加载到内存中，因此将出现两个不同的状态。 这可能会导致难以解决的错误。 除了编写无状态包（例如，如果 JavaScript 的 Math 是一个包，它将是无状态的，因为它的所有方法都是静态的），还有一些方法可以隔离状态，以便在可能加载的 CommonJS 和 ES 模块之间共享它包的实例：(1)如果可能，在实例化对象中包含所有状态。 比如 JavaScript 的 Date(2)在包的 CommonJS 和 ES 模块版本之间共享的一个或多个 CommonJS 文件中隔离状态。 比如 CommonJS 和 ES 模块入口点分别是 index.cjs 和 index.mjs： 123456789// ./node_modules/pkg/index.cjsconst state = require(&#x27;./state.cjs&#x27;);module.exports.state = state;// ./node_modules/pkg/index.mjsimport state from &#x27;./state.cjs&#x27;;export &#123; state&#125;; 此方法适用于以下任何用例： 该包目前是用 ES 模块语法编写的，包作者希望在支持此类语法的任何地方使用该版本。 包是无状态的，或者它的状态可以很容易地被隔离。 该包不太可能有其他依赖它的公共包，或者如果有，则该包是无状态的，或者具有不需要在依赖项之间或与整个应用程序共享的状态。 即使处于隔离状态，在 CommonJS 和 ES 模块版本之间仍然存在可能执行额外代码的成本。 与之前的方法一样，这种方法的变体不需要消费者有条件的导出，可以添加一个导出，例如 “./module”，指向包的全 ES 模块语法版本"},{"title":"nodejs基础知识(11)","date":"2023-01-25T10:45:46.000Z","updated":"2023-07-24T09:24:46.500Z","comments":true,"path":"nodejs/nodejs-note-21.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-21.html","excerpt":"","text":"net 网络node:net 模块在 Windows 上使用命名管道支持 IPC，在其他操作系统上则使用 Unix 域套接字。 在 Unix 上，本地域也称为 Unix 域。 路径是文件系统路径名。 它被截断为与操作系统相关的 sizeof(sockaddr_un.sun_path) - 1 长度。 典型的值为 Linux 上的 107 字节和 macOS 上的 103 字节。 在 Windows 上，本地域是使用命名管道实现的。 路径必须引用 \\?\\pipe\\ 或 \\.\\pipe\\ 中的条目。管道不会持续存在。 当对它们的最后一个引用关闭时，它们将被删除。 与 Unix 域套接字不同，Windows 将在拥有进程退出时关闭并删除管道。 JavaScript 字符串转义需要使用额外的反斜杠转义来指定路径，例如： 1net.createServer().listen(path.join(&#x27;\\\\\\\\?\\\\pipe&#x27;, process.cwd(), &#x27;myctl&#x27;)); net.Server 类‘drop’ 事件当连接数达到 server.maxConnections 的阈值时，服务器将丢弃新的连接并触发 ‘drop’ 事件。 server.close([callback])停止服务器接受新连接并保持现有连接。 该函数是异步的，当所有连接都结束并且服务器触发 ‘close’ 事件时，则服务器最终关闭。 一旦 ‘close’ 事件发生，则可选的 callback 将被调用。 与该事件不同，如果服务器在关闭时未打开，它将以 Error 作为唯一参数被调用。????? server.listen()当且仅当在第一次调用 server.listen() 期间出现错误或调用 server.close() 时，才能再次调用 server.listen() 方法。 否则，将抛出 ERR_SERVER_ALREADY_LISTEN 错误。监听时最常见的错误之一是 EADDRINUSE。 当另一个服务器已经在监听请求的 port/path/handle 时会发生这种情况。 处理此问题的方法之一是在一定时间后重试： 123456789server.on(&#x27;error&#x27;, (e) =&gt; &#123; if (e.code === &#x27;EADDRINUSE&#x27;) &#123; console.log(&#x27;Address in use, retrying...&#x27;); setTimeout(() =&gt; &#123; server.close(); server.listen(PORT, HOST); &#125;, 1000); &#125;&#125;); server.maxConnections设置此属性以在服务器的连接计数变高时拒绝连接。一旦套接字已发送给具有 child_process.fork() 的子进程，则不建议使用此选项。 server.ref()与 unref() 相反，如果它是唯一剩下的服务器（默认行为），则在以前的 unref 的服务器上调用 ref() 不会让程序退出。 如果服务器被 ref，则再次调用 ref() 将无效。 server.unref()如果服务器是事件系统中唯一的活动服务器，则在服务器上调用 unref() 将允许程序退出。 如果服务器已经被 unref，则再次调用 unref() 将无效。 net.Socket 类此类是 TCP 套接字或流式 IPC 端点（在 Windows 上使用命名管道，否则使用 Unix 域套接字）的抽象。 它也是 EventEmitter。net.Socket 可以由用户创建并直接用于与服务器交互。它也可以由 Node.js 创建并在接收到连接时传给用户。 ‘timeout’ 事件如果套接字因不活动而超时则触发。 这只是通知套接字已空闲。 用户必须手动关闭连接。 socket.end([data[, encoding]][, callback]) data | | encoding 仅当数据为 string 时使用。 默认值: ‘utf8’。 callback 套接字完成时的可选回调。半关闭套接字。 即，它发送一个 FIN 数据包。 服务器可能仍会发送一些数据。 socket.pause()暂停读取数据。 也就是说，不会触发 ‘data’ 事件。 用于限制上传。 socket.pending如果套接字尚未连接，则为 true，要么是因为 .connect() 尚未被调用，要么是因为它仍在连接过程中 socket.resume()调用 socket.pause() 后继续读取。 socket.setNoDelay([noDelay]) noDelay 默认值: true启用/禁用 Nagle 算法的使用。创建 TCP 连接时，它将启用 Nagle 算法。Nagle 的算法在数据通过网络发送之前延迟数据。 它试图以延迟为代价来优化吞吐量。为 noDelay 传入 true 或不传入参数将禁用套接字的 Nagle 算法。 为 noDelay 传入 false 将启用 Nagle 的算法。 socket.setTimeout(timeout[, callback]) timeout callback 将套接字设置为在套接字上 timeout 毫秒不活动后超时。 默认情况下 net.Socket 没有超时。当空闲超时被触发时，套接字将收到 ‘timeout’ 事件，但连接不会被切断。 用户必须手动调用 socket.end() 或 socket.destroy() 才能结束连接。 socket.readyState此属性将连接状态表示为字符串。 如果流正在连接，则 socket.readyState 是 opening。 如果流可读可写，则为 open。 如果流可读不可写，则为 readOnly。 如果流不可读写，则为 writeOnly。 net.connect() net.createConnection() 的别名。 net.createConnection() 工厂函数，其创建新的 net.Socket，并立即使用 socket.connect() 发起连接，然后返回启动连接的 net.Socket。 建立连接后，将在返回的套接字上触发 ‘connect’ 事件。 最后一个参数 connectListener（如果提供）将作为 ‘connect’ 事件的监听器添加一次。 net.createConnection(path[, connectListener]) 发起 IPC 连接 net.createConnection(port[, host][, connectListener]) 发起 TCP 连接 net.createServer([options][, connectionListener]) 如果 allowHalfOpen 设置为 true，则当套接字的另一端发出传输结束信号时，服务器仅在显式调用 socket.end() 时才发回传输结束。 例如，在 TCP 上下文中，当接收到 FIN 数据包时，只有在显式调用 socket.end() 时才会发送回 FIN 数据包。 在此之前，连接是半关闭的（不可读但仍可写）。 如果 pauseOnConnect 设置为 true，则与每个传入连接关联的套接字将被暂停，并且不会从其句柄读取数据。 这允许在进程之间传递连接，而原始进程不会读取任何数据。 要开始从暂停的套接字读取数据，则调用 socket.resume()。 net.isIP(input) 如果 input 是 IPv6 地址，则返回 6。 如果 input 是点十进制表示法中没有前导零的 IPv4 地址，则返回 4。 否则，返回 0。 net.isIPv4(input) 如果 input 是点十进制表示法中没有前导零的 IPv4 地址，则返回 true。 否则，返回 false。 net.isIPv6(input) 如果 input 是 IPv6 地址，则返回 true。 否则，返回 false。 os 操作系统os.EOL 操作系统特定的行尾标记。POSIX 上是 \\nWindows 上是 \\r\\n os.arch()返回为其编译 Node.js 二进制文件的操作系统 CPU 架构。 可能的值为 ‘arm’、’arm64’、’ia32’、’mips’、’mipsel’、’ppc’、’ppc64’、’s390’、’s390x’、以及 ‘x64’。返回值相当于 process.arch os.constants包含用于错误码、进程信号等的常用操作系统特定常量。 定义的特定常量在操作系统常量中描述。 os.cpus()返回包含有关每个逻辑 CPU 内核的信息的对象数组。每个对象上包含的属性包括： model speed （以兆赫为单位） times user CPU 在用户模式下花费的毫秒数。 nice CPU 在良好模式下花费的毫秒数。 sys CPU 在系统模式下花费的毫秒数。 idle CPU 在空闲模式下花费的毫秒数。 irq CPU 在中断请求模式下花费的毫秒数。 nice 值仅适用于 POSIX。 在 Windows 上，所有处理器的 nice 值始终为 0。 os.devNull空设备的特定于平台的文件路径。Windows 上是 \\.\\nulPOSIX 上是 /dev/null os.endianness()返回标识为其编译 Node.js 二进制文件的 CPU 的字节序的字符串。可能的值是大端序的 ‘BE’ 和小端序的 ‘LE’。 os.freemem()以整数形式返回空闲的系统内存量（以字节为单位）。 os.homedir()返回当前用户的主目录的字符串路径。 在 POSIX 上，它使用 $HOME 环境变量（如果已定义）。 否则，它使用有效的 UID 来查找用户的主目录。 在 Windows 上，它使用 USERPROFILE 环境变量（如果已定义）。 否则，它使用当前用户的配置文件目录的路径。 os.loadavg()返回包含 1、5 和 15 分钟平均负载的数组。平均负载是操作系统计算的系统活动量度，并表示为小数。平均负载是 Unix 特有的概念。 在 Windows 上，返回值始终为 [0, 0, 0]。 os.networkInterfaces()返回包含已分配网络地址的网络接口的对象。返回对象上的每个键都标识一个网络接口。 关联的值是每个对象描述一个分配的网络地址的对象数组。分配的网络地址对象上可用的属性包括： address 分配的 IPv4 或 IPv6 地址 netmask IPv4 或 IPv6 网络掩码 family IPv4 或 IPv6 mac 网络接口的 MAC 地址 internal 如果网络接口是不能远程访问的环回或类似接口，则为 true；否则为 false scopeid 数字的 IPv6 范围 ID（仅在 family 为 IPv6 时指定） cidr 使用 CIDR 表示法的路由前缀分配的 IPv4 或 IPv6 地址。 如果 netmask 无效，则此属性设置为 null。 os.platform()返回标识为其编译 Node.js 二进制文件的操作系统平台的字符串。 该值在编译时设置。 可能的值为 ‘aix’、’darwin’、’freebsd’、’linux’、’openbsd’、’sunos’、以及 ‘win32’。返回值相当于 process.platform。如果 Node.js 是在安卓操作系统上构建的，则也可能返回值 ‘android’。 安卓支持是实验的。 os.release()以字符串形式返回操作系统。在 POSIX 系统上，操作系统版本是通过调用 uname(3) 来确定的。 在 Windows 上，使用 GetVersionExW()。 os.setPriority([pid, ]priority) pid 要为其设置调度优先级的进程 ID。 默认值: 0。 priority 分配给进程的调度优先级。尝试为 pid 指定的进程设置调度优先级。 如果未提供 pid 或为 0，则使用当前进程的进程 ID。priority 输入必须是 -20（高优先级）和 19（低优先级）之间的整数。 由于 Unix 优先级和 Windows 优先级之间的差异，priority 映射到 os.constants.priority 中的六个优先级常量之一。 当检索进程优先级时，此范围映射可能会导致返回值在 Windows 上略有不同。 为避免混淆，请将 priority 设置为优先级常量之一。 在 Windows 上，将优先级设置为 PRIORITY_HIGHEST 需要提升用户权限。 否则设置的优先级将被静默地降低到 PRIORITY_HIGH。 os.tmpdir()以字符串形式返回操作系统默认的临时文件的目录。 os.totalmem()以整数形式返回系统内存总量（以字节为单位）。 os.type()返回 uname(3) 返回的操作系统名称。 例如，它在 Linux 上返回 ‘Linux’，在 macOS 上返回 ‘Darwin’，在 Windows 上返回 ‘Windows_NT’。 s.userInfo([options]) options encoding 用于解释结果字符串的字符编码。 如果 encoding 设置为 ‘buffer’，则 username、shell 和 homedir 的值将是 Buffer 实例。 默认值: ‘utf8’。返回有关当前有效用户的信息。 在 POSIX 平台上，这通常是密码文件的子集。 返回的对象包括 username、uid、gid、shell 和 homedir。 在 Windows 上，uid 和 gid 字段是 -1，而 shell 是 null。os.userInfo() 返回的 homedir 的值由操作系统提供。 这与 os.homedir() 的结果不同，后者在回退到操作系统响应之前查询主目录的环境变量。如果用户没有 username 或 homedir，则抛出 SystemError。 path 路径Windows 与 POSIX 的对比node:path 模块的默认操作因运行 Node.js 应用程序的操作系统而异。 具体来说，当在 Windows 操作系统上运行时，node:path 模块将假定正在使用 Windows 风格的路径。 因此，在 POSIX 和 Windows 上使用 path.basename() 可能会产生不同的结果： 在 POSIX 上：12path.basename(&#x27;C:\\\\temp\\\\myfile.html&#x27;);// 返回: &#x27;C:\\\\temp\\\\myfile.html&#x27; 在 Windows 上：12path.basename(&#x27;C:\\\\temp\\\\myfile.html&#x27;);// 返回: &#x27;myfile.html&#x27; 当使用 Windows 文件路径时，若要在任何操作系统上获得一致的结果，则使用 path.win32 在 POSIX 和 Windows 上：12path.win32.basename(&#x27;C:\\\\temp\\\\myfile.html&#x27;);// 返回: &#x27;myfile.html&#x27; 当使用 POSIX 文件路径时，若要在任何操作系统上获得一致的结果，则使用 path.posix 在 POSIX 和 Windows 上：12path.posix.basename(&#x27;/tmp/myfile.html&#x27;);// 返回: &#x27;myfile.html&#x27; 在 Windows 上，Node.js 遵循独立驱动器工作目录的概念。 当使用不带反斜杠的驱动器路径时，可以观察到此行为。 例如，path.resolve(‘C:\\‘) 可能返回与 path.resolve(‘C:’) 不同的结果。 path.basename(path[, ext])path.basename() 方法返回 path 的最后一部分，类似于 Unix basename 命令。 尾随的目录分隔符被忽略，见 path.sep。 12345path.basename(&#x27;/foo/bar/baz/asdf/quux.html&#x27;);// 返回: &#x27;quux.html&#x27;path.basename(&#x27;/foo/bar/baz/asdf/quux.html&#x27;, &#x27;.html&#x27;);// 返回: &#x27;quux&#x27; 尽管 Windows 通常以不区分大小写的方式处理文件名（包括文件扩展名），但此函数不会。例如，C:\\foo.html 和 C:\\foo.HTML 指的是同一个文件，但 basename 将扩展名视为区分大小写的字符串： 12345path.win32.basename(&#x27;C:\\\\foo.html&#x27;, &#x27;.html&#x27;);// 返回: &#x27;foo&#x27;path.win32.basename(&#x27;C:\\\\foo.HTML&#x27;, &#x27;.html&#x27;);// 返回: &#x27;foo.HTML&#x27; 如果 path 不是字符串，或者如果给定 ext 并且不是字符串，则抛出 TypeError。 path.delimiter提供特定于平台的路径定界符： ; 用于 Windows : 用于 POSIX例如，在 POSIX 上：123456789101112console.log(process.env.PATH);// 打印: &#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&#x27;process.env.PATH.split(path.delimiter);// 返回: [&#x27;/usr/bin&#x27;, &#x27;/bin&#x27;, &#x27;/usr/sbin&#x27;, &#x27;/sbin&#x27;, &#x27;/usr/local/bin&#x27;]&lt;!-- 在 Windows 上： --&gt;console.log(process.env.PATH);// 打印: &#x27;C:\\Windows\\system32;C:\\Windows;C:\\Program Files\\node\\&#x27;process.env.PATH.split(path.delimiter);// 返回: [&#x27;C:\\\\Windows\\\\system32&#x27;, &#x27;C:\\\\Windows&#x27;, &#x27;C:\\\\Program Files\\\\node\\\\&#x27;] path.dirname(path)path.dirname() 方法返回 path 的目录名，类似于 Unix dirname 命令。 尾随的目录分隔符被忽略，见 path.sep。12path.dirname(&#x27;/foo/bar/baz/asdf/quux&#x27;);// 返回: &#x27;/foo/bar/baz/asdf&#x27; 如果 path 不是字符串，则抛出 TypeError。 path.extname(path)path.extname() 方法返回 path 的扩展名，即 path 的最后一部分中从最后一次出现的 .（句点）字符到字符串的结尾。 如果 path 的最后一部分中没有 .，或者除了 path 的基本名称（参见 path.basename()）的第一个字符之外没有 . 个字符，则返回空字符串。 1234567891011121314151617path.extname(&#x27;index.html&#x27;);// 返回: &#x27;.html&#x27;path.extname(&#x27;index.coffee.md&#x27;);// 返回: &#x27;.md&#x27;path.extname(&#x27;index.&#x27;);// 返回: &#x27;.&#x27;path.extname(&#x27;index&#x27;);// 返回: &#x27;&#x27;path.extname(&#x27;.index&#x27;);// 返回: &#x27;&#x27;path.extname(&#x27;.index.md&#x27;);// 返回: &#x27;.md&#x27; 如果 path 不是字符串，则抛出 TypeError。 path.format(pathObject)pathObject 任何具有以下属性的 JavaScript 对象： dir root base name ext path.format() 方法从对象返回路径字符串。 这与 path.parse() 相反。 当向 pathObject 提供属性时，存在一个属性优先于另一个属性的组合：如果提供 pathObject.dir，则忽略 pathObject.root如果 pathObject.base 存在，则忽略 pathObject.ext 和 pathObject.name例如，在 POSIX 上： 123456789101112131415161718192021222324252627// 如果提供 `dir`、`root` 和 `base`，// 则将返回 `$&#123;dir&#125;$&#123;path.sep&#125;$&#123;base&#125;`。// `root` 将被忽略。path.format(&#123; root: &#x27;/ignored&#x27;, dir: &#x27;/home/user/dir&#x27;, base: &#x27;file.txt&#x27;&#125;);// 返回: &#x27;/home/user/dir/file.txt&#x27;// 如果未指定 `dir`，则将使用 `root`。// 如果仅提供 `root` 或 `dir` 等于 `root`，则将不包括平台分隔符。// `ext` 将被忽略。path.format(&#123; root: &#x27;/&#x27;, base: &#x27;file.txt&#x27;, ext: &#x27;ignored&#x27;&#125;);// 返回: &#x27;/file.txt&#x27;// 如果未指定 `base`，则将使用 `name` + `ext`。path.format(&#123; root: &#x27;/&#x27;, name: &#x27;file&#x27;, ext: &#x27;.txt&#x27;&#125;);// 返回: &#x27;/file.txt&#x27; 在 Windows 上： 12345path.format(&#123; dir: &#x27;C:\\\\path\\\\dir&#x27;, base: &#x27;file.txt&#x27;&#125;);// 返回: &#x27;C:\\\\path\\\\dir\\\\file.txt&#x27; path.isAbsolute(path)path.isAbsolute() 方法确定 path 是否为绝对路径。如果给定的 path 是零长度字符串，则将返回 false。例如，在 POSIX 上： 1234path.isAbsolute(&#x27;/foo/bar&#x27;); // truepath.isAbsolute(&#x27;/baz/..&#x27;); // truepath.isAbsolute(&#x27;qux/&#x27;); // falsepath.isAbsolute(&#x27;.&#x27;); // false 在 Windows 上： 1234567path.isAbsolute(&#x27;//server&#x27;); // truepath.isAbsolute(&#x27;\\\\\\\\server&#x27;); // truepath.isAbsolute(&#x27;C:/foo/..&#x27;); // truepath.isAbsolute(&#x27;C:\\\\foo\\\\..&#x27;); // truepath.isAbsolute(&#x27;bar\\\\baz&#x27;); // falsepath.isAbsolute(&#x27;bar/baz&#x27;); // falsepath.isAbsolute(&#x27;.&#x27;); // false 如果 path 不是字符串，则抛出 TypeError。 path.join([…paths])…paths 路径片段的序列返回: path.join() 方法使用特定于平台的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。零长度的 path 片段被忽略。 如果连接的路径字符串是零长度字符串，则将返回 ‘.’，表示当前工作目录。 12345path.join(&#x27;/foo&#x27;, &#x27;bar&#x27;, &#x27;baz/asdf&#x27;, &#x27;quux&#x27;, &#x27;..&#x27;);// 返回: &#x27;/foo/bar/baz/asdf&#x27;path.join(&#x27;foo&#x27;, &#123;&#125;, &#x27;bar&#x27;);// 抛出 &#x27;TypeError: Path must be a string. Received &#123;&#125;&#x27; 如果任何路径片段不是字符串，则抛出 TypeError。 path.normalize(path)path.normalize() 方法规范化给定的 path，解析 ‘..’ 和 ‘.’ 片段。当找到多个连续的路径片段分隔符（例如 POSIX 上的 / 和 Windows 上的 \\ 或 /）时，则它们将被平台特定路径片段分隔符（POSIX 上的 / 和 Windows 上的 \\）的单个实例替换。 保留尾随的分隔符。如果 path 是零长度字符串，则返回 ‘.’，表示当前工作目录。 12345678910&lt;!-- 例如，在 POSIX 上： --&gt;path.normalize(&#x27;/foo/bar//baz/asdf/quux/..&#x27;);// 返回: &#x27;/foo/bar/baz/asdf&#x27;&lt;!-- 在 Windows 上： --&gt;path.normalize(&#x27;C:\\\\temp\\\\\\\\foo\\\\bar\\\\..\\\\&#x27;);// 返回: &#x27;C:\\\\temp\\\\foo\\\\&#x27;&lt;!-- 由于 Windows 识别多个路径分隔符，两个分隔符都将被 Windows 首选分隔符 (\\) 的实例替换： --&gt;path.win32.normalize(&#x27;C:////temp\\\\\\\\/\\\\/\\\\/foo/bar&#x27;);// 返回: &#x27;C:\\\\temp\\\\foo\\\\bar&#x27; 如果 path 不是字符串，则抛出 TypeError。 path.parse(path)path.parse() 方法返回一个对象，其属性表示 path 的重要元素。 尾随的目录分隔符被忽略，见 path.sep。 返回的对象将具有以下属性： dir root base name ext 1234567891011121314151617181920212223242526272829303132&lt;!-- 例如，在 POSIX 上： --&gt;path.parse(&#x27;/home/user/dir/file.txt&#x27;);// 返回:// &#123; root: &#x27;/&#x27;,// dir: &#x27;/home/user/dir&#x27;,// base: &#x27;file.txt&#x27;,// ext: &#x27;.txt&#x27;,// name: &#x27;file&#x27; &#125;┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │&quot; / home/user/dir / file .txt &quot;└──────┴──────────────┴──────┴─────┘(&quot;&quot; 行中的所有空格都应被忽略。它们纯粹是为了格式化。)&lt;!-- 在 Windows 上： --&gt;path.parse(&#x27;C:\\\\path\\\\dir\\\\file.txt&#x27;);// 返回:// &#123; root: &#x27;C:\\\\&#x27;,// dir: &#x27;C:\\\\path\\\\dir&#x27;,// base: &#x27;file.txt&#x27;,// ext: &#x27;.txt&#x27;,// name: &#x27;file&#x27; &#125;┌─────────────────────┬────────────┐│ dir │ base │├──────┬ ├──────┬─────┤│ root │ │ name │ ext │&quot; C:\\ path\\dir \\ file .txt &quot;└──────┴──────────────┴──────┴─────┘(&quot;&quot; 行中的所有空格都应被忽略。它们纯粹是为了格式化。) 如果 path 不是字符串，则抛出 TypeError。 path.posixpath.posix 属性提供对 path 方法的 POSIX 特定实现的访问。API 可通过 require(‘node:path’).posix 或 require(‘node:path/posix’) 访问。 path.relative(from, to)path.relative() 方法根据当前工作目录返回从 from 到 to 的相对路径。 如果 from 和 to 都解析为相同的路径（在分别调用 path.resolve() 之后），则返回零长度字符串。如果零长度字符串作为 from 或 to 传入，则将使用当前工作目录而不是零长度字符串。 12345678&lt;!-- 例如，在 POSIX 上： --&gt;path.relative(&#x27;/data/orandea/test/aaa&#x27;, &#x27;/data/orandea/impl/bbb&#x27;);// 返回: &#x27;../../impl/bbb&#x27;&lt;!-- 在 Windows 上： --&gt;path.relative(&#x27;C:\\\\orandea\\\\test\\\\aaa&#x27;, &#x27;C:\\\\orandea\\\\impl\\\\bbb&#x27;);// 返回: &#x27;..\\\\..\\\\impl\\\\bbb&#x27; 如果 from 或 to 不是字符串，则抛出 TypeError。 path.resolve([…paths])path.resolve() 方法将路径或路径片段的序列解析为绝对路径。给定的路径序列从右到左处理，每个后续的 path 会被追加到前面，直到构建绝对路径。 例如，给定路径片段的序列：/foo、/bar、baz，调用 path.resolve(‘/foo’, ‘/bar’, ‘baz’) 将返回 /bar/baz，因为 ‘baz’ 不是绝对路径，而 ‘/bar’ + ‘/‘ + ‘baz’ 是。如果在处理完所有给定的 path 片段之后，还没有生成绝对路径，则使用当前工作目录。生成的路径被规范化，并删除尾部斜杠（除非路径解析为根目录）。零长度的 path 片段被忽略。如果没有传入 path 片段，则 path.resolve() 将返回当前工作目录的绝对路径。 123456789path.resolve(&#x27;/foo/bar&#x27;, &#x27;./baz&#x27;);// 返回: &#x27;/foo/bar/baz&#x27;path.resolve(&#x27;/foo/bar&#x27;, &#x27;/tmp/file/&#x27;);// 返回: &#x27;/tmp/file&#x27;path.resolve(&#x27;wwwroot&#x27;, &#x27;static_files/png/&#x27;, &#x27;../gif/image.gif&#x27;);// 如果当前工作目录是 /home/myself/node，// 则返回 &#x27;/home/myself/node/wwwroot/static_files/gif/image.gif&#x27; 如果任何参数不是字符串，则抛出 TypeError。 path.sep提供特定于平台的路径片段分隔符： Windows 上是 \\ POSIX 上是 /12345678例如，在 POSIX 上：&#x27;foo/bar/baz&#x27;.split(path.sep);// 返回: [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;]在 Windows 上：&#x27;foo\\\\bar\\\\baz&#x27;.split(path.sep);// 返回: [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;] 在 Windows 上，正斜杠 (/) 和反斜杠 () 都被接受作为路径片段分隔符；但是，path 方法只添加反斜杠 ()。 path.toNamespacedPath(path)仅在 Windows 系统上，返回给定 path 的等效命名空间前缀路径。 如果 path 不是字符串，则 path 将不加修改地返回。此方法仅在 Windows 系统上有意义。 在 POSIX 系统上，该方法是不可操作的，并且始终返回 path 而不进行修改。 path.win32path.win32 属性提供对 path 方法的 Windows 特定实现的访问。API 可通过 require(‘node:path’).win32 或 require(‘node:path/win32’) 访问。"},{"title":"nodejs基础知识(14)","date":"2023-03-05T12:23:34.000Z","updated":"2023-07-24T09:24:46.502Z","comments":true,"path":"nodejs/nodejs-note-24.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-24.html","excerpt":"","text":"readline 逐行读取InterfaceConstructor 类InterfaceConstructor 类的实例是使用 readlinePromises.createInterface() 或 readline.createInterface() 方法构造的。 每个实例都与单个 input 可读流和单个 output 可写流相关联。 output 流用于打印到达并从 input 流中读取的用户输入的提示。 ‘close’ 事件发生以下情况之一时会触发 ‘close’ 事件： rl.close() 方法被调用，InterfaceConstructor 实例放弃了对 input 和 output 流的控制； input 流接收到它的 ‘end’ 事件； input 流接收 Ctrl+D 以发出传输结束（EOT）的信号； input 流接收 Ctrl+C 以发出 SIGINT 信号，并且在 InterfaceConstructor 实例上没有注册 ‘SIGINT’ 事件监听器。 调用监听器函数时不传入任何参数。一旦触发 ‘close’ 事件，则 InterfaceConstructor 实例就完成了。 ‘line’ 事件每当 input 流接收到行尾输入（\\n、\\r 或 \\r\\n）时，则会触发 ‘line’ 事件。 这通常发生在用户按下 回车 或 返回 时。如果从流中读取了新数据并且该流在没有最终行尾标记的情况下结束，也会触发 ‘line’ 事件。使用包含单行接收输入的字符串调用监听器函数。 ‘history’ 事件每当历史数组发生更改时，则会触发 ‘history’ 事件。使用包含历史数组的数组调用监听器函数。 它将反映由于 historySize 和 removeHistoryDuplicates 引起的所有更改、添加的行和删除的行。主要目的是允许监听器保留历史记录。 监听器也可以更改历史对象。 这可能有助于防止将某些行添加到历史记录中，例如密码。 ‘resume’ 事件每当 input 流恢复时，则会触发 ‘resume’ 事件。调用监听器函数时不传入任何参数。 ‘SIGCONT’ 事件当之前使用 Ctrl+Z（即 SIGTSTP）移动到后台的 Node.js 进程然后使用 fg(1p) 返回到前台时，则会触发 ‘SIGCONT’ 事件。如果 input 流在 SIGTSTP 请求之前暂停，则不会触发此事件。Windows 不支持 ‘SIGCONT’ 事件。 ‘SIGINT’ 事件每当 input 流接收到 Ctrl+C 输入（通常称为 SIGINT）时，则会触发 ‘SIGINT’ 事件。 如果在 input 流接收到 SIGINT 时没有注册 ‘SIGINT’ 事件监听器，则将触发 ‘pause’ 事件。 rl.close()rl.close() 方法关闭 InterfaceConstructor 实例并放弃对 input 和 output 流的控制。 当调用时，将触发 ‘close’ 事件。调用 rl.close() 不会立即阻止其他由 InterfaceConstructor 实例触发的事件（包括 ‘line’）。 rl.pause()rl.pause() 方法暂停 input 流，允许它稍后在必要时恢复。调用 rl.pause() 不会立即暂停其他由 InterfaceConstructor 实例触发的事件（包括 ‘line’）。 rl.prompt([preserveCursor])preserveCursor 如果为 true，则防止光标位置重置为 0。rl.prompt() 方法将配置为 prompt 的 InterfaceConstructor 实例写入 output 中的新行，以便为用户提供用于提供输入的新位置。当调用时，如果 rl.prompt() 流已暂停，则 rl.prompt() 将恢复 input 流。如果 InterfaceConstructor 是在 output 设置为 null 或 undefined 的情况下创建的，则不会写入提示。 rl.question(query[, options], callback)query 要写入 output 的语句或查询，位于提示之前。options signal 可选择允许使用 AbortController 取消 question()。callback 使用用户输入调用的回调函数以响应 query。rl.question() 方法通过将 query 写入 output 来显示 query，等待在 input 上提供用户输入，然后调用 callback 函数，将提供的输入作为第一个参数传入。 当调用时，如果 rl.question() 流已暂停，则 rl.question() 将恢复 input 流。如果 InterfaceConstructor 是在 output 设置为 null 或 undefined 的情况下创建的，则不会写入 query。传给 rl.question() 的 callback 函数不遵循接受 Error 对象或 null 作为第一个参数的典型模式。 以提供的答案作为唯一参数调用 callback。在 rl.close() 之后调用 rl.question() 会报错。 rl.resume()如果 input 流已暂停，则 rl.resume() 方法会恢复该流。 rl.setPrompt(prompt)rl.setPrompt() 方法设置了在调用 rl.prompt() 时将写入 output 的提示。 rl.getPrompt()rl.getPrompt() 方法返回 rl.prompt() 使用的当前提示。 rl.write(data[, key])data key ctrl true 表示 Ctrl 键。 meta true 表示 Meta 键。 shift true 表示 Shift 键。 name 键的名称。rl.write() 方法会将 data 或由 key 标识的键序列写入 output。 仅当 output 是 TTY 文本终端时才支持 key 参数。如果指定了 key，则忽略 data。当调用时，如果 rl.write() 流已暂停，则 rl.write() 将恢复 input 流。 如果 InterfaceConstructor 是在 output 设置为 null 或 undefined 的情况下创建的，则不会写入 data 和 key。rl.write() 方法将数据写入 readline Interface 的 input，就好像它是由用户提供的一样。 rlSymbol.asyncIterator创建 AsyncIterator 对象，该对象遍历输入流中的每一行作为字符串。 此方法允许通过 for await…of 循环异步迭代 InterfaceConstructor 对象。输入流中的错误不会被转发。如果循环以 break、throw 或 return 终止，则将调用 rl.close()。 换句话说，迭代 InterfaceConstructor 将始终完全消费输入流。性能无法与传统的 ‘line’ 事件 API 相提并论。 对于性能敏感的应用程序，请改用 ‘line’。readline.createInterface() 将在调用后开始使用输入流。 在接口创建和异步迭代之间进行异步操作可能会导致丢失行。 Promises API readlinePromises.Interface 类readlinePromises.Interface 类的实例是使用 readlinePromises.createInterface() 方法构造的。 每个实例都与单个 input 可读流和单个 output 可写流相关联。 output 流用于打印到达并从 input 流中读取的用户输入的提示。 rl.question(query[, options])query 要写入 output 的语句或查询，位于提示之前。options signal 可选择允许使用 AbortSignal 取消 question()。返回: 使用用户响应 query 的输入履行的 promise。 其他特性与rl.question(query[, options], callback)类似 readlinePromises.Readline 类 new readlinePromises.Readline(stream[, options])stream &lt;stream.Writable&gt; TTY 流。options autoCommit 如果是 true，则不需要调用 rl.commit()。 rl.clearLine(dir)dir -1: 从光标向左1: 从光标向右0: 整行rl.clearLine() 方法在待处理动作的内部列表中添加一个动作，该动作在 dir 标识的指定方向上清除关联 stream 的当前行。 调用 rl.commit() 看看这个方法的效果，除非 autoCommit: true 传给了构造函数。 rl.clearScreenDown()rl.clearScreenDown() 方法向待处理动作的内部列表添加一个动作，该动作从光标向下的当前位置清除关联流。 rl.commit()rl.commit() 方法将所有待处理的操作发送到关联的 stream 并清除待处理操作的内部列表。 rl.rollback()rl.rollback 方法清除内部待处理操作列表，而不将其发送到关联的 stream。 readlinePromises.createInterface(options) completer 函数的使用completer 函数将用户输入的当前行作为参数，并返回包含 2 个条目的 Array： 使用匹配条目的 Array 补全。 用于匹配的子字符串。completer 函数也可以返回 ，或者是异步的 Callback APIreadline.Interface 类继承自: &lt;readline.InterfaceConstructor&gt;readline.Interface 类的实例是使用 readline.createInterface() 方法构造的。 每个实例都与单个 input 可读流和单个 output 可写流相关联。 output 流用于打印到达并从 input 流中读取的用户输入的提示。 示例：微型 CLI下面的例子说明了使用 readline.Interface 类来实现一个微型的命令行界面： 1234567891011121314151617181920212223const readline = require(&#x27;node:readline&#x27;);const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout, prompt: &#x27;OHAI&gt; &#x27;&#125;);rl.prompt();rl.on(&#x27;line&#x27;, (line) =&gt; &#123; switch (line.trim()) &#123; case &#x27;hello&#x27;: console.log(&#x27;world!&#x27;); break; default: console.log(`Say what? I might have heard &#x27;$&#123;line.trim()&#125;&#x27;`); break; &#125; rl.prompt();&#125;).on(&#x27;close&#x27;, () =&gt; &#123; console.log(&#x27;Have a great day!&#x27;); process.exit(0);&#125;); 示例：逐行读取文件流readline 的一个常见用例是每次一行地消费输入文件。 最简单的方式是利用 fs.ReadStream API 和 for await…of 循环： 12345678910111213141516171819const fs = require(&#x27;node:fs&#x27;);const readline = require(&#x27;node:readline&#x27;);async function processLineByLine() &#123; const fileStream = fs.createReadStream(&#x27;input.txt&#x27;); const rl = readline.createInterface(&#123; input: fileStream, crlfDelay: Infinity &#125;); // 注意：使用 crlfDelay 选项 // 将 input.txt 中的所有 CR LF (&#x27;\\r\\n&#x27;) 实例识别为单个换行符。 for await (const line of rl) &#123; // input.txt 中的每一行都将在此处作为 `line` 连续可用。 console.log(`Line from file: $&#123;line&#125;`); &#125;&#125;processLineByLine(); 或者，可以使用 ‘line’ 事件： 1234567891011const fs = require(&#x27;node:fs&#x27;);const readline = require(&#x27;node:readline&#x27;);const rl = readline.createInterface(&#123; input: fs.createReadStream(&#x27;sample.txt&#x27;), crlfDelay: Infinity&#125;);rl.on(&#x27;line&#x27;, (line) =&gt; &#123; console.log(`Line from file: $&#123;line&#125;`);&#125;); 目前，for await…of 循环可能会慢一点。 如果 async / await 流量和速度都必不可少，则可以应用混合方法： 12345678910111213141516171819202122const &#123; once &#125; = require(&#x27;node:events&#x27;);const &#123; createReadStream &#125; = require(&#x27;node:fs&#x27;);const &#123; createInterface &#125; = require(&#x27;node:readline&#x27;);(async function processLineByLine() &#123; try &#123; const rl = createInterface(&#123; input: createReadStream(&#x27;big-file.txt&#x27;), crlfDelay: Infinity &#125;); rl.on(&#x27;line&#x27;, (line) =&gt; &#123; // 处理行。 &#125;); await once(rl, &#x27;close&#x27;); console.log(&#x27;File processed.&#x27;); &#125; catch (err) &#123; console.error(err); &#125;&#125;)(); stream 流流的类型Node.js 中有四种基本的流类型： Writable: 可以写入数据的流（例如，fs.createWriteStream()）。 Readable: 可以从中读取数据的流（例如，fs.createReadStream()）。 Duplex: Readable 和 Writable 的流（例如，net.Socket）。 Transform: 可以在写入和读取数据时修改或转换数据的 Duplex 流（例如，zlib.createDeflate()）。此外，此模块还包括实用函数 stream.pipeline()、stream.finished()、stream.Readable.from() 和 stream.addAbortSignal()。 流的 Promise APIstream/promises API 为返回 Promise 对象（而不是使用回调）的流提供了一组替代的异步实用函数。 API 可通过 require(‘node:stream/promises’) 或 require(‘node:stream’).promises 访问。 对象模式Node.js API 创建的所有流都只对字符串和 Buffer（或 Uint8Array）对象进行操作。 但是，流的实现可以使用其他类型的 JavaScript 值（除了 null，它在流中具有特殊用途）。 这样的流被认为是在”对象模式”下运行的。 流的实例在创建流时使用 objectMode 选项切换到对象模式。 尝试将现有的流切换到对象模式是不安全的。 缓冲Writable 和 Readable 流都将数据存储在内部缓冲区中。可能缓冲的数据量取决于传给流的构造函数的 highWaterMark 选项。对于普通的流，highWaterMark 选项指定字节的总数。 对于在对象模式下操作的流，highWaterMark 指定对象的总数。 当实现调用 stream.push(chunk) 时，数据缓存在 Readable 流中。 如果流的消费者没有调用 stream.read()，则数据会一直驻留在内部队列中，直到被消费。 一旦内部读取缓冲区的总大小达到 highWaterMark 指定的阈值，则流将暂时停止从底层资源读取数据，直到可以消费当前缓冲的数据（也就是，流将停止调用内部的用于填充读取缓冲区 readable._read() 方法）。 当重复调用 writable.write(chunk) 方法时，数据会缓存在 Writable 流中。 虽然内部的写入缓冲区的总大小低于 highWaterMark 设置的阈值，但对 writable.write() 的调用将返回 true。 一旦内部缓冲区的大小达到或超过 highWaterMark，则将返回 false。 stream API 的一个关键目标，尤其是 stream.pipe() 方法，是将数据缓冲限制在可接受的水平，以便不同速度的来源和目标不会压倒可用内存。 highWaterMark 选项是阈值，而不是限制：它规定了流在停止请求更多数据之前缓冲的数据量。 它通常不强制执行严格的内存限制。 特定的流实现可能会选择实施更严格的限制，但这样做是可选的。 由于 Duplex 和 Transform 流都是 Readable 和 Writable，因此每个流都维护两个独立的内部缓冲区，用于读取和写入，允许每一端独立操作，同时保持适当且高效的数据流。 例如，net.Socket 实例是 Duplex 流，其 Readable 端允许消费从套接字接收的数据，其 Writable 端允许将数据写入套接字。 因为数据可能以比接收数据更快或更慢的速度写入套接字，所以每一端都应该独立于另一端进行操作（和缓冲）。 内部缓冲的机制是内部的实现细节，可能随时更改。 但是，对于某些高级实现，可以使用 writable.writableBuffer 或 readable.readableBuffer 检索内部的缓冲区。 不鼓励使用这些未记录的属性。 流消费者的 API几乎所有的 Node.js 应用程序，无论多么简单，都以某种方式使用流。 以下是在实现 HTTP 服务器的 Node.js 应用程序中使用流的示例： 123456789101112131415161718192021222324252627282930313233343536373839const http = require(&#x27;node:http&#x27;);const server = http.createServer((req, res) =&gt; &#123; // `req` 是 http.IncomingMessage，它是可读流。 // `res` 是 http.ServerResponse，它是可写流。 let body = &#x27;&#x27;; // 以 utf8 字符串形式获取数据。 // 如果未设置编码，则将接收缓冲区对象。 req.setEncoding(&#x27;utf8&#x27;); // 一旦添加了监听器，则可读流就会触发 &#x27;data&#x27; 事件。 req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; body += chunk; &#125;); // &#x27;end&#x27; 事件表示已经接收到整个正文。 req.on(&#x27;end&#x27;, () =&gt; &#123; try &#123; const data = JSON.parse(body); // 给用户回写一些有趣的东西： res.write(typeof data); res.end(); &#125; catch (er) &#123; // 哦哦！糟糕的 json！ res.statusCode = 400; return res.end(`error: $&#123;er.message&#125;`); &#125; &#125;);&#125;);server.listen(1337);// $ curl localhost:1337 -d &quot;&#123;&#125;&quot;// object// $ curl localhost:1337 -d &quot;\\&quot;foo\\&quot;&quot;// string// $ curl localhost:1337 -d &quot;not json&quot;// error: Unexpected token o in JSON at position 1 Writable 流（例如示例中的 res）暴露了用于将数据写入流的方法，例如 write() 和 end()。 当数据可从流中读取时，Readable 流使用 EventEmitter API 来通知应用程序代码。 可以通过多种方式从流中读取可用数据。 Writable 和 Readable 流都以各种方式使用 EventEmitter API 来传达流的当前状态。 Duplex 和 Transform 流都是 Writable 和 Readable。 向流中写入数据或从流中消费数据的应用程序不需要直接实现流的接口，并且通常没有理由调用 require(‘node:stream’)。 希望实现新类型的流的开发者应参考流实现者的 API 章节。 可写流Writable 流的示例包括： 客户端上的 HTTP 请求 服务器上的 HTTP 响应 文件系统写入流 压缩流 加密流 TCP 套接字 子进程标准输入 process.stdout、process.stderr其中一些示例实际上是实现 Writable 接口的 Duplex 流。 所有的 Writable 流都实现了 stream.Writable 类定义的接口。 虽然 Writable 流的特定实例可能以各种方式不同，但所有的 Writable 流都遵循相同的基本使用模式，如下例所示： stream.Writable 类 ‘close’ 事件当流及其任何底层资源（例如文件描述符）已关闭时，则会触发 ‘close’ 事件。 该事件表明将不再触发更多事件，并且不会发生进一步的计算。 如果 Writable 流是使用 emitClose 选项创建的，则始终会触发 ‘close’ 事件。 ‘error’ 事件如果在写入或管道数据时发生错误，则会触发 ‘error’ 事件。 监听器回调在调用时传入单个 Error 参数。除非在创建流时将 autoDestroy 选项设置为 false，否则当触发 ‘error’ 事件时将关闭流。在 ‘error’ 之后，不应触发除 ‘close’ 之外的其他事件（包括 ‘error’ 事件）。 ‘finish’ 事件在调用 stream.end() 方法之后，并且所有数据都已刷新到底层系统，则触发 ‘finish’ 事件。 12345678const writer = getWritableStreamSomehow();for (let i = 0; i &lt; 100; i++) &#123; writer.write(`hello, #$&#123;i&#125;!\\n`);&#125;writer.on(&#x27;finish&#x27;, () =&gt; &#123; console.log(&#x27;All writes are now complete.&#x27;);&#125;);writer.end(&#x27;This is the end\\n&#x27;); ‘pipe’ 事件src &lt;stream.Readable&gt; 管道到此可写流的源流当在可读流上调用 stream.pipe() 方法将此可写流添加到其目标集时，则触发 ‘pipe’ 事件。 1234567const writer = getWritableStreamSomehow();const reader = getReadableStreamSomehow();writer.on(&#x27;pipe&#x27;, (src) =&gt; &#123; console.log(&#x27;Something is piping into the writer.&#x27;); assert.equal(src, reader);&#125;);reader.pipe(writer); ‘unpipe’ 事件src &lt;stream.Readable&gt; 取消管道此可写流的源流当在 Readable 流上调用 stream.unpipe() 方法时，则会触发 ‘unpipe’ 事件，从其目标集合中删除此 Writable。当 Readable 流管道进入它时，如果此 Writable 流触发错误，则这也会触发。 writable.cork()writable.cork() 方法强制所有写入的数据都缓存在内存中。 当调用 stream.uncork() 或 stream.end() 方法时，缓冲的数据将被刷新。 writable.cork() 的主要目的是适应将几个小块快速连续写入流的情况。 writable.cork() 不是立即将它们转发到底层目标，而是缓冲所有块，直到 writable.uncork() 被调用，如果存在，writable.uncork() 会将它们全部传给 writable._writev()。 这可以防止在等待处理第一个小块时正在缓冲数据的行头阻塞情况。 但是，在不实现 writable._writev() 的情况下使用 writable.cork() 可能会对吞吐量产生不利影响。 writable.destroy([error])error 可选，与 ‘error’ 事件一起触发的错误。返回: 销毁流 可选地触发 ‘error’ 事件，并且触发 ‘close’ 事件（除非 emitClose 设置为 false）。 在此调用之后，则可写流已结束，随后对 write() 或 end() 的调用将导致 ERR_STREAM_DESTROYED 错误。 这是销毁流的破坏性和直接的方式。 先前对 write() 的调用可能没有排空，并且可能触发 ERR_STREAM_DESTROYED 错误。 如果数据应该在关闭之前刷新，或者在销毁流之前等待 ‘drain’ 事件，则使用 end() 而不是销毁。 123456789101112131415161718192021222324const &#123; Writable &#125; = require(&#x27;node:stream&#x27;);const myStream = new Writable();const fooErr = new Error(&#x27;foo error&#x27;);myStream.destroy(fooErr);myStream.on(&#x27;error&#x27;, (fooErr) =&gt; console.error(fooErr.message)); // foo errorconst &#123; Writable &#125; = require(&#x27;node:stream&#x27;);const myStream = new Writable();myStream.destroy();myStream.on(&#x27;error&#x27;, function wontHappen() &#123;&#125;);const &#123; Writable &#125; = require(&#x27;node:stream&#x27;);const myStream = new Writable();myStream.destroy();myStream.write(&#x27;foo&#x27;, (error) =&gt; console.error(error.code));// ERR_STREAM_DESTROYED 一旦 destroy() 被调用，任何进一步的调用都将是空操作，除了来自 _destroy() 的其他错误可能不会作为 ‘error’ 触发。实现者不应覆盖此方法，而应实现 writable._destroy()。 writable.uncork()writable.uncork() 方法会刷新自调用 stream.cork() 以来缓冲的所有数据。 当使用 writable.cork() 和 writable.uncork() 管理写入流的缓冲时，使用 process.nextTick() 推迟对 writable.uncork() 的调用。 这样做允许对在给定 Node.js 事件循环阶段中发生的所有 writable.write() 调用进行批处理。如果在一个流上多次调用 writable.cork() 方法，则必须调用相同数量的 writable.uncork() 调用来刷新缓冲的数据。 123456789stream.cork();stream.write(&#x27;some &#x27;);stream.cork();stream.write(&#x27;data &#x27;);process.nextTick(() =&gt; &#123; stream.uncork(); // 在第二次调用 uncork() 之前不会刷新数据。 stream.uncork();&#125;); 另见: writable.cork()。 writable.writableCorked需要调用 writable.uncork() 以完全解开流的次数。 writable.errored如果流因错误而被销毁，则返回错误。 writable.writableHighWaterMark返回创建此 Writable 时传入的 highWaterMark 的值。 writable.writableLength此属性包含队列中准备写入的字节数（或对象数）。 该值提供有关 highWaterMark 状态的内省数据。 可读流可读流是对被消费的数据的来源的抽象。 Readable 流的示例包括： 客户端上的 HTTP 响应 服务器上的 HTTP 请求 文件系统读取流 压缩流 加密流 TCP 套接字 子进程的标准输出和标准错误 process.stdin所有的 Readable 流都实现了 stream.Readable 类定义的接口。 两种读取模式Readable 流以两种模式之一有效地运行：流动和暂停。 这些模式与对象模式是分开的。 Readable 流可以处于或不处于对象模式，无论其是处于流动模式还是暂停模式。 在流动模式下，数据会自动从底层系统读取，并通过 EventEmitter 接口使用事件尽快提供给应用程序。在暂停模式下，必须显式调用 stream.read() 方法以从流中读取数据块。所有的 Readable 流都以暂停模式开始，但可以通过以下方式之一切换到流动模式： 添加 ‘data’ 事件句柄。 调用 stream.resume() 方法。 调用 stream.pipe() 方法将数据发送到 Writable。 Readable 可以使用以下方法之一切换回暂停模式： 如果没有管道目标，则通过调用 stream.pause() 方法。 如果有管道目标，则删除所有管道目标。 可以通过调用 stream.unpipe() 方法删除多个管道目标。要记住的重要概念是，在提供消费或忽略该数据的机制之前，Readable 不会产生数据。 如果消费机制被禁用或移除，则 Readable 将尝试停止产生数据。 出于向后兼容性的原因，删除 ‘data’ 事件句柄不会自动暂停流。 此外，如果有管道目标，则调用 stream.pause() 将不能保证一旦这些目标排空并要求更多数据，流将保持暂停状态。 如果 Readable 切换到流动模式并且没有消费者可用于处理数据，则数据将被丢失。 例如，当调用 readable.resume() 方法而没有绑定到 ‘data’ 事件的监听器时，或者当从流中删除 ‘data’ 事件句柄时，就会发生这种情况。 添加 ‘readable’ 事件句柄会自动使流停止流动，并且必须通过 readable.read() 来消费数据。 如果删除了 ‘readable’ 事件句柄，则如果有 ‘data’ 事件句柄，流将再次开始流动。 三种状态Readable 流的操作的”两种模式”是对 Readable 流实现中发生的更复杂的内部状态管理的简化抽象。具体来说，在任何给定的时间点，每个 Readable 都处于三种可能的状态之一： readable.readableFlowing === null readable.readableFlowing === false readable.readableFlowing === true当 readable.readableFlowing 为 null 时，则不提供消费流数据的机制。 因此，流不会生成数据。 在此状态下，为 ‘data’ 事件绑定监听器、调用 readable.pipe() 方法、或调用 readable.resume() 方法会将 readable.readableFlowing 切换到 true，从而使 Readable 在生成数据时开始主动触发事件。 调用readable.pause()、readable.unpipe()、或者接收背压都会导致 readable.readableFlowing 被设置为 false，暂时停止事件的流动，但不会停止数据的生成。 在此状态下，为 ‘data’ 事件绑定监听器不会将 readable.readableFlowing 切换到 true。 1234567891011const &#123; PassThrough, Writable &#125; = require(&#x27;node:stream&#x27;);const pass = new PassThrough();const writable = new Writable();pass.pipe(writable);pass.unpipe(writable);// readableFlowing 现在为 false。pass.on(&#x27;data&#x27;, (chunk) =&gt; &#123; console.log(chunk.toString()); &#125;);pass.write(&#x27;ok&#x27;); // 不会触发 &#x27;data&#x27;。pass.resume(); // 必须调用才能使流触发 &#x27;data&#x27;。 虽然 readable.readableFlowing 是 false，但数据可能会在流的内部缓冲区中累积。 选择一种接口风格Readable 流的 API 跨越多个 Node.js 版本的演进，并提供了多种消费流数据的方法。 一般情况下，开发者应该选择其中一种消费数据的方式，切忌使用多种方式消费单一流中的数据。 具体来说，使用 on(‘data’)、on(‘readable’)、pipe() 或异步迭代器的组合可能会导致不直观的行为。 stream.Readable 类 readable.pipe(destination[, options]) destination &lt;stream.Writable&gt; 写入数据的目标 options 管道选项 end 当读取结束时结束写入。 默认值: true。返回: &lt;stream.Writable&gt; 目标，如果它是 Duplex 或 Transform 流，则允许使用管道链readable.pipe() 方法将 Writable 流绑定到 readable，使其自动切换到流动模式并将其所有数据推送到绑定的 Writable。 数据流将被自动管理，以便目标 Writable 流不会被更快的 Readable 流漫过。可以将多个 Writable 流绑定到单个 Readable 流。 readable.read([size])size 用于指定要读取的数据量的可选参数。返回: | | | readable.read() 方法从内部缓冲区中读取数据并返回。 如果没有数据可以读取，则返回 null。默认情况下，除非使用 readable.setEncoding() 方法指定了编码或流在对象模式下运行，否则数据将作为 Buffer 对象返回。可选的 size 参数指定要读取的特定字节数。 如果无法读取 size 字节，则将返回 null，除非流已结束，在这种情况下，将返回内部缓冲区中剩余的所有数据。如果未指定 size 参数，则将返回内部缓冲区中包含的所有数据。size 参数必须小于或等于 1 GiB。readable.read() 方法应该只在暂停模式下操作的 Readable 流上调用。 在流动模式下，会自动调用 readable.read()，直到内部缓冲区完全排空。 每次调用 readable.read() 都会返回一个数据块或 null。 块不是串联的。 需要 while 循环来消费当前缓冲区中的所有数据。 当读取大文件时，.read() 可能会返回 null，到目前为止已经消费了所有缓冲的内容，但是还有更多的数据尚未缓冲。 在这种情况下，当缓冲区中有更多数据时，将触发新的 ‘readable’ 事件。 最后，当没有更多数据时，则将触发 ‘end’ 事件。 因此，要从 readable 读取文件的全部内容，必须跨越多个 ‘readable’ 事件来收集块： 123456789101112const chunks = [];readable.on(&#x27;readable&#x27;, () =&gt; &#123; let chunk; while (null !== (chunk = readable.read())) &#123; chunks.push(chunk); &#125;&#125;);readable.on(&#x27;end&#x27;, () =&gt; &#123; const content = chunks.join(&#x27;&#x27;);&#125;); 对象模式下的 Readable 流将始终从对 readable.read(size) 的调用返回单个条目，而不管 size 参数的值如何。如果 readable.read() 方法返回数据块，则还将触发 ‘data’ 事件。在 ‘end’ 事件触发后调用 stream.read([size]) 将返回 null。 不会引发运行时错误。 readable.readable如果调用 readable.read() 是安全的，则为 true，这意味着流尚未被销毁或触发 ‘error’ 或 ‘end’。 readable.readableAborted返回在触发 ‘end’ 之前流是被破销毁或出错。 readable.readableDidRead返回是否已触发 ‘data’。 readable.errored如果流因错误而被销毁，则返回错误。 readable.readableFlowing此属性反映了 Readable 流的当前状态，如三种状态章节所述。 readable.resume()readable.resume() 方法使被显式暂停的 Readable 流恢复触发 ‘data’ 事件，将流切换到流动模式。 readable.resume() 方法可用于完全地消费流中的数据，而无需实际处理任何数据： 12345getReadableStreamSomehow() .resume() .on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;Reached the end, but did not read anything.&#x27;); &#125;); 如果有 ‘readable’ 事件监听器，则 readable.resume() 方法不起作用。 readable.iterator([options])options destroyOnReturn 当设置为 false 时，在异步迭代器上调用 return 或使用 break、return 或 throw 退出 for await…of 迭代不会销毁流。 默认值: true。返回: 消费流。如果 for await…of 循环由 return、break 或 throw 退出，或者如果流在迭代期间发出错误，迭代器是否应该销毁流，则此方法创建的迭代器为用户提供了取消流销毁的选项。1234567891011121314151617181920212223242526272829303132const &#123; Readable &#125; = require(&#x27;node:stream&#x27;);async function printIterator(readable) &#123; for await (const chunk of readable.iterator(&#123; destroyOnReturn: false &#125;)) &#123; console.log(chunk); // 1 break; &#125; console.log(readable.destroyed); // false for await (const chunk of readable.iterator(&#123; destroyOnReturn: false &#125;)) &#123; console.log(chunk); // 将打印 2 然后打印 3 &#125; console.log(readable.destroyed); // true，流被完全消费了&#125;async function printSymbolAsyncIterator(readable) &#123; for await (const chunk of readable) &#123; console.log(chunk); // 1 break; &#125; console.log(readable.destroyed); // true&#125;async function showBoth() &#123; await printIterator(Readable.from([1, 2, 3])); await printSymbolAsyncIterator(Readable.from([1, 2, 3]));&#125;showBoth(); readable.map(fn[, options])fn | 映射流中每个块的函数。 data 来自流的数据块。 options signal 如果流被销毁则中止，允许提前中止 fn 调用。options concurrency 一次调用流的最大并发调用 fn。 默认值: 1。 signal 如果信号被中止，则允许销毁流。返回: 使用函数 fn 映射的流。此方法允许映射流。 将为流中的每个块调用 fn 函数。 如果 fn 函数返回 promise，则该 promise 将在被传到结果流之前被 await。 readable.drop(limit[, options])limit 从可读文件中删除的块数。options signal 如果信号被中止，则允许销毁流。返回: 丢弃了 limit 个块的流。此方法返回新的流，其前 limit 个块被丢弃。123import &#123; Readable &#125; from &#x27;node:stream&#x27;;await Readable.from([1, 2, 3, 4]).drop(2).toArray(); // [3, 4] readable.take(limit[, options])此方法返回带有前 limit 个块的新流。 readable.asIndexedPairs([options])options signal 如果信号被中止，则允许销毁流。返回: 索引对的流。此方法返回新的流，其中包含与 [index, chunk] 形式的计数器配对的底层流块。 第一个索引值为 0，每产生一个块，则增加 1。1234import &#123; Readable &#125; from &#x27;node:stream&#x27;;const pairs = await Readable.from([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]).asIndexedPairs().toArray();console.log(pairs); // [[0, &#x27;a&#x27;], [1, &#x27;b&#x27;], [2, &#x27;c&#x27;]] 双工流与转换流stream.Duplex 类双工流是同时实现 Readable 和 Writable 接口的流。 Duplex 流的示例包括： TCP 套接字 压缩流 加密流 Transform 流的示例包括： 压缩流 加密流 stream.compose(…streams)streams &lt;Stream[]&gt; | &lt;Iterable[]&gt; | &lt;AsyncIterable[]&gt; | &lt;Function[]&gt;返回: &lt;stream.Duplex&gt;将两个或多个流组合成一个 Duplex 流，其写入第一个流并从最后一个流读取。 每个提供的流都通过管道传输到下一个，使用 stream.pipeline。 如果任何流错误，则所有流都将被销毁，包括外部的 Duplex 流。 因为 stream.compose 返回新的流，该流又可以（并且应该）通过管道传输到其他流中，所以它支持组合。 相比之下，当将流传到 stream.pipeline 时，通常第一个流是可读流，最后一个流是可写流，从而形成闭合回路。 如果传入了 Function，则它必须是采用 source Iterable 的工厂方法。 stream.compose 可用于将异步迭代器、生成器和函数转换为流。 AsyncIterable 转换为可读的 Duplex。 无法产生 null。AsyncGeneratorFunction 转换为可读/可写的转换 Duplex。 必须将源 AsyncIterable 作为第一个参数。 无法产生 null。AsyncFunction 转换为可写的 Duplex。 必须返回 null 或 undefined。 stream.Readable.from(iterable[, options])iterable 实现 Symbol.asyncIterator 或 Symbol.iterator 可迭代协议的对象。 如果传入空值，则触发 ‘error’ 事件。options 提供给 new stream.Readable([options]) 的选项。 默认情况下，Readable.from() 会将 options.objectMode 设置为 true，除非通过将 options.objectMode 设置为 false 来明确选择退出。返回: &lt;stream.Readable&gt;一个从迭代器中创建可读流的实用方法。 出于性能原因，调用 Readable.from(string) 或 Readable.from(buffer) 不会迭代字符串或缓冲区以匹配其他流语义。 stream.addAbortSignal(signal, stream)signal 代表可能取消的信号stream 将信号绑定到的流将中止信号绑定到可读或可写的流。 这让代码可以使用 AbortController 来控制流销毁。在与传入的 AbortSignal 对应的 AbortController 上调用 abort 的行为与在流上调用 .destroy(new AbortError()) 的行为相同。 readable.read(0)在某些情况下，需要触发底层可读流机制的刷新，而不实际消耗任何数据。 在这种情况下，可以调用 readable.read(0)，它总是返回 null。 如果内部读取缓冲区在 highWaterMark 之下，并且当前没有读取流，那么调用 stream.read(0) 将触发低级 stream._read() 调用。 虽然大多数应用程序几乎不需要这样做，但在 Node.js 中也有这样做的情况，特别是在 Readable 流类内部。 readable.push(‘’)不推荐使用 readable.push(‘’)。 将零字节字符串 Buffer 或 Uint8Array 推送到非对象模式的流有一个有趣的副作用。 因为是对 readable.push() 的调用，所以调用会结束读取过程。 然而，因为参数是空字符串，没有数据被添加到可读缓冲区，所以用户没有任何东西可以消费。 调用 readable.setEncoding() 之后 highWaterMark 的差异readable.setEncoding() 的使用将改变 highWaterMark 在非对象模式下的操作方式。通常，当前缓冲区的大小是根据 highWaterMark 以字节为单位来衡量的。 但是，在调用 setEncoding() 之后，比较函数将开始以字符为单位测量缓冲区的大小。 在 latin1 或 ascii 的常见情况下，这不是问题。 但建议在处理可能包含多字节字符的字符串时注意这种行为。"},{"title":"nodejs基础知识(12)","date":"2023-02-25T12:08:26.000Z","updated":"2023-07-24T09:24:46.501Z","comments":true,"path":"nodejs/nodejs-note-22.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-22.html","excerpt":"","text":"perf_hooks 性能钩子performance.eventLoopUtilization([utilization1[, utilization2]])utilization1 上一次调用 eventLoopUtilization() 的结果。utilization2 在 utilization1 之前调用 eventLoopUtilization() 的结果。返回 idle active utilization eventLoopUtilization() 方法返回包含事件循环作为高解析度毫秒计时器的既空闲又活动的累积持续时间的对象。 utilization 值是计算的事件循环利用率 (ELU)。 如果主线程上的引导尚未完成，则属性的值为 0。 由于引导发生在事件循环内，所以 ELU 立即在工作线程上可用。 utilization1 和 utilization2 都是可选参数。 如果传入了 utilization1，则计算当前调用的 active 和 idle 之间的差值，以及对应的 utilization 值(类似于 process.hrtime())。 如果传入了 utilization1 和 utilization2，则计算两个参数之间的增量。 这是便捷的选项，因为与 process.hrtime() 不同，计算 ELU 比单个减法更复杂。 ELU 类似于 CPU 使用率，不同之处在于它只测量事件循环统计信息而不是 CPU 使用率。 它表示事件循环在事件循环的事件提供者（例如 epoll_wait）之外花费的时间百分比。 不考虑其他 CPU 空闲时间。 以下是主要空闲进程如何具有高 ELU 的示例。 123456789&#x27;use strict&#x27;;const &#123; eventLoopUtilization &#125; = require(&#x27;node:perf_hooks&#x27;).performance;const &#123; spawnSync &#125; = require(&#x27;node:child_process&#x27;);setImmediate(() =&gt; &#123; const elu = eventLoopUtilization(); spawnSync(&#x27;sleep&#x27;, [&#x27;5&#x27;]); console.log(eventLoopUtilization(elu).utilization);&#125;); 虽然运行这个脚本时 CPU 大部分是空闲的，但 utilization 的值为 1。 这是因为对 child_process.spawnSync() 的调用阻止了事件循环的进行。传入用户定义的对象而不是先前调用 eventLoopUtilization() 的结果将导致未定义的行为。 不保证返回值反映事件循环的任何正确状态。 performance.getEntries()返回 PerformanceEntry 对象的列表，按照相对于 performanceEntry.startTime 的时间顺序排列。 如果您只对某些类型或具有某些名称的性能条目感兴趣，则参阅 performance.getEntriesByType() 和 performance.getEntriesByName()。 performance.mark([name[, options]])name options detail 包含在标记中的附加可选细节。 startTime 用作标记时间的可选时间戳。 默认值: performance.now().在性能时间轴中创建新的 PerformanceMark 条目。 PerformanceMark 是 PerformanceEntry 的子类，其 performanceEntry.entryType 始终为 ‘mark’，而其 performanceEntry.duration 始终为 0。 性能标记用于标记性能时间轴中的特定重要时刻。创建的 PerformanceMark 条目放入全局的性能时间轴，可以用 performance.getEntries、performance.getEntriesByName、performance.getEntriesByType 查询。 当执行观察时，应使用 performance.clearMarks 手动从全局的性能时间轴中清除条目。 performance.markResourceTiming(timingInfo, requestedUrl, initiatorType, global, cacheMode) timingInfo 获取计时信息 requestedUrl 资源网址 initiatorType 启动器名称，例如：’fetch’ global cacheMode 缓存模式必须为空字符串（’’）或 ‘local’ 此属性是 Node.js 的扩展。 它在 Web 浏览器中不可用。在资源时间线中创建新的 PerformanceResourceTiming 条目。 PerformanceResourceTiming 是 PerformanceEntry 的子类，其 performanceEntry.entryType 始终是 ‘resource’。 性能资源用于在资源时间线中标记时刻。创建的 PerformanceMark 条目放入全局资源时间线，可以使用 performance.getEntries、performance.getEntriesByName、performance.getEntriesByType 查询。 当执行观察时，应使用 performance.clearResourceTimings 手动从全局的性能时间轴中清除条目。 performance.measure(name[, startMarkOrOptions[, endMark]]) name startMarkOrOptions | 可选的。 detail 要包含在度量中的其他可选细节。 duration 开始和结束时间之间的持续时间。 end | 用作结束时间的时间戳，或标识先前记录标记的字符串。 start | 用作开始时间的时间戳，或标识先前记录标记的字符串。 endMark 可选的。 如果 startMarkOrOptions 是 ，则必须省略。在性能时间轴中创建新的 PerformanceMeasure 条目。 PerformanceMeasure 是 PerformanceEntry 的子类，其 performanceEntry.entryType 始终为 ‘measure’，其 performanceEntry.duration 测量自 startMark 和 endMark 以来经过的毫秒数。 startMark 参数可以标识性能时间轴中的任何现有的 PerformanceMark，或者可能标识由 PerformanceNodeTiming 类提供的任何时间戳属性。 如果指定的 startMark 不存在，则抛出错误。 可选的 endMark 参数必须标识性能时间轴中的任何现有的 PerformanceMark 或 PerformanceNodeTiming 类提供的任何时间戳属性。 不传入参数则 endMark 为 performance.now()，否则如果命名的 endMark 不存在，则抛出错误。 创建的 PerformanceMeasure 条目放入全局的性能时间轴，可以用 performance.getEntries、performance.getEntriesByName、performance.getEntriesByType 查询。 当执行观察时，应使用 performance.clearMeasures 手动从全局的性能时间轴中清除条目。 performance.nodeTimin此属性是 Node.js 的扩展。 它在 Web 浏览器中不可用。PerformanceNodeTiming 类的实例，为特定的 Node.js 操作里程碑提供性能指标。 performance.now()返回当前的高解析度毫秒时间戳，其中 0 表示当前的 node 进程的开始。 performance.timeOrigintimeOrigin 指定了当前的 node 进程开始的高解析度毫秒时间戳，以 Unix 时间度量。 performance.timerify(fn[, options])fn options histogram 使用 perf_hooks.createHistogram() 创建的直方图对象，以纳秒为单位记录运行时间。此属性是 Node.js 的扩展。 它在 Web 浏览器中不可用。 将函数封装在测量被封装函数运行时间的新函数中。 PerformanceObserver 必须订阅 ‘function’ 事件类型才能访问时间细节。 12345678910111213141516171819202122const &#123; performance, PerformanceObserver&#125; = require(&#x27;node:perf_hooks&#x27;);function someFunction() &#123; console.log(&#x27;hello world&#x27;);&#125;const wrapped = performance.timerify(someFunction);const obs = new PerformanceObserver((list) =&gt; &#123; console.log(list.getEntries()[0].duration); performance.clearMarks(); performance.clearMeasures(); obs.disconnect();&#125;);obs.observe(&#123; entryTypes: [&#x27;function&#x27;] &#125;);// 将创建性能时间轴条目wrapped(); 如果封装的函数返回 promise，则 finally 句柄将绑定到该 promise 上，并且一旦调用 finally 句柄就会报告持续时间。 performance.toJSON()performance 对象的 JSON 表示的对象。 类似于浏览器中的 window.performance.toJSON。 PerformanceEntry 类performanceEntry.duration此条目经过的总毫秒数。 此值对所有性能条目类型都没有意义。 performanceEntry.entryType性能条目的类型。 它可能是以下之一： ‘node’（仅限 Node.js） ‘mark’（在 Web 上可用） ‘measure’（在 Web 上可用） ‘gc’（仅限 Node.js） ‘function’（仅限 Node.js） ‘http2’（仅限 Node.js） ‘http’（仅限 Node.js） performanceEntry.flags此属性是 Node.js 的扩展。 它在 Web 浏览器中不可用。 当 performanceEntry.entryType 等于 ‘gc’ 时，则 performance.flags 属性包含有关垃圾收集操作的附加信息。 该值可能是以下之一： perf_hooks.constants.NODE_PERFORMANCE_GC_FLAGS_NO perf_hooks.constants.NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED perf_hooks.constants.NODE_PERFORMANCE_GC_FLAGS_FORCED perf_hooks.constants.NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING perf_hooks.constants.NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE perf_hooks.constants.NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY perf_hooks.constants.NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE performanceEntry.kind此属性是 Node.js 的扩展。 它在 Web 浏览器中不可用。 当 performanceEntry.entryType 等于 ‘gc’ 时，则 performance.kind 属性标识发生的垃圾收集操作的类型。 该值可能是以下之一： perf_hooks.constants.NODE_PERFORMANCE_GC_MAJOR perf_hooks.constants.NODE_PERFORMANCE_GC_MINOR perf_hooks.constants.NODE_PERFORMANCE_GC_INCREMENTAL perf_hooks.constants.NODE_PERFORMANCE_GC_WEAKCB HTTP 的详细信息当 performanceEntry.type 等于 ‘http’ 时，则 performanceEntry.detail 属性将是一个包含额外信息的 。 如果 performanceEntry.name 等于 HttpClient，则 detail 将包含以下属性：req、res。 而 req 属性将是包含 method、url、headers 的 ，res 属性将是包含 statusCode、statusMessage、headers 的 。 如果 performanceEntry.name 等于 HttpRequest，则 detail 将包含以下属性：req、res。 而 req 属性将是包含 method、url、headers 的 ，res 属性将是包含 statusCode、statusMessage、headers 的 。 这可能会增加额外的内存开销，并且只能用于诊断目的，而不是默认情况下在生产中打开。 HTTP/2 的详细信息当 performanceEntry.type 等于 ‘http2’ 时，则 performanceEntry.detail 属性将是包含附加性能信息的 。如果 performanceEntry.name 等于 Http2Stream，则 detail 将包含以下属性： bytesRead 为此 Http2Stream 接收的 DATA 帧字节数。 bytesWritten 为此 Http2Stream 发送的 DATA 帧字节数。 id 关联 Http2Stream 的标识符 timeToFirstByte 从 PerformanceEntry startTime 到接收到第一个 DATA 帧之间经过的毫秒数。 timeToFirstByteSent 从 PerformanceEntry startTime 到发送的第一个 DATA 帧之间经过的毫秒数。 timeToFirstHeader 从 PerformanceEntry startTime 到接收到第一个标头之间经过的毫秒数。 如果 performanceEntry.name 等于 Http2Session，则 detail 将包含以下属性： bytesRead 为此 Http2Session 接收的字节数。 bytesWritten 为此 Http2Session 发送的字节数。 framesReceived Http2Session 接收到的 HTTP/2 帧数。 framesSent Http2Session 发送的 HTTP/2 帧数。 maxConcurrentStreams Http2Session 生命周期内同时打开的最大流数。 pingRTT 从发送 PING 帧到接收到它的确认所经过的毫秒数。 只有在 Http2Session 上发送了 PING 帧时才会出现。 streamAverageDuration 所有 Http2Stream 实例的平均持续时间（以毫秒为单位） streamCount Http2Session 处理的 Http2Stream 实例的数量。 type ‘server’ 或 ‘client’ 来标识 Http2Session 的类型。 计时器化的详细信息当 performanceEntry.type 等于 ‘function’ 时，则 performanceEntry.detail 属性将是列出计时函数的输入参数的 。 网络(‘net’)的详细信息当 performanceEntry.type 等于 ‘net’ 时，则 performanceEntry.detail 属性将是一个包含额外信息的 。如果 performanceEntry.name 等于 connect，则 detail 将包含以下属性：host、port。 域名系统(‘dns’)的详细信息当 performanceEntry.type 等于 ‘dns’ 时，则 performanceEntry.detail 属性将是一个包含额外信息的 。 如果 performanceEntry.name 等于 lookup，则 detail 将包含以下属性：hostname、family、hints、verbatim。 如果 performanceEntry.name 等于 lookupService，则 detail 将包含以下属性：host、port。 如果 performanceEntry.name 等于 queryxxx 或 getHostByAddr，则 detail 将包含以下属性：host、ttl。 PerformanceNodeTiming 类继承自: 此属性是 Node.js 的扩展。 它在 Web 浏览器中不可用。 为 Node.js 本身提供计时细节。 此类的构造函数不会暴露给用户。 performanceNodeTiming.bootstrapCompleteNode.js 进程完成引导的高解析度毫秒时间戳。 如果引导尚未完成，则该属性的值为 -1。 performanceNodeTiming.environmentNode.js 环境初始化的高解析度毫秒时间戳。 performanceNodeTiming.idleTime事件循环在事件循环的事件提供者（例如 epoll_wait）中空闲的时间量的高解析度毫秒时间戳。 这不考虑 CPU 使用率。 如果事件循环尚未开始（例如，在主脚本的第一个滴答中），则该属性的值为 0。 performanceNodeTiming.loopExitNode.js 事件循环退出时的高解析度毫秒时间戳。 如果事件循环尚未退出，则该属性的值为 -1。 它只能在 ‘exit’ 事件的句柄中具有非 -1 的值。 performanceNodeTiming.loopStartNode.js 事件循环开始的高解析度毫秒时间戳。 如果事件循环尚未开始（例如，在主脚本的第一个滴答中），则该属性的值为 -1。 performanceNodeTiming.nodeStartNode.js 进程初始化的高解析度毫秒时间戳。 performanceNodeTiming.v8StartV8 平台初始化的高解析度毫秒时间戳。 PerformanceResourceTiming 类继承自: 提供有关应用程序资源加载的详细网络计时数据。 此类的构造函数不直接暴露给用户。 performanceResourceTiming.workerStart即将发送 fetch 请求之前的高解析度毫秒时间戳。 如果资源没有被工作进程截获，该属性将始终返回 0。 performanceResourceTiming.redirectStart表示启动重定向的获取的开始时间的高解析度毫秒时间戳。 performanceResourceTiming.redirectEnd接收到最后一个重定向响应的最后一个字节后立即创建的高解析度毫秒时间戳。 performanceResourceTiming.fetchStartNode.js 开始获取资源之前的高解析度毫秒时间戳。 performanceResourceTiming.domainLookupStartNode.js 开始查找资源之前的高解析度毫秒时间戳。 performanceResourceTiming.domainLookupEnd表示 Node.js 完成对资源的域名查找之后的时间高解析度毫秒时间戳。 performanceResourceTiming.connectStart表示 Node.js 开始与服务器建立连接以检索资源之前的时间的高解析度毫秒时间戳。 performanceResourceTiming.connectEnd表示 Node.js 完成与服务器建立连接以检索资源后的时间的高解析度毫秒时间戳。 performanceResourceTiming.secureConnectionStart表示 Node.js 开始握手过程以保护当前连接之前的时间的高解析度毫秒时间戳。 performanceResourceTiming.requestStart表示 Node.js 从服务器接收到响应的第一个字节之前的时间的高解析度毫秒时间戳。 performanceResourceTiming.responseEnd表示 Node.js 接收到资源的最后一个字节之后或传输连接关闭之前的时间（以先到者为准）的高解析度毫秒时间戳。 performanceResourceTiming.transferSize表示获取资源大小（以八位字节为单位）的数值。 大小包括响应头字段加上响应负载正文。 performanceResourceTiming.encodedBodySize表示在删除任何应用的内容编码之前从有效负载主体的提取（HTTP 或缓存）接收到的大小（以八位字节为单位）的数值。 performanceResourceTiming.decodedBodySize表示在删除任何应用的内容编码后，从消息主体的提取（HTTP 或缓存）接收到的大小（以八位字节为单位）的数值。 performanceResourceTiming.toJSON()返回 object，其是 PerformanceResourceTiming 对象的 JSON 表示形式 perf_hooks.PerformanceObserver 类new PerformanceObserver(callback)callback list observer 当新的 PerformanceEntry 实例被添加到性能时间线时，则 PerformanceObserver 对象会提供通知。123456789101112131415const &#123; performance, PerformanceObserver&#125; = require(&#x27;node:perf_hooks&#x27;);const obs = new PerformanceObserver((list, observer) =&gt; &#123; console.log(list.getEntries()); performance.clearMarks(); performance.clearMeasures(); observer.disconnect();&#125;);obs.observe(&#123; entryTypes: [&#x27;mark&#x27;], buffered: true &#125;);performance.mark(&#x27;test&#x27;); 因为 PerformanceObserver 实例引入了它们自己的额外性能开销，实例不应无限期地订阅通知。 一旦不再需要观察者，则用户应立即断开观察者的连接。当 PerformanceObserver 接收到有关新的 PerformanceEntry 实例的通知时，则会调用 callback。 回调接收到 PerformanceObserverEntryList 实例和对 PerformanceObserver 的引用。 performanceObserver.disconnect()断开 PerformanceObserver 实例与所有通知的连接。 performanceObserver.observe(options)options type 单个 类型。 如果已经指定了 entryTypes，则不能给出。 entryTypes &lt;string[]&gt; 标识观察者感兴趣的 实例类型的字符串数组。 如果未提供，将抛出错误。 buffered 如果为 true，则使用列表全局 PerformanceEntry 缓冲条目调用观察者回调。 如果为false，则只有在时间点之后创建的 PerformanceEntry 被发送到观察者回调。 默认值: false。为 实例订阅由 options.entryTypes 或 options.type 标识的新 实例的通知：123456789101112const &#123; performance, PerformanceObserver&#125; = require(&#x27;node:perf_hooks&#x27;);const obs = new PerformanceObserver((list, observer) =&gt; &#123; // 异步调用一次。`list` 包含三个条目。&#125;);obs.observe(&#123; type: &#x27;mark&#x27; &#125;);for (let n = 0; n &lt; 3; n++) performance.mark(`test$&#123;n&#125;`); PerformanceObserverEntryList 类PerformanceObserverEntryList 类用于提供对传给 PerformanceObserver 的 PerformanceEntry 实例的访问。 此类的构造函数不会暴露给用户。 performanceObserverEntryList.getEntries()返回: &lt;PerformanceEntry[]&gt;返回 PerformanceEntry 对象的列表，按照相对于 performanceEntry.startTime 的时间顺序排列。 1234567891011121314151617181920212223242526272829303132const &#123; performance, PerformanceObserver&#125; = require(&#x27;node:perf_hooks&#x27;);const obs = new PerformanceObserver((perfObserverList, observer) =&gt; &#123; console.log(perfObserverList.getEntries()); /** * [ * PerformanceEntry &#123; * name: &#x27;test&#x27;, * entryType: &#x27;mark&#x27;, * startTime: 81.465639, * duration: 0 * &#125;, * PerformanceEntry &#123; * name: &#x27;meow&#x27;, * entryType: &#x27;mark&#x27;, * startTime: 81.860064, * duration: 0 * &#125; * ] */ performance.clearMarks(); performance.clearMeasures(); observer.disconnect();&#125;);obs.observe(&#123; type: &#x27;mark&#x27; &#125;);performance.mark(&#x27;test&#x27;);performance.mark(&#x27;meow&#x27;); performanceObserverEntryList.getEntriesByName(name[, type])name type 返回: &lt;PerformanceEntry[]&gt;返回按时间顺序的 PerformanceEntry 对象列表，其中 performanceEntry.startTime 的 performanceEntry.name 等于 name，并且可选地，其 performanceEntry.entryType 等于 type。 12345678910111213141516171819202122232425262728293031323334353637383940const &#123; performance, PerformanceObserver&#125; = require(&#x27;node:perf_hooks&#x27;);const obs = new PerformanceObserver((perfObserverList, observer) =&gt; &#123; console.log(perfObserverList.getEntriesByName(&#x27;meow&#x27;)); /** * [ * PerformanceEntry &#123; * name: &#x27;meow&#x27;, * entryType: &#x27;mark&#x27;, * startTime: 98.545991, * duration: 0 * &#125; * ] */ console.log(perfObserverList.getEntriesByName(&#x27;nope&#x27;)); // [] console.log(perfObserverList.getEntriesByName(&#x27;test&#x27;, &#x27;mark&#x27;)); /** * [ * PerformanceEntry &#123; * name: &#x27;test&#x27;, * entryType: &#x27;mark&#x27;, * startTime: 63.518931, * duration: 0 * &#125; * ] */ console.log(perfObserverList.getEntriesByName(&#x27;test&#x27;, &#x27;measure&#x27;)); // [] performance.clearMarks(); performance.clearMeasures(); observer.disconnect();&#125;);obs.observe(&#123; entryTypes: [&#x27;mark&#x27;, &#x27;measure&#x27;] &#125;);performance.mark(&#x27;test&#x27;);performance.mark(&#x27;meow&#x27;); performanceObserverEntryList.getEntriesByType(type)type 返回: &lt;PerformanceEntry[]&gt;返回按时间顺序排列的 PerformanceEntry 对象列表，其中 performanceEntry.startTime 的 performanceEntry.entryType 等于 type。 12345678910111213141516171819202122232425262728293031const &#123; performance, PerformanceObserver&#125; = require(&#x27;node:perf_hooks&#x27;);const obs = new PerformanceObserver((perfObserverList, observer) =&gt; &#123; console.log(perfObserverList.getEntriesByType(&#x27;mark&#x27;)); /** * [ * PerformanceEntry &#123; * name: &#x27;test&#x27;, * entryType: &#x27;mark&#x27;, * startTime: 55.897834, * duration: 0 * &#125;, * PerformanceEntry &#123; * name: &#x27;meow&#x27;, * entryType: &#x27;mark&#x27;, * startTime: 56.350146, * duration: 0 * &#125; * ] */ performance.clearMarks(); performance.clearMeasures(); observer.disconnect();&#125;);obs.observe(&#123; type: &#x27;mark&#x27; &#125;);performance.mark(&#x27;test&#x27;);performance.mark(&#x27;meow&#x27;); perf_hooks.createHistogram([options])options lowest | 最低可识别值。 必须是大于 0 的整数值。 默认值: 1。 highest | 最高可记录值。 必须是等于或大于 lowest 两倍的整数值。 默认值: Number.MAX_SAFE_INTEGER。 figures 精度位数。 必须是 1 和 5 之间的数字。 默认值: 3。返回 perf_hooks.monitorEventLoopDelay([options])options resolution 以毫秒为单位的采样率。 必须大于零。 默认值: 10。返回: 此属性是 Node.js 的扩展。 它在 Web 浏览器中不可用。 创建可随时间采样并报告事件循环延迟的 IntervalHistogram 对象。 延迟将以纳秒为单位报告。 使用计时器来检测近似的事件循环延迟是有效的，因为计时器的执行与 libuv 事件循环的生命周期特别相关。 也就是说，循环中的延迟会导致计时器执行的延迟，而这些延迟正是此 API 旨在检测的。 123456789101112const &#123; monitorEventLoopDelay &#125; = require(&#x27;node:perf_hooks&#x27;);const h = monitorEventLoopDelay(&#123; resolution: 20 &#125;);h.enable();// 做点什么。h.disable();console.log(h.min);console.log(h.max);console.log(h.mean);console.log(h.stddev);console.log(h.percentiles);console.log(h.percentile(50));console.log(h.percentile(99)); Histogram 类histogram.count直方图记录的样本数。 histogram.countBigInt直方图记录的样本数。 histogram.exceeds事件循环延迟超过最大 1 小时事件循环延迟阈值的次数。 histogram.exceedsBigInt事件循环延迟超过最大 1 小时事件循环延迟阈值的次数。 histogram.max记录的事件循环延迟的最大值。 histogram.maxBigInt记录的事件循环延迟的最大值。 histogram.mean记录的事件循环延迟的平均值。 histogram.min记录的事件循环延迟的最小值。 histogram.minBigInt记录的事件循环延迟的最小值。 histogram.percentile(percentile)percentile 百分位值的范围是 (0, 100]。返回: 返回给定的百分位数的值。 histogram.percentileBigInt(percentile)#percentile 百分位值的范围是 (0, 100]。返回: 返回给定的百分位数的值。 histogram.percentiles返回详细说明累积的百分位分布的 Map 对象。 histogram.percentilesBigInt返回详细说明累积的百分位分布的 Map 对象。 histogram.reset()重置收集的直方图数据。 histogram.stddev记录的事件循环延迟的标准偏差。 IntervalHistogram 类继承 Histogram 类在给定的时间间隔内定期更新的 Histogram。 histogram.disable()禁用更新间隔计时器。 如果计时器被停止，则返回 true，如果已被停止，则返回 false。 histogram.enable()启用更新间隔计时器。 如果计时器被启动，则返回 true，如果已被启动，则返回 false。 克隆 IntervalHistogram 实例可以通过 克隆。在接收端，直方图被克隆为没有实现 enable() 和 disable() 方法的普通 对象。 RecordableHistogram 类继承 Histogram 类histogram.add(other)other 将 other 中的值添加到此直方图中。 histogram.record(val)val | 在直方图中记录的数量。 histogram.recordDelta()计算自上次调用 recordDelta() 以来经过的时间量（以纳秒为单位），并在直方图中记录该量。 示例测量异步操作的时长以下示例使用异步钩子和性能 API 来测量超时操作的实际持续时间（包括执行回调所花费的时间）。 123456789101112131415161718192021222324252627282930313233343536&#x27;use strict&#x27;;const async_hooks = require(&#x27;node:async_hooks&#x27;);const &#123; performance, PerformanceObserver&#125; = require(&#x27;node:perf_hooks&#x27;);const set = new Set();const hook = async_hooks.createHook(&#123; init(id, type) &#123; if (type === &#x27;Timeout&#x27;) &#123; performance.mark(`Timeout-$&#123;id&#125;-Init`); set.add(id); &#125; &#125;, destroy(id) &#123; if (set.has(id)) &#123; set.delete(id); performance.mark(`Timeout-$&#123;id&#125;-Destroy`); performance.measure(`Timeout-$&#123;id&#125;`, `Timeout-$&#123;id&#125;-Init`, `Timeout-$&#123;id&#125;-Destroy`); &#125; &#125;&#125;);hook.enable();const obs = new PerformanceObserver((list, observer) =&gt; &#123; console.log(list.getEntries()[0]); performance.clearMarks(); performance.clearMeasures(); observer.disconnect();&#125;);obs.observe(&#123; entryTypes: [&#x27;measure&#x27;], buffered: true &#125;);setTimeout(() =&gt; &#123;&#125;, 1000); 测量加载依赖的耗时以下示例测量加载依赖项的 require() 操作的持续时间： 12345678910111213141516171819202122232425&#x27;use strict&#x27;;const &#123; performance, PerformanceObserver&#125; = require(&#x27;node:perf_hooks&#x27;);const mod = require(&#x27;node:module&#x27;);// Monkey 修补 require 函数mod.Module.prototype.require = performance.timerify(mod.Module.prototype.require);require = performance.timerify(require);// 激活观察者const obs = new PerformanceObserver((list) =&gt; &#123; const entries = list.getEntries(); entries.forEach((entry) =&gt; &#123; console.log(`require(&#x27;$&#123;entry[0]&#125;&#x27;)`, entry.duration); &#125;); performance.clearMarks(); performance.clearMeasures(); obs.disconnect();&#125;);obs.observe(&#123; entryTypes: [&#x27;function&#x27;], buffered: true &#125;);require(&#x27;some-module&#x27;); 测量一次 HTTP 往返需要多长时间以下示例用于跟踪 HTTP 客户端 (OutgoingMessage) 和 HTTP 请求 (IncomingMessage) 花费的时间。 对于 HTTP 客户端，是指发起请求到收到响应的时间间隔，对于 HTTP 请求，是指从接收请求到发送响应的时间间隔： 12345678910111213141516171819&#x27;use strict&#x27;;const &#123; PerformanceObserver &#125; = require(&#x27;node:perf_hooks&#x27;);const http = require(&#x27;node:http&#x27;);const obs = new PerformanceObserver((items) =&gt; &#123; items.getEntries().forEach((item) =&gt; &#123; console.log(item); &#125;);&#125;);obs.observe(&#123; entryTypes: [&#x27;http&#x27;] &#125;);const PORT = 8080;http.createServer((req, res) =&gt; &#123; res.end(&#x27;ok&#x27;);&#125;).listen(PORT, () =&gt; &#123; http.get(`http://127.0.0.1:$&#123;PORT&#125;`);&#125;); 测量连接成功时 net.connect（仅适用于 TCP）需要多长时间 123456789101112131415&#x27;use strict&#x27;;const &#123; PerformanceObserver &#125; = require(&#x27;node:perf_hooks&#x27;);const net = require(&#x27;node:net&#x27;);const obs = new PerformanceObserver((items) =&gt; &#123; items.getEntries().forEach((item) =&gt; &#123; console.log(item); &#125;);&#125;);obs.observe(&#123; entryTypes: [&#x27;net&#x27;] &#125;);const PORT = 8080;net.createServer((socket) =&gt; &#123; socket.destroy();&#125;).listen(PORT, () =&gt; &#123; net.connect(PORT);&#125;); 测量请求成功时 DNS 需要多长时间 1234567891011&#x27;use strict&#x27;;const &#123; PerformanceObserver &#125; = require(&#x27;node:perf_hooks&#x27;);const dns = require(&#x27;node:dns&#x27;);const obs = new PerformanceObserver((items) =&gt; &#123; items.getEntries().forEach((item) =&gt; &#123; console.log(item); &#125;);&#125;);obs.observe(&#123; entryTypes: [&#x27;dns&#x27;] &#125;);dns.lookup(&#x27;localhost&#x27;, () =&gt; &#123;&#125;);dns.promises.resolve(&#x27;localhost&#x27;);"},{"title":"nodejs基础知识(13)","date":"2023-02-28T13:09:20.000Z","updated":"2023-07-24T09:24:46.501Z","comments":true,"path":"nodejs/nodejs-note-23.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-23.html","excerpt":"","text":"process 进程‘beforeExit’ 事件当 Node.js 清空其事件循环并且没有额外的工作要安排时，则会触发 ‘beforeExit’ 事件。 通常情况下，当没有工作要调度时，Node.js 进程会退出，但是注册在 ‘beforeExit’ 事件上的监听器可以进行异步的调用，从而使 Node.js 进程继续。 调用监听器回调函数时将 process.exitCode 的值作为唯一的参数传入。 对于导致显式终止的条件，例如调用 process.exit() 或未捕获的异常，则不会触发 ‘beforeExit’ 事件。 ‘beforeExit’ 不应用作 ‘exit’ 事件的替代，除非打算安排额外的工作。 12345678910111213141516import process from &#x27;node:process&#x27;;process.on(&#x27;beforeExit&#x27;, (code) =&gt; &#123; console.log(&#x27;Process beforeExit event with code: &#x27;, code);&#125;);process.on(&#x27;exit&#x27;, (code) =&gt; &#123; console.log(&#x27;Process exit event with code: &#x27;, code);&#125;);console.log(&#x27;This message is displayed first.&#x27;);// 打印:// This message is displayed first.// Process beforeExit event with code: 0// Process exit event with code: 0 ‘disconnect’ 事件#如果 Node.js 进程是使用 IPC 通道衍生（参见子进程和集群文档），则在 IPC 通道关闭时将触发 ‘disconnect’ 事件。 ‘exit’ 事件code 当 Node.js 进程由于以下任一原因即将退出时，则会触发 ‘exit’ 事件： process.exit() 方法被显式调用； Node.js 事件循环不再需要执行任何额外的工作。此时没有办法阻止事件循环的退出，一旦所有 ‘exit’ 监听器都运行完毕，则 Node.js 进程将终止。监听器回调函数使用 process.exitCode 属性指定的退出码或传给 process.exit() 方法的 exitCode 参数调用。12345import process from &#x27;node:process&#x27;;process.on(&#x27;exit&#x27;, (code) =&gt; &#123; console.log(`About to exit with code: $&#123;code&#125;`);&#125;); 监听器函数必须只执行同步的操作。 Node.js 进程将在调用 ‘exit’ 事件监听器之后立即退出，从而使任何仍在事件循环中排队的其他工作被丢弃。 例如，在以下示例中，超时永远不会发生：1234567import process from &#x27;node:process&#x27;;process.on(&#x27;exit&#x27;, (code) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;This will not run&#x27;); &#125;, 0);&#125;); ‘message’ 事件message | | | | 解析的 JSON 对象或可序列化的原始值。sendHandle &lt;net.Server&gt; | &lt;net.Socket&gt; net.Server 或 net.Socket 对象、或未定义。如果 Node.js 进程是使用 IPC 通道衍生（参见子进程和集群文档），则每当子进程收到父进程使用 childprocess.send() 发送的消息时，就会触发 ‘message’ 事件。消息经过序列化和解析。 结果消息可能与最初发送的消息不同。如果在衍生进程时将 serialization 选项设置为 advanced，则 message 参数可以包含 JSON 无法表示的数据。 ‘rejectionHandled’ 事件promise 最近处理的 promise。每当 Promise 被拒绝并且错误句柄被附加到它（例如使用 promise.catch()）晚于一轮 Node.js 事件循环时，则 ‘rejectionHandled’ 事件就会触发。 Promise 对象会在 ‘unhandledRejection’ 事件中先处理，但在处理过程中获得了拒绝句柄。对于 Promise 链，没有始终可以处理拒绝的顶层概念。 由于本质上是异步的，Promise 拒绝可以在未来的某个时间点处理，可能比触发 ‘unhandledRejection’ 事件所需的事件循环轮询要晚得多。 另一种表述方式是，与同步代码中未处理的异常列表不断增长不同，promise 中未处理的拒绝列表可能会不断增长和缩小。 在同步代码中，当未处理的异常列表增长时，会触发 ‘uncaughtException’ 事件。在异步代码中，当未处理的拒绝列表增长时，会触发 ‘unhandledRejection’ 事件，当未处理的拒绝列表缩小时，会触发 ‘rejectionHandled’ 事件。 123456789import process from &#x27;node:process&#x27;;const unhandledRejections = new Map();process.on(&#x27;unhandledRejection&#x27;, (reason, promise) =&gt; &#123; unhandledRejections.set(promise, reason);&#125;);process.on(&#x27;rejectionHandled&#x27;, (promise) =&gt; &#123; unhandledRejections.delete(promise);&#125;); 在这个例子中，unhandledRejections Map 将随着时间的推移而增长和缩小，反映了开始未处理然后变成处理的拒绝。 可以定期在错误日志中记录此类错误（这可能最适合长时间运行的应用程序）或在进程退出时（这可能对脚本最方便）。 ‘uncaughtException’ 事件err 未捕获的异常。origin 指示异常是源自未处理的拒绝还是源自同步错误。 可以是 ‘uncaughtException’ 或 ‘unhandledRejection’。 后者用于在基于 Promise 的异步上下文中发生异常（或者如果 Promise 被拒绝）并且 –unhandled-rejections 标志设置为 strict 或 throw（这是默认值）并且拒绝未被处理，或者当拒绝发生在命令行入口点的 ES 模块静态加载阶段。当未捕获的 JavaScript 异常一直冒泡回到事件循环时，则会触发 ‘uncaughtException’ 事件。 默认情况下，Node.js 通过将堆栈跟踪打印到 stderr 并以代码 1 退出，覆盖任何先前设置的 process.exitCode 来处理此类异常。 为 ‘uncaughtException’ 事件添加句柄会覆盖此默认行为。 或者，更改 ‘uncaughtException’ 处理程序中的 process.exitCode，这将导致进程以提供的退出码退出。 否则，在存在此类句柄的情况下，进程将以 0 退出。 1234567891011121314151617import process from &#x27;node:process&#x27;;process.on(&#x27;uncaughtException&#x27;, (err, origin) =&gt; &#123; fs.writeSync( process.stderr.fd, `Caught exception: $&#123;err&#125;\\n` + `Exception origin: $&#123;origin&#125;` );&#125;);setTimeout(() =&gt; &#123; console.log(&#x27;This will still run.&#x27;);&#125;, 500);// 故意引发异常，但不捕获。nonexistentFunc();console.log(&#x27;This will not run.&#x27;); 通过安装 ‘uncaughtExceptionMonitor’ 监听器，可以在不覆盖退出进程的默认行为的情况下监视 ‘uncaughtException’ 事件。 注意: 正确使用 ‘uncaughtException’‘uncaughtException’ 是用于异常处理的粗略机制，仅用作最后的手段。 事件_不应该_用作 On Error Resume Next 的等价物。 未处理的异常本质上意味着应用程序处于未定义状态。 在没有从异常中正确恢复的情况下尝试恢复应用程序代码可能会导致其他不可预见和不可预测的问题。 从事件句柄中抛出的异常将不会被捕获。 而是，该进程将以非零退出码退出，并将打印堆栈跟踪。 这是为了避免无限递归。 尝试在未捕获异常后正常恢复类似于升级计算机时拔掉电源线。 十有八九，什么都没有发生。 但是第十次，系统损坏了。 ‘uncaughtException’ 的正确用法是在关闭进程之前对分配的资源（例如文件描述符、句柄等）执行同步清理。 在 ‘uncaughtException’ 之后恢复正常操作是不安全的。 为了以更可靠的方式重新启动崩溃的应用程序，无论 ‘uncaughtException’ 是否触发，都应该在单独的进程中使用外部监视器来检测应用程序故障并根据需要恢复或重新启动。 ‘uncaughtExceptionMonitor’ 事件err 未捕获的异常。origin 指示异常是源自未处理的拒绝还是源自同步错误。 可以是 ‘uncaughtException’ 或 ‘unhandledRejection’。 后者用于在基于 Promise 的异步上下文中发生异常（或者如果 Promise 被拒绝）并且 –unhandled-rejections 标志设置为 strict 或 throw（这是默认值）并且拒绝未被处理，或者当拒绝发生在命令行入口点的 ES 模块静态加载阶段。‘uncaughtExceptionMonitor’ 事件在 ‘uncaughtException’ 事件触发或通过 process.setUncaughtExceptionCaptureCallback() 安装的钩子被调用之前触发。 一旦触发 ‘uncaughtException’ 事件，则安装 ‘uncaughtExceptionMonitor’ 监听器不会更改行为。 如果没有安装 ‘uncaughtException’ 监听器，则进程仍然会崩溃。 123456789import process from &#x27;node:process&#x27;;process.on(&#x27;uncaughtExceptionMonitor&#x27;, (err, origin) =&gt; &#123; MyMonitoringTool.logSync(err, origin);&#125;);// 故意引发异常，但不捕获。nonexistentFunc();// 仍然崩溃 Node.js ‘unhandledRejection’ 事件reason | Promise 被拒绝的对象（通常是 Error 对象）。promise 被拒绝的 promise。每当 Promise 被拒绝并且在事件循环的一个轮询内没有错误句柄附加到承诺时，则会触发 ‘unhandledRejection’ 事件。 使用 Promise 进行编程时，异常被封装为“被拒绝的 promise”。 拒绝可以使用 promise.catch() 捕获和处理，并通过 Promise 链传播。 ‘unhandledRejection’ 事件对于检测和跟踪尚未处理的被拒绝的 promise 很有用。 123456789101112131415161718192021import process from &#x27;node:process&#x27;;process.on(&#x27;unhandledRejection&#x27;, (reason, promise) =&gt; &#123; console.log(&#x27;Unhandled Rejection at:&#x27;, promise, &#x27;reason:&#x27;, reason); // 应用程序特定的日志记录，在此处抛出错误或其他逻辑&#125;);somePromise.then((res) =&gt; &#123; return reportToUser(JSON.pasre(res)); // 注意错别字 (`pasre`)&#125;); // 无 `.catch()` 或 `.then()`// 以下也将触发 &#x27;unhandledRejection&#x27; 事件被触发：import process from &#x27;node:process&#x27;;function SomeResource() &#123; // 最初将加载状态设置为被拒绝的 promise this.loaded = Promise.reject(new Error(&#x27;Resource not yet loaded!&#x27;));&#125;const resource = new SomeResource();// resource.loaded 上没有 .catch 或 .then 在此示例情况下，可以将拒绝作为开发人员错误进行跟踪，这通常是其他 ‘unhandledRejection’ 事件的情况。 为了解决此类故障，可以将非操作 .catch(() =&gt; { }) 句柄附加到 resource.loaded，这将阻止触发 ‘unhandledRejection’ 事件。 ‘warning’ 事件warning 警告的主要属性是： name 警告的名称。 默认值: ‘Warning’。 message 系统提供的警告描述。 stack 代码中发出警告的位置的堆栈跟踪。每当 Node.js 触发进程警告时，则会触发 ‘warning’ 事件。 进程警告类似于错误，因为其描述了引起用户注意的异常情况。 但是，警告不是正常 Node.js 和 JavaScript 错误处理流程的一部分。 Node.js 可以在检测到可能导致次优应用程序性能、错误或安全漏洞的不良编码实践时触发警告。 1234567import process from &#x27;node:process&#x27;;process.on(&#x27;warning&#x27;, (warning) =&gt; &#123; console.warn(warning.name); // 打印警告名称 console.warn(warning.message); // 打印警告信息 console.warn(warning.stack); // 打印堆栈跟踪&#125;); 默认情况下，Node.js 会将进程警告打印到 stderr。 –no-warnings 命令行选项可用于抑制默认控制台输出，但 ‘warning’ 事件仍将由 process 对象触发。 以下示例说明了在向事件添加过多监听器时打印到 stderr 的警告： 123456$ node&gt; events.defaultMaxListeners = 1;&gt; process.on(&#x27;foo&#x27;, () =&gt; &#123;&#125;);&gt; process.on(&#x27;foo&#x27;, () =&gt; &#123;&#125;);&gt; (node:38638) MaxListenersExceededWarning: Possible EventEmitter memory leak// detected. 2 foo listeners added. Use emitter.setMaxListeners() to increase limit 相比之下，以下示例关闭默认警告输出并向 ‘warning’ 事件添加自定义句柄： 123456$ node --no-warnings&gt; const p = process.on(&#x27;warning&#x27;, (warning) =&gt; console.warn(&#x27;Do not do that!&#x27;));&gt; events.defaultMaxListeners = 1;&gt; process.on(&#x27;foo&#x27;, () =&gt; &#123;&#125;);&gt; process.on(&#x27;foo&#x27;, () =&gt; &#123;&#125;);&gt; Do not do that! –trace-warnings 命令行选项可用于使警告的默认控制台输出包括警告的完整堆栈跟踪。使用 –throw-deprecation 命令行标志启动 Node.js 将导致自定义弃用警告作为异常抛出。使用 –trace-deprecation 命令行标志将导致自定义弃用与堆栈跟踪一起打印到 stderr。使用 –no-deprecation 命令行标志将抑制自定义弃用的所有报告。*-deprecation 命令行标志仅影响使用名称 ‘DeprecationWarning’ 的警告。 ‘worker’ 事件worker 创建的 。创建新的 线程后会触发 ‘worker’ 事件。 触发自定义的告警请参阅 process.emitWarning() 方法以发出自定义或特定于应用程序的警告。 Node.js 警告的名称Node.js 触发的警告类型（由 name 属性标识）没有严格的指导方针。 可以随时添加新类型的警告。 一些最常见的警告类型包括： ‘DeprecationWarning’ - 表示使用已弃用的 Node.js API 或功能。 此类警告必须包含标识弃用代码的 ‘code’ 属性。‘ExperimentalWarning’ - 表示使用实验的 Node.js API 或功能。 必须谨慎使用此类功能，因为它们可能随时更改，并且不受与受支持功能相同的严格语义版本控制和长期支持政策的约束。‘MaxListenersExceededWarning’ - 表示在 EventEmitter 或 EventTarget 上注册了太多给定事件的监听器。 这通常表示内存泄漏。‘TimeoutOverflowWarning’ - 表示已向 setTimeout() 或 setInterval() 函数提供了无法容纳在 32 位有符号整数内的数值。‘UnsupportedWarning’ - 表示使用不受支持的选项或功能，这些选项或功能将被忽略而不是被视为错误。 一个示例是在使用 HTTP/2 兼容性 API 时使用 HTTP 响应状态消息。 信号事件当 Node.js 进程收到信号时，则将触发信号事件。 有关标准 POSIX 信号名称（例如 ‘SIGINT’、’SIGHUP’ 等）的列表，请参阅 signal(7)。 信号在 Worker 线程上不可用。信号句柄将接收信号的名称（’SIGINT’、’SIGTERM’ 等）作为第一个参数。每个事件的名称将是信号的大写通用名称（例如 ‘SIGINT’ 表示 SIGINT 信号）。 12345678910111213141516import process from &#x27;node:process&#x27;;// 从标准输入开始读取，因此进程不会退出。process.stdin.resume();process.on(&#x27;SIGINT&#x27;, () =&gt; &#123; console.log(&#x27;Received SIGINT. Press Control-D to exit.&#x27;);&#125;);// 使用单个函数处理多个信号function handle(signal) &#123; console.log(`Received $&#123;signal&#125;`);&#125;process.on(&#x27;SIGINT&#x27;, handle);process.on(&#x27;SIGTERM&#x27;, handle); ‘SIGUSR1’ 由 Node.js 预留以启动调试器。 可以安装监听器，但这样做可能会干扰调试器。‘SIGTERM’ 和 ‘SIGINT’ 在非 Windows 平台上具有默认的句柄，其在使用代码 128 + signal number 退出之前重置终端模式。 如果这些信号之一安装了监听器，则其默认行为将被删除（Node.js 将不再退出）。‘SIGPIPE’ 默认情况下忽略。 它可以安装监听器。‘SIGHUP’ 在 Windows 上是在关闭控制台窗口时生成，在其他平台上是在各种类似条件下生成。 参见 signal(7)。 它可以安装监听器，但是 Node.js 将在大约 10 秒后被 Windows 无条件地终止。 在非 Windows 平台上，SIGHUP 的默认行为是终止 Node.js，但一旦安装了监听器，则其默认行为将被删除。‘SIGTERM’ Windows 上不支持，可以监听。所有平台都支持来自终端的 ‘SIGINT’，通常可以使用 Ctrl+C 生成（但是这是可配置的）。 当启用终端原始模式并使用 Ctrl+C 时不会生成它。‘SIGBREAK’ 在 Windows 上，当按下 Ctrl+Break 时会发送。 在非 Windows 平台上，它可以被监听，但无法发送或生成它。‘SIGWINCH’ 当调整控制台大小时会发送。 在 Windows 上，这只会发生在当光标移动时写入控制台，或者当在原始模式下使用可读的终端时。‘SIGKILL’ 不能安装监听器，它会无条件地终止所有平台上的 Node.js。‘SIGSTOP’ 不能安装监听器。‘SIGBUS’、’SIGFPE’、’SIGSEGV’ 和 ‘SIGILL’，当不使用 kill(2) 人为引发时，本质上会使进程处于调用 JS 监听器不安全的状态。 这样做可能会导致进程停止响应。0 可以发送来测试进程是否存在，如果进程存在则没影响，如果进程不存在则抛出错误。Windows 不支持信号，因此没有等价的使用信号来终止，但 Node.js 提供了一些对 process.kill() 和 subprocess.kill() 的模拟：发送 SIGINT、SIGTERM、和 SIGKILL 会导致目标进程无条件的终止，之后子进程会报告进程被信号终止。发送信号 0 可以作为独立于平台的方式来测试进程是否存在。 process.abort()process.abort() 方法会导致 Node.js 进程立即退出并生成一个核心文件。此特性在 Worker 线程中不可用。 process.allowedNodeEnvironmentFlagsprocess.allowedNodeEnvironmentFlags 属性是 NODE_OPTIONS 环境变量中允许的特殊的只读 Set 标志。 process.allowedNodeEnvironmentFlags 继承了 Set，但覆盖了 Set.prototype.has 以识别几种不同的可能标志表示。 在以下情况下，process.allowedNodeEnvironmentFlags.has() 将返回 true： 标志可以省略前导单（-）或双（–）破折号；例如，inspect-brk 代表 –inspect-brk，或 r 代表 -r。 传给 V8 的标志（如 –v8-options 中所列）可能会替换一个或多个_非前导_破折号作为下划线，反之亦然；例如，–perf_basic_prof、–perf-basic-prof、–perf_basic-prof 等。 标志可能包含一个或多个等于 (=) 字符；在第一个等号之后并包括在内的所有字符都将被忽略；例如，–stack-trace-limit=100。 标志_必须_在 NODE_OPTIONS 中是允许的。 在 process.allowedNodeEnvironmentFlags 上迭代时，标志只会出现_一次_；每个都以一个或多个破折号开头。 传给 V8 的标志将包含下划线而不是非前导破折号： 123456789import &#123; allowedNodeEnvironmentFlags &#125; from &#x27;node:process&#x27;;allowedNodeEnvironmentFlags.forEach((flag) =&gt; &#123; // -r // --inspect-brk // --abort_on_uncaught_exception // ...&#125;);// process.allowedNodeEnvironmentFlags 的方法 add()、clear() 和 delete() 什么都不做，会静默失败。 如果 Node.js 编译时_没有_ NODE_OPTIONS 支持（显示在 process.config 中），那么 process.allowedNodeEnvironmentFlags 将包含_本来_允许的内容。 process.arch为其编译 Node.js 二进制文件的操作系统 CPU 架构。 可能的值为：’arm’、’arm64’、’ia32’、’mips’、’mipsel’、’ppc’、’ppc64’、’s390’、’s390x’、以及 ‘x64’。 123import &#123; arch &#125; from &#x27;node:process&#x27;;console.log(`This processor architecture is $&#123;arch&#125;`); process.argvprocess.argv 属性返回数组，其中包含启动 Node.js 进程时传入的命令行参数。 第一个元素将是 process.execPath。 如果需要访问 argv[0] 的原始值，请参阅 process.argv0。 第二个元素将是正在执行的 JavaScript 文件的路径。 其余元素将是任何其他命令行参数。 例如，假设 process-args.js 有以下脚本： 123456import &#123; argv &#125; from &#x27;node:process&#x27;;// 打印 process.argvargv.forEach((val, index) =&gt; &#123; console.log(`$&#123;index&#125;: $&#123;val&#125;`);&#125;); 以如下方式启动 Node.js 进程： 12345678$ node process-args.js one two=three four将生成输出：0: /usr/local/bin/node1: /Users/mjr/work/node/process-args.js2: one3: two=three4: four process.argv0process.argv0 属性存储了 Node.js 启动时传入的 argv[0] 原始值的只读副本。 12345$ bash -c &#x27;exec -a customArgv0 ./node&#x27;&gt; process.argv[0]&#x27;/Volumes/code/external/node/out/Release/node&#x27;&gt; process.argv0&#x27;customArgv0&#x27; process.channel如果 Node.js 进程是使用 IPC 通道衍生（参见子进程文档），则 process.channel 属性是对 IPC 通道的引用。 如果不存在 IPC 通道，则此属性为 undefined。 process.channel.ref()如果之前已调用过 .unref()，则此方法使 IPC 通道保持进程的事件循环运行。通常，这是通过 process 对象上的 ‘disconnect’ 和 ‘message’ 监听器的数量来管理的。 但是，此方法可用于显式请求特定行为。 process.channel.unref()此方法使 IPC 通道不会保持进程的事件循环运行，并且即使在通道打开时也让它完成。通常，这是通过 process 对象上的 ‘disconnect’ 和 ‘message’ 监听器的数量来管理的。 但是，此方法可用于显式请求特定行为。 process.chdir(directory)directory process.chdir() 方法更改 Node.js 进程的当前工作目录，如果失败则抛出异常（例如，如果指定的 directory 不存在）。 123456789import &#123; chdir, cwd &#125; from &#x27;node:process&#x27;;console.log(`Starting directory: $&#123;cwd()&#125;`);try &#123; chdir(&#x27;/tmp&#x27;); console.log(`New directory: $&#123;cwd()&#125;`);&#125; catch (err) &#123; console.error(`chdir: $&#123;err&#125;`);&#125; 此特性在 Worker 线程中不可用。 process.configprocess.config 属性返回 Object，其中包含用于编译当前 Node.js 可执行文件的配置选项的 JavaScript 表示。 这与运行 ./configure 脚本时生成的 config.gypi 文件相同。可能的输出示例如下所示： 12345678910111213141516171819202122232425&#123; target_defaults: &#123; cflags: [], default_configuration: &#x27;Release&#x27;, defines: [], include_dirs: [], libraries: [] &#125;, variables: &#123; host_arch: &#x27;x64&#x27;, napi_build_version: 5, node_install_npm: &#x27;true&#x27;, node_prefix: &#x27;&#x27;, node_shared_cares: &#x27;false&#x27;, node_shared_http_parser: &#x27;false&#x27;, node_shared_libuv: &#x27;false&#x27;, node_shared_zlib: &#x27;false&#x27;, node_use_dtrace: &#x27;false&#x27;, node_use_openssl: &#x27;true&#x27;, node_shared_openssl: &#x27;false&#x27;, strict_aliasing: &#x27;true&#x27;, target_arch: &#x27;x64&#x27;, v8_use_snapshot: 1 &#125;&#125; process.config 属性是非只读的，并且生态系统中存在已知扩展、修改或完全替换 process.config 值的现有模块。修改 process.config 属性或 process.config 对象的任何子属性已被弃用。 在未来的版本中，process.config 将变为只读。 process.connected如果 Node.js 进程使用 IPC 通道衍生（参见子进程和集群文档），则只要 IPC 通道连接，process.connected 属性将返回 true，并在调用 process.disconnect() 后返回 false。一旦 process.connected 为 false，就不能再使用 process.send() 通过 IPC 通道发送消息。 process.cpuUsage([previousValue])#previousValue 先前调用 process.cpuUsage() 的返回值返回: user system process.cpuUsage() 方法在具有属性 user 和 system 的对象中返回当前进程的用户和系统 CPU 时间使用情况，其值为微秒值（百万分之一秒）。 这些值分别测量在用户和系统代码中花费的时间，如果多个 CPU 内核为此进程执行工作，则最终可能会大于实际经过的时间。 先前调用 process.cpuUsage() 的结果可以作为参数传给函数，以获取差异读数。 1234567891011import &#123; cpuUsage &#125; from &#x27;node:process&#x27;;const startUsage = cpuUsage();// &#123; user: 38579, system: 6986 &#125;// 使 CPU 旋转 500 毫秒const now = Date.now();while (Date.now() - now &lt; 500);console.log(cpuUsage(startUsage));// &#123; user: 514883, system: 11226 &#125; process.cwd()process.cwd() 方法返回 Node.js 进程的当前工作目录。 123import &#123; cwd &#125; from &#x27;node:process&#x27;;console.log(`Current directory: $&#123;cwd()&#125;`); process.debugPort启用时 Node.js 调试器使用的端口。 123import process from &#x27;node:process&#x27;;process.debugPort = 5858; process.disconnect()如果 Node.js 进程是使用 IPC 通道衍生（参见子进程和集群文档），则 process.disconnect() 方法将关闭通往父进程的 IPC 通道，一旦没有其他连接使其保持活动状态，则允许子进程正常退出。调用 process.disconnect() 的效果和从父进程调用 ChildProcess.disconnect() 是一样的。如果 Node.js 进程不是使用 IPC 通道衍生，则 process.disconnect() 将是 undefined。 process.dlopen(module, filename[, flags]) module filename flags &lt;os.constants.dlopen&gt; 默认值: os.constants.dlopen.RTLD_LAZYprocess.dlopen() 方法允许动态加载共享对象。 require() 主要用于加载 C++ 插件，除非特殊情况，否则不应直接使用。 换句话说，require() 应该优先于 process.dlopen()，除非有特定的原因，例如自定义 dlopen 标志或从 ES 模块加载。 flags 参数是整数，允许指定 dlopen 行为。 有关详细信息，请参阅 os.constants.dlopen 文档。调用 process.dlopen() 时的一个重要要求是必须传入 module 实例。 然后可以通过 module.exports 访问由 C++ 插件导出的函数。 下面的示例显示了如何加载名为 local.node 的 C++ 插件，该插件导出 foo 函数。 通过传入 RTLD_NOW 常量，在调用返回之前加载所有符号。 在此示例中，假定常量可用。 12345678import &#123; dlopen &#125; from &#x27;node:process&#x27;;import &#123; constants &#125; from &#x27;node:os&#x27;;import &#123; fileURLToPath &#125; from &#x27;node:url&#x27;;const module = &#123; exports: &#123;&#125; &#125;;dlopen(module, fileURLToPath(new URL(&#x27;local.node&#x27;, import.meta.url)), constants.dlopen.RTLD_NOW);module.exports.foo(); process.emitWarning(warning[, options])warning | 要触发的警告。options type 当 warning 是 String 时，type 是用于触发警告的 type 的名称。 默认值: ‘Warning’。 code 触发的警告实例的唯一标识符。 ctor 当 warning 为 String 时，ctor 是可选函数，用于限制生成的堆栈跟踪。 默认值: process.emitWarning。 detail 要包含在错误中的额外文本。process.emitWarning() 方法可用于触发自定义或特定于应用程序的进程警告。 这些可以通过向 ‘warning’ 事件添加句柄来监听。12345678910import &#123; emitWarning &#125; from &#x27;node:process&#x27;;// 触发带有代码和其他详细信息的警告。emitWarning(&#x27;Something happened!&#x27;, &#123; code: &#x27;MY_WARNING&#x27;, detail: &#x27;This is some additional information&#x27;&#125;);// 触发:// (node:56338) [MY_WARNING] Warning: Something happened!// This is some additional information 在此示例中，Error 对象由 process.emitWarning() 在内部生成并传给 ‘warning’ 句柄。123456789import process from &#x27;node:process&#x27;;process.on(&#x27;warning&#x27;, (warning) =&gt; &#123; console.warn(warning.name); // &#x27;Warning&#x27; console.warn(warning.message); // &#x27;Something happened!&#x27; console.warn(warning.code); // &#x27;MY_WARNING&#x27; console.warn(warning.stack); // Stack trace console.warn(warning.detail); // &#x27;This is some additional information&#x27;&#125;); 如果 warning 作为 Error 对象传入，则忽略 options 参数。 process.emitWarning(warning[, type[, code]][, ctor]) warning | 要触发的警告。 type 当 warning 是 String 时，type 是用于触发警告的 type 的名称。 默认值: ‘Warning’。 code 触发的警告实例的唯一标识符。 ctor 当 warning 为 String 时，ctor 是可选函数，用于限制生成的堆栈跟踪。 默认值: process.emitWarning。process.emitWarning() 方法可用于触发自定义或特定于应用程序的进程警告。 这些可以通过向 ‘warning’ 事件添加句柄来监听。1234567891011121314import &#123; emitWarning &#125; from &#x27;node:process&#x27;;// 使用字符串触发警告。emitWarning(&#x27;Something happened!&#x27;);// 触发: (node: 56338) Warning: Something happened!import &#123; emitWarning &#125; from &#x27;node:process&#x27;;// 使用字符串和类型触发警告。emitWarning(&#x27;Something Happened!&#x27;, &#x27;CustomWarning&#x27;);// 触发: (node:56338) CustomWarning: Something Happened!import &#123; emitWarning &#125; from &#x27;node:process&#x27;;emitWarning(&#x27;Something happened!&#x27;, &#x27;CustomWarning&#x27;, &#x27;WARN001&#x27;);// 触发: (node:56338) [WARN001] CustomWarning: Something happened! 在前面的每个示例中，Error 对象由 process.emitWarning() 在内部生成并传给 ‘warning’ 句柄。12345678import process from &#x27;node:process&#x27;;process.on(&#x27;warning&#x27;, (warning) =&gt; &#123; console.warn(warning.name); console.warn(warning.message); console.warn(warning.code); console.warn(warning.stack);&#125;); 如果 warning 作为 Error 对象传入，则它将被不加修改地传给 ‘warning’ 事件句柄（并且可选的 type、code 和 ctor 参数将被忽略）：12345678910import &#123; emitWarning &#125; from &#x27;node:process&#x27;;// 使用 Error 对象触发警告。const myWarning = new Error(&#x27;Something happened!&#x27;);// 使用错误名称属性指定类型名称myWarning.name = &#x27;CustomWarning&#x27;;myWarning.code = &#x27;WARN001&#x27;;emitWarning(myWarning);// 触发: (node:56338) [WARN001] CustomWarning: Something happened! 如果 warning 不是字符串或 Error 对象，则抛出 TypeError。虽然进程警告使用 Error 对象，但进程警告机制不是替代正常错误处理机制。如果警告 type 为 ‘DeprecationWarning’，则执行以下额外处理： 如果使用 –throw-deprecation 命令行标志，则弃用警告将作为异常抛出，而不是作为事件触发。 如果使用 –no-deprecation 命令行标志，则会取消弃用警告。 如果使用 –trace-deprecation 命令行标志，则弃用警告将与完整堆栈跟踪一起打印到 stderr。 避免重复警告作为最佳实践，每个进程只应触发一次警告。 为此，则将 emitWarning() 放在布尔值后面。 123456789101112import &#123; emitWarning &#125; from &#x27;node:process&#x27;;function emitMyWarning() &#123; if (!emitMyWarning.warned) &#123; emitMyWarning.warned = true; emitWarning(&#x27;Only warn once!&#x27;); &#125;&#125;emitMyWarning();// 触发: (node: 56339) Warning: Only warn once!emitMyWarning();// 什么都不触发 process.envprocess.env 属性返回包含用户环境的对象。 参见 environ(7)。 此对象的示例如下所示： 123456789101112&#123; TERM: &#x27;xterm-256color&#x27;, SHELL: &#x27;/usr/local/bin/bash&#x27;, USER: &#x27;maciej&#x27;, PATH: &#x27;~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin&#x27;, PWD: &#x27;/Users/maciej&#x27;, EDITOR: &#x27;vim&#x27;, SHLVL: &#x27;1&#x27;, HOME: &#x27;/Users/maciej&#x27;, LOGNAME: &#x27;maciej&#x27;, _: &#x27;/usr/local/bin/node&#x27;&#125; 可以修改此对象，但此类修改不会反映在 Node.js 进程之外，或反映到其他 Worker 线程（除非显示请求）。 换句话说，以下示例将不起作用： $ node -e ‘process.env.foo = “bar”‘ &amp;&amp; echo $foo但是以下示例则将起作用： 1234import &#123; env &#125; from &#x27;node:process&#x27;;env.foo = &#x27;bar&#x27;;console.log(env.foo); 在 process.env 上分配属性会将值隐式转换为字符串。 此行为已弃用。 当值不是字符串、数字或布尔值时，Node.js 的未来版本可能会抛出错误。 1234567891011121314151617181920212223import &#123; env &#125; from &#x27;node:process&#x27;;env.test = null;console.log(env.test);// =&gt; &#x27;null&#x27;env.test = undefined;console.log(env.test);// =&gt; &#x27;undefined&#x27;// 使用 delete 从 process.env 中删除属性。import &#123; env &#125; from &#x27;node:process&#x27;;env.TEST = 1;delete env.TEST;console.log(env.TEST);// =&gt; undefined// 在 Windows 操作系统上，环境变量不区分大小写。import &#123; env &#125; from &#x27;node:process&#x27;;env.TEST = 1;console.log(env.test);// =&gt; 1 除非在创建 Worker 实例时显式地指定，否则每个 Worker 线程都有自己的 process.env 副本，基于其父线程的 process.env，或任何指定为 Worker 构造函数的 env 选项。 对 process.env 的更改不会跨 Worker 线程可见，只有主线程可以进行对操作系统或原生插件可见的更改。 process.execArgvprocess.execArgv 属性返回 Node.js 进程启动时传入的一组特定于 Node.js 的命令行选项。这些选项不会出现在 process.argv 属性返回的数组中，也不包括 Node.js 可执行文件、脚本名称或脚本名称后面的任何选项。 这些选项可用于衍生与父进程具有相同执行环境的子进程。 1234567$ node --harmony script.js --versionprocess.execArgv 的结果：[&#x27;--harmony&#x27;]process.argv 的结果：[&#x27;/usr/local/bin/node&#x27;, &#x27;script.js&#x27;, &#x27;--version&#x27;] 有关具有此属性的工作线程的详细行为，请参阅 Worker 构造函数。 process.execPathprocess.execPath 属性返回启动 Node.js 进程的可执行文件的绝对路径名。 符号链接（如果有）会被解析。 process.exit([code])code 退出码。 默认值: 0。process.exit() 方法指示 Node.js 以 code 的退出状态同步终止进程。 如果省略 code，则退出将使用“成功”代码 0 或 process.exitCode 的值（如果已设置）。 直到所有 ‘exit’ 事件监听器都被调用，Node.js 才会终止。 以“失败”代码退出： 123import &#123; exit &#125; from &#x27;node:process&#x27;;exit(1); 执行 Node.js 的 shell 应该看到退出码为 1。调用 process.exit() 将强制进程尽快退出，即使仍有未完全完成的异步操作挂起，包括对 process.stdout 和 process.stderr 的 I/O 操作。 在大多数情况下，实际上没有必要显式调用 process.exit()。 如果事件循环中没有其他待处理的工作，则 Node.js 进程将自行退出。 可以设置 process.exitCode 属性来告诉进程在进程正常退出时使用哪个退出码。 例如，以下示例说明了 process.exit() 方法的误用，其可能导致打印到标准输出的数据被截断和丢失： 1234567import &#123; exit &#125; from &#x27;node:process&#x27;;// 这是不该做的示例：if (someConditionNotMet()) &#123; printUsageToStdout(); exit(1);&#125; 这是有问题的原因是因为在 Node.js 中写入 process.stdout 有时是异步的，并且可能发生在 Node.js 事件循环的多个滴答上。 但是，调用 process.exit() 会强制进程在执行对 stdout 的其他写入之前退出。 代码应该设置 process.exitCode 并通过避免为事件循环安排任何额外工作来允许进程自然退出，而不是直接调用 process.exit()： 1234567import process from &#x27;node:process&#x27;;// 如何正确设置退出码，同时让进程正常退出。if (someConditionNotMet()) &#123; printUsageToStdout(); process.exitCode = 1;&#125; 如果由于错误情况需要终止 Node.js 进程，则抛出未捕获的错误并允许进程相应地终止比调用 process.exit() 更安全。在 Worker 线程中，该函数停止当前线程而不是当前进程。 process.exitCode当进程正常退出或通过 process.exit() 退出而不指定代码时，将作为进程退出码的数字。将代码指定为 process.exit(code) 将覆盖 process.exitCode 的任何先前设置。 process.getActiveResourcesInfo()process.getActiveResourcesInfo() 方法返回字符串数组，其中包含当前保持事件循环活动的活动资源的类型。 123456789import &#123; getActiveResourcesInfo &#125; from &#x27;node:process&#x27;;import &#123; setTimeout &#125; from &#x27;node:timers&#x27;;console.log(&#x27;Before:&#x27;, getActiveResourcesInfo());setTimeout(() =&gt; &#123;&#125;, 1000);console.log(&#x27;After:&#x27;, getActiveResourcesInfo());// 打印:// Before: [ &#x27;CloseReq&#x27;, &#x27;TTYWrap&#x27;, &#x27;TTYWrap&#x27;, &#x27;TTYWrap&#x27; ]// After: [ &#x27;CloseReq&#x27;, &#x27;TTYWrap&#x27;, &#x27;TTYWrap&#x27;, &#x27;TTYWrap&#x27;, &#x27;Timeout&#x27; ] process.getegid()process.getegid() 方法返回 Node.js 进程的数字有效群组标识。 （见 getegid(2)。） 12345import process from &#x27;node:process&#x27;;if (process.getegid) &#123; console.log(`Current gid: $&#123;process.getegid()&#125;`);&#125; 此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 process.geteuid()process.geteuid() 方法返回进程的数字有效用户身份。 （见 geteuid(2)。） 12345import process from &#x27;node:process&#x27;;if (process.geteuid) &#123; console.log(`Current uid: $&#123;process.geteuid()&#125;`);&#125; 此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 process.getgid()process.getgid() 方法返回进程的数字群组标识。 （见 getgid(2)。） 12345import process from &#x27;node:process&#x27;;if (process.getgid) &#123; console.log(`Current gid: $&#123;process.getgid()&#125;`);&#125; 此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 process.getgroups()process.getgroups() 方法返回带有补充组 ID 的数组。 POSIX 不指定是否包含有效组 ID，但 Node.js 确保它始终包含。 12345import process from &#x27;node:process&#x27;;if (process.getgroups) &#123; console.log(process.getgroups()); // [ 16, 21, 297 ]&#125; 此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 process.getuid()process.getuid() 方法返回进程的数字用户标识。 （见 getuid(2)。） 12345import process from &#x27;node:process&#x27;;if (process.getuid) &#123; console.log(`Current uid: $&#123;process.getuid()&#125;`);&#125; 此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 process.hasUncaughtExceptionCaptureCallback()指示是否已使用 process.setUncaughtExceptionCaptureCallback() 设置回调。 process.hrtime([time])time &lt;integer[]&gt; 先前调用 process.hrtime() 的结果返回: &lt;integer[]&gt;这是 process.hrtime.bigint() 在 JavaScript 中引入 bigint 之前的旧版本。process.hrtime() 方法在 [seconds, nanoseconds] 元组 Array 中返回当前高解析度实时，其中 nanoseconds 是无法以秒精度表示的实时剩余部分。 time 是可选参数，它必须是先前 process.hrtime() 调用 diff 与当前时间的结果。 如果传入的参数不是元组 Array，则会抛出 TypeError。 传入用户定义的数组而不是先前调用 process.hrtime() 的结果将导致未定义的行为。 这些时间相对于过去的任意时间，与一天中的时间无关，因此不受时钟漂移的影响。 主要用途是测量间隔之间的性能： 12345678910111213import &#123; hrtime &#125; from &#x27;node:process&#x27;;const NS_PER_SEC = 1e9;const time = hrtime();// [ 1800216, 25 ]setTimeout(() =&gt; &#123; const diff = hrtime(time); // [ 1, 552 ] console.log(`Benchmark took $&#123;diff[0] * NS_PER_SEC + diff[1]&#125; nanoseconds`); // 基准测试耗时 1000000552 纳秒&#125;, 1000); process.hrtime.bigint()process.hrtime() 方法的 bigint 版本以纳秒为单位返回当前高解析度实时作为 bigint。与 process.hrtime() 不同，它不支持额外的 time 参数，因为可以直接通过减去两个 bigint 来计算差异。 123456789101112import &#123; hrtime &#125; from &#x27;node:process&#x27;;const start = hrtime.bigint();// 191051479007711nsetTimeout(() =&gt; &#123; const end = hrtime.bigint(); // 191052633396993n console.log(`Benchmark took $&#123;end - start&#125; nanoseconds`); // 基准测试耗时 1154389282 纳秒&#125;, 1000); process.initgroups(user, extraGroup) user | 用户名或数字标识符。 extraGroup | 群组名或数字标识符。process.initgroups() 方法读取 /etc/group 文件并使用用户所属的所有组初始化组访问列表。 这是一个特权操作，要求 Node.js 进程具有 root 访问权限或 CAP_SETGID 能力。 删除权限时要小心： 1234567import &#123; getgroups, initgroups, setgid &#125; from &#x27;node:process&#x27;;console.log(getgroups()); // [ 0 ]initgroups(&#x27;nodeuser&#x27;, 1000); // 切换用户console.log(getgroups()); // [ 27, 30, 46, 1000, 0 ]setgid(1000); // 删除 root 的 gidconsole.log(getgroups()); // [ 27, 30, 46, 1000 ] 此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 此特性在 Worker 线程中不可用。 process.kill(pid[, signal])pid 进程标识signal | 要发送的信号，可以是字符串或数字。 默认值: ‘SIGTERM’。process.kill() 方法将 signal 发送到由 pid 标识的进程。 信号名称是字符串，例如 ‘SIGINT’ 或 ‘SIGHUP’。 有关详细信息，请参阅信号事件和 kill(2)。 如果目标 pid 不存在，则此方法将抛出错误。 作为特殊情况，可以使用信号 0 来测试进程是否存在。 如果使用 pid 来杀死进程组，则 Windows 平台将抛出错误。尽管此函数的名字是 process.kill()，但它实际上只是信号发送者，就像 kill 系统调用。 发送的信号可能会做其他事情而不是杀死目标进程。 123456789101112import process, &#123; kill &#125; from &#x27;node:process&#x27;;process.on(&#x27;SIGHUP&#x27;, () =&gt; &#123; console.log(&#x27;Got SIGHUP signal.&#x27;);&#125;);setTimeout(() =&gt; &#123; console.log(&#x27;Exiting.&#x27;); process.exit(0);&#125;, 100);kill(process.pid, &#x27;SIGHUP&#x27;); 当 Node.js 进程收到 SIGUSR1 时，Node.js 将启动调试器。 参见信号事件。 process.memoryUsage()返回: rss heapTotal heapUsed external arrayBuffers 返回描述 Node.js 进程的内存使用量（以字节为单位）的对象。12345678910111213141516import &#123; memoryUsage &#125; from &#x27;node:process&#x27;;console.log(memoryUsage());// 打印:// &#123;// rss: 4935680,// heapTotal: 1826816,// heapUsed: 650472,// external: 49879,// arrayBuffers: 9386// &#125;// heapTotal 和 heapUsed 指的是 V8 的内存使用量。// external 指的是绑定到 V8 管理的 JavaScript 对象的 C++ 对象的内存使用量。// rss，常驻集大小，是进程在主内存设备（即总分配内存的子集）中占用的空间量，包括所有 C++ 和 JavaScript 对象和代码。// arrayBuffers 是指为 ArrayBuffer 和 SharedArrayBuffer 分配的内存，包括所有 Node.js Buffer。 这也包含在 external 值中。 当 Node.js 被用作嵌入式库时，此值可能为 0，因为在这种情况下可能不会跟踪 ArrayBuffer 的分配。// 当使用 Worker 线程时，则 rss 将是对整个进程都有效的值，而其他字段仅涉及当前线程。 process.memoryUsage() 方法遍历每个页面以收集有关内存使用情况的信息，这可能会根据程序内存分配而变慢。 process.memoryUsage.rss()process.memoryUsage.rss() 方法返回以字节为单位表示驻留集大小的整数 (RSS)。驻留集大小是进程在主内存设备（即总分配内存的子集）中占用的空间量，包括所有 C++ 和 JavaScript 对象和代码。这与 process.memoryUsage() 提供的 rss 属性值相同，但 process.memoryUsage.rss() 更快。 1234import &#123; memoryUsage &#125; from &#x27;node:process&#x27;;console.log(memoryUsage.rss());// 35655680 process.nextTick(callback[, …args])callback …args 当调用 callback 时要传入的额外参数process.nextTick() 将 callback 添加到”下一个滴答队列”。 在 JavaScript 堆栈上的当前操作运行完成之后，且在允许事件循环继续之前，此队列将被完全排空。 如果递归地调用 process.nextTick()，则可能会创建无限的循环。 1234567891011import &#123; nextTick &#125; from &#x27;node:process&#x27;;console.log(&#x27;start&#x27;);nextTick(() =&gt; &#123; console.log(&#x27;nextTick callback&#x27;);&#125;);console.log(&#x27;scheduled&#x27;);// 输出：// start// scheduled// nextTick callback 这在开发 API 时很重要，以便让用户有机会在对象构建之后但在任何 I/O 发生之前分配事件句柄： 1234567891011121314import &#123; nextTick &#125; from &#x27;node:process&#x27;;function MyThing(options) &#123; this.setupOptions(options); nextTick(() =&gt; &#123; this.startDoingStuff(); &#125;);&#125;const thing = new MyThing();thing.getReadyForStuff();// thing.startDoingStuff() 现在被调用，而不是之前。 这对于要 100% 同步或 100% 异步的 API 非常重要。 设想这个示例： 123456789// 警告！不要使用！不安全的危险！function maybeSync(arg, cb) &#123; if (arg) &#123; cb(); return; &#125; fs.stat(&#x27;file&#x27;, cb);&#125; 此 API 是危险的，因为在以下情况下： 1234567const maybeTrue = Math.random() &gt; 0.5;maybeSync(maybeTrue, () =&gt; &#123; foo();&#125;);bar(); 并不清楚是先调用 foo() 还是 bar()。 以下方法要好得多： 12345678910import &#123; nextTick &#125; from &#x27;node:process&#x27;;function definitelyAsync(arg, cb) &#123; if (arg) &#123; nextTick(cb); return; &#125; fs.stat(&#x27;file&#x27;, cb);&#125; 何时使用 queueMicrotask() 与 process.nextTick()queueMicrotask() API 是 process.nextTick() 的替代方案，它还使用用于执行 then、catch 和 finally 处理程序的相同微任务队列来延迟函数的执行。 在 Node.js 中，每次“下一个滴答队列”被排空时，微任务队列也会立即排空。 123456789import &#123; nextTick &#125; from &#x27;node:process&#x27;;Promise.resolve().then(() =&gt; console.log(2));queueMicrotask(() =&gt; console.log(3));nextTick(() =&gt; console.log(1));// 输出：// 1// 2// 3 对于_大多数_用户空间用例，queueMicrotask() API 提供了一种可移植且可靠的延迟执行机制，该机制适用于多个 JavaScript 平台环境，应该比 process.nextTick() 更受青睐。 在简单的场景中，queueMicrotask() 可以直接替代 process.nextTick()。 123456789console.log(&#x27;start&#x27;);queueMicrotask(() =&gt; &#123; console.log(&#x27;microtask callback&#x27;);&#125;);console.log(&#x27;scheduled&#x27;);// 输出：// start// scheduled// microtask callback process.nextTick()和queueMicrotask()区别 process.nextTick() 允许指定额外值，这些值将在调用时作为参数传递给延迟函数。使用 queueMicrotask() 实现相同的结果需要使用闭包或绑定函数 从下一个滴答队列和微任务队列中引发的错误的处理方式存在细微差别。 在排队的微任务回调中抛出的错误应该在可能的情况下在排队的回调中处理。 如果不是，则可以使用 process.on(‘uncaughtException’) 事件句柄来捕获和处理错误。 process.noDeprecationprocess.noDeprecation 属性指示是否在当前 Node.js 进程上设置了 –no-deprecation 标志。 有关此标志行为的更多信息，请参阅 ‘warning’ 事件和 emitWarning() 方法的文档。 process.reportprocess.report 是一个对象，其方法用于为当前进程生成诊断报告。 报告文档中提供了额外文档。 process.report.getReport([err])返回正在运行的进程的诊断报告的 JavaScript 对象表示形式。 报告的 JavaScript 堆栈跟踪取自 err（如果存在）。 12345678import &#123; report &#125; from &#x27;node:process&#x27;;const data = report.getReport();console.log(data.header.nodejsVersion);// 类似于 process.report.writeReport()import fs from &#x27;node:fs&#x27;;fs.writeFileSync(&#x27;my-report.log&#x27;, util.inspect(data), &#x27;utf8&#x27;); process.report.reportOnSignal如果为 true，则当进程接收到 process.report.signal 指定的信号时生成诊断报告。 process.report.reportOnUncaughtException如果为 true，则针对未捕获的异常生成诊断报告。 process.report.signal用于触发诊断报告创建的信号。 默认为 ‘SIGUSR2’。 process.report.writeReport([filename][, err])filename 写入报告的文件的名称。 这应该是相对路径，如果未指定，它将附加到 process.report.directory 中指定的目录或 Node.js 进程的当前工作目录。err 用于报告 JavaScript 堆栈的自定义错误。将诊断报告写入文件。 如果未提供 filename，则默认文件名包括日期、时间、PID 和序列号。 报告的 JavaScript 堆栈跟踪取自 err（如果存在）。 process.send(message[, sendHandle[, options]][, callback])如果使用 IPC 通道衍生 Node.js，则可以使用 process.send() 方法向父进程发送消息。 消息将作为父对象 ChildProcess 对象上的 ‘message’ 事件接收。如果 Node.js 没有使用 IPC 通道衍生，则 process.send 将是 undefined。消息经过序列化和解析。 结果消息可能与最初发送的消息不同。 process.setegid(id)process.setegid() 方法设置进程的有效群组标识。 （请参阅 setegid(2)。）id 可以作为数字 ID 或群组名称字符串传入。 如果指定了群组名，则此方法在解析关联的数字 ID 时会阻塞。此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 此特性在 Worker 线程中不可用。 process.seteuid(id)process.setgid(id)process.setuid(id)与process.setegid(id)类似 process.setgroups(groups)process.setgroups() 方法为 Node.js 进程设置补充群组 ID。这是一个特权操作，需要 Node.js 进程具有 root 或 CAP_SETGID 能力。groups 数组可以包含数字群组 ID、群组名称或两者。此功能仅适用于 POSIX 平台（即不适用于 Windows 或安卓）。 此特性在 Worker 线程中不可用。 process.setUncaughtExceptionCaptureCallback(fn)fn | process.setUncaughtExceptionCaptureCallback() 函数设置一个函数，当发生未捕获的异常时将调用该函数，该函数将接收异常值本身作为其第一个参数。如果设置了这样的函数，则不会触发 ‘uncaughtException’ 事件。 如果 –abort-on-uncaught-exception 是从命令行传入的或通过 v8.setFlagsFromString() 设置的，则进程不会中止。 配置为对异常执行的操作（例如报告生成）也将受到影响 要取消捕获功能，可以使用 process.setUncaughtExceptionCaptureCallback(null)。 在设置另一个捕获函数时使用非 null 参数调用此方法将引发错误。 使用此函数与使用已弃用的 domain 内置模块是相互排斥的。 process.stderrprocess.stderr 属性返回连接到 stderr (文件描述符 2) 的流。 它是 net.Socket（也就是 Duplex 流），除非文件描述符 2 指向文件，在这种情况下它是 Writable 流。process.stderr 在一些重要的方面不同于其他 Node.js 流。 有关更多信息，请参阅进程 I/O 的注意事项。 process.stderr.fd该属性指的是 process.stderr 的底层文件描述符的值。 该值固定为 2。 在 Worker 线程中，该字段不存在。 process.stdinprocess.stdin 属性返回连接到 stdin (文件描述符 0) 的流。 它是 net.Socket（也就是 Duplex 流），除非文件描述符 0 指向文件，在这种情况下它是 Readable 流。有关如何从 stdin 读取的详细信息，请参阅 readable.read()。在“旧”流模式下，stdin 流默认是暂停的，所以必须调用 process.stdin.resume() 来读取它。 另请注意，调用 process.stdin.resume() 本身会将流切换到“旧”模式。 process.stdoutprocess.stdout 属性返回连接到 stdout (文件描述符 1) 的流。 它是 net.Socket（也就是 Duplex 流），除非文件描述符 1 指向文件，在这种情况下它是 Writable 流。 进程 I/O 的注意事项process.stdout 和 process.stderr 在重要方面与其他 Node.js 流不同： 它们分别由 console.log() 和 console.error() 内部使用。写入的区别： 文件：在 Windows 和 POSIX 上是_同步的_ TTY（终端）: 在 Windows 上是_异步的_，在 POSIX 上是_同步的_ 管道（和套接字）: 在 Windows 上是_同步的_，在 POSIX 上是_异步的_ 警告：同步写入会阻塞事件循环，直到写入完成。 在输出到文件的情况下，这可能几乎是瞬时的，但在系统负载高、接收端未读取管道或终端或文件系统速度较慢的情况下，事件循环可能经常被阻塞足够长，足以对性能产生严重的负面影响。 这在写入交互式终端会话时可能不是问题，但在对流程输出流进行生产日志记录时要特别小心。 要检查流是否连接到 TTY 上下文，请检查 isTTY 属性。 process.titleprocess.title 属性返回当前进程标题（即返回 ps 的当前值）。 为 process.title 分配一个新值会修改 ps 的当前值。 分配新值时，不同平台会对标题施加不同的最大长度限制。 将值分配给 process.title 可能不会在进程管理器应用程序（例如 macOS 活动监视器或 Windows 服务管理器）中产生准确的标签。 process.umask(mask)process.umask(mask) 设置 Node.js 进程的文件模式创建掩码。 子进程从父进程继承掩码。 返回上一个掩码。在 Worker 线程中，process.umask(mask) 会抛出异常。 process.uptime()process.uptime() 方法返回当前 Node.js 进程已经运行的秒数。返回值包括几分之一秒。 使用 Math.floor() 获得整秒。 process.versionprocess.version 属性包含 Node.js 版本字符串。要获取不带 v 的版本字符串，则使用 process.versions.node。 process.versionsprocess.versions 属性返回对象，其中列出了 Node.js 的版本字符串及其依赖项。process.versions.modules 表示当前的 ABI 版本，每当 C++ API 更改时都会增加。 Node.js 将拒绝加载针对不同模块 ABI 版本编译的模块。 退出码当没有更多异步操作挂起时，Node.js 通常会以 0 状态代码退出。 在其他情况下使用以下状态代码： 1 未捕获的致命异常：存在未捕获的异常，并且其没有被域或 ‘uncaughtException’ 事件句柄处理。2: 未使用（由 Bash 预留用于内置误用）3 内部 JavaScript 解析错误：Node.js 引导过程中的内部 JavaScript 源代码导致解析错误。 这是极其罕见的，通常只能在 Node.js 本身的开发过程中发生。4 内部 JavaScript 评估失败：Node.js 引导过程中的内部 JavaScript 源代码在评估时未能返回函数值。 这是极其罕见的，通常只能在 Node.js 本身的开发过程中发生。5 致命错误：V8 中存在不可恢复的致命错误。 通常将打印带有前缀 FATAL ERROR 的消息到标准错误。6 非函数的内部异常句柄：存在未捕获的异常，但内部致命异常句柄不知何故设置为非函数，无法调用。7 内部异常句柄运行时失败：存在未捕获的异常，并且内部致命异常句柄函数本身在尝试处理时抛出错误。 例如，如果 ‘uncaughtException’ 或 domain.on(‘error’) 句柄抛出错误，就会发生这种情况。8: 未使用。 在以前版本的 Node.js 中，退出码 8 有时表示未捕获的异常。9 无效参数：指定了未知选项，或者提供了需要值的选项而没有值。10 内部 JavaScript 运行时失败：Node.js 引导过程中的内部 JavaScript 源代码在调用引导函数时抛出错误。 这是极其罕见的，通常只能在 Node.js 本身的开发过程中发生。12 无效的调试参数：设置了 –inspect 和/或 –inspect-brk 选项，但选择的端口号无效或不可用。13 未完成的顶层等待：在顶层代码中的函数外使用了 await，但传入的 Promise 从未解决。 128 信号退出：如果 Node.js 收到致命的信号，例如 SIGKILL 或 SIGHUP，则其退出码将是 128 加上信号代码的值。 这是标准的 POSIX 实践，因为退出码被定义为 7 位整数，并且信号退出设置高位，然后包含信号代码的值。 例如，信号 SIGABRT 的值是 6，因此预期的退出码将是 128 + 6 或 134。"},{"title":"nodejs基础知识(15)","date":"2023-03-10T13:15:16.000Z","updated":"2023-07-24T09:24:46.502Z","comments":true,"path":"nodejs/nodejs-note-25.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-25.html","excerpt":"","text":"timers 定时器Immediate 类此对象是在 setImmediate() 内部创建并返回。 它可以传给 clearImmediate() 以取消调度的行动。 默认情况下，当立即调度时，只要立即处于活动状态，则 Node.js 事件循环就会继续运行。 setImmediate() 返回的 Immediate 对象导出可用于控制此默认行为的 immediate.ref() 和 immediate.unref() 函数。 immediate.hasRef()如果为 true，则 Immediate 对象将使 Node.js 事件循环保持活动状态。 immediate.ref()调用时，只要 Immediate 处于活动状态，就请求 Node.js 事件循环不退出。 多次调用 immediate.ref() 将不起作用。 默认情况下，所有 Immediate 对象都被“引用”，这使得通常不需要调用 immediate.ref() 除非之前已经调用过 immediate.unref()。 immediate.unref()调用时，活动的 Immediate 对象不需要 Node.js 事件循环保持活动状态。 如果没有其他活动保持事件循环运行，则进程可能会在调用 Immediate 对象的回调之前退出。 多次调用 immediate.unref() 将不起作用。 Timeout 类此对象是在 setTimeout() 和 setInterval() 内部创建并返回。 它可以传给 clearTimeout() 或 clearInterval() 以取消调度的行动。 默认情况下，当使用 setTimeout() 或 setInterval() 调度定时器时，只要定时器处于活动状态，则 Node.js 事件循环就会继续运行。 这些函数返回的每个 Timeout 对象都导出可用于控制此默认行为的 timeout.ref() 和 timeout.unref() 函数。 timeout.close()取消超时。 timeout.hasRef()如果为 true，则 Timeout 对象将使 Node.js 事件循环保持活动状态。 timeout.ref()调用时，只要 Timeout 处于活动状态，就请求 Node.js 事件循环不退出。 多次调用 timeout.ref() 将不起作用。默认情况下，所有 Timeout 对象都被“引用”，这使得通常不需要调用 timeout.ref() 除非之前已经调用过 timeout.unref()。 timeout.refresh()将定时器的开始时间设置为当前时间，并重新调度定时器在调整为当前时间的先前指定的时长调用其回调。 这对于在不分配新的 JavaScript 对象的情况下刷新定时器很有用。在已经调用其回调的定时器上使用它会重新激活定时器。 timeout.unref()调用时，活动的 Timeout 对象不需要 Node.js 事件循环保持活动状态。 如果没有其他活动保持事件循环运行，则进程可能会在调用 Timeout 对象的回调之前退出。 多次调用 timeout.unref() 将不起作用。 timeoutSymbol.toPrimitive将 Timeout 强制为原始类型。 该原始类型可用于清除 Timeout。 该原始类型只能在创建超时的同一线程中使用。 因此，要在 worker_threads 上使用它，则必须首先将其传给正确的线程。 这允许增强与浏览器 setTimeout() 和 setInterval() 实现的兼容性。 调度定时器Node.js 中的定时器是一种会在一段时间后调用给定函数的内部构造。 定时器函数的调用时间取决于用于创建定时器的方法以及 Node.js 事件循环正在执行的其他工作。 setImmediate(callback[, …args])callback 在本轮 Node.js 事件循环结束时调用的函数…args 调用 callback 时要传入的可选参数。返回: 用于 clearImmediate()在 I/O 事件的回调之后调度 callback 的“立即”执行。 当多次调用 setImmediate() 时，则 callback 函数会按照它们的创建顺序排队执行。 每次事件循环迭代都会处理整个回调队列。 如果立即定时器从正在执行的回调中排队，则直到下一次事件循环迭代才会触发该定时器。如果 callback 不是函数，则将抛出 TypeError。此方法具有可使用 timersPromises.setImmediate() 获得的 promise 的自定义变体。 setInterval(callback[, delay[, …args]])每 delay 毫秒调度重复执行 callback。当 delay 大于 2147483647 或小于 1 时，则 delay 将设置为 1。 非整数延迟被截断为整数。如果 callback 不是函数，则将抛出 TypeError。此方法具有可使用 timersPromises.setInterval() 获得的 promise 的自定义变体。 setTimeout(callback[, delay[, …args]])在 delay 毫秒后调度单次的 callback 的执行。callback 可能不会在精确的 delay 毫秒内被调用。 Node.js 不保证回调将触发的确切时间，也不保证它们的顺序。 回调将在尽可能接近指定的时间时调用。当 delay 大于 2147483647 或小于 1 时，则 delay 将设置为 1。 非整数延迟被截断为整数。如果 callback 不是函数，则将抛出 TypeError。此方法具有可使用 timersPromises.setTimeout() 获得的 promise 的自定义变体。 取消定时器setImmediate()、setInterval() 和 setTimeout() 方法各自返回表示调度的定时器的对象。 这些可用于取消定时器并防止其触发。对于 setImmediate() 和 setTimeout() 的 promise 化变体，可以使用 AbortController 来取消定时器。当取消时，返回的 Promise 将使用 ‘AbortError’ 拒绝。 对于 setImmediate()： 12345678910111213const &#123; setImmediate: setImmediatePromise &#125; = require(&#x27;node:timers/promises&#x27;);const ac = new AbortController();const signal = ac.signal;setImmediatePromise(&#x27;foobar&#x27;, &#123; signal &#125;) .then(console.log) .catch((err) =&gt; &#123; if (err.name === &#x27;AbortError&#x27;) console.log(&#x27;The immediate was aborted&#x27;); &#125;);ac.abort(); 对于 setTimeout()： 12345678910111213const &#123; setTimeout: setTimeoutPromise &#125; = require(&#x27;node:timers/promises&#x27;);const ac = new AbortController();const signal = ac.signal;setTimeoutPromise(1000, &#x27;foobar&#x27;, &#123; signal &#125;) .then(console.log) .catch((err) =&gt; &#123; if (err.name === &#x27;AbortError&#x27;) console.log(&#x27;The timeout was aborted&#x27;); &#125;);ac.abort(); 定时器的 Promise APItimers/promises API 提供了一组可返回 Promise 对象的可供选择的定时器函数。 API 可通过 require(‘node:timers/promises’) 访问。 timersPromises.setTimeout([delay[, value[, options]]])delay 在履行 promise 之前等待的毫秒数。 默认值: 1。value 履行 promise 使用的值。options ref 设置为 false 以指示调度的 Timeout 不应要求 Node.js 事件循环保持活动状态。 默认值: true。 signal 可选的 AbortSignal，可用于取消调度的 Timeout。1234567import &#123; setTimeout,&#125; from &#x27;timers/promises&#x27;;const res = await setTimeout(100, &#x27;result&#x27;);console.log(res); // 打印 &#x27;result&#x27; timersPromises.setImmediate([value[, options]]) 1234567import &#123; setImmediate,&#125; from &#x27;timers/promises&#x27;;const res = await setImmediate(&#x27;result&#x27;);console.log(res); // 打印 &#x27;result&#x27; timersPromises.setInterval([delay[, value[, options]]]) 123456789101112import &#123; setInterval,&#125; from &#x27;timers/promises&#x27;;const interval = 100;for await (const startTime of setInterval(interval, Date.now())) &#123; const now = Date.now(); console.log(now); if ((now - startTime) &gt; 1000) break;&#125;console.log(Date.now()); test 测试通过 test 模块创建的测试由单个函数组成，该函数以三种方式之一进行处理： 同步的函数，如果抛出异常则认为失败，否则认为通过。 返回 Promise 的函数，如果 Promise 拒绝，则认为该函数失败，如果 Promise 解决，则认为该函数通过。 接收回调函数的函数。 如果回调接收到任何真值作为其第一个参数，则认为测试失败。 如果非真值作为第一个参数传给回调，则认为测试通过。 如果测试函数接收到回调函数并且还返回 Promise，则测试将失败。 子测试测试上下文的 test() 方法允许创建子测试。 此方法的行为与顶层 test() 函数相同。await 用于确保两个子测试均已完成。 这是必要的，因为父测试不会等待子测试完成。 当父测试完成时仍然未完成的任何子测试将被取消并视为失败。 任何子测试失败都会导致父测试失败。 123456789test(&#x27;top level test&#x27;, async (t) =&gt; &#123; await t.test(&#x27;subtest 1&#x27;, (t) =&gt; &#123; assert.strictEqual(1, 1); &#125;); await t.test(&#x27;subtest 2&#x27;, (t) =&gt; &#123; assert.strictEqual(2, 2); &#125;);&#125;); 跳过测试通过将 skip 选项传给测试，或调用测试上下文的 skip() 方法，可以跳过单个测试。 12345678910111213141516test(&#x27;top level test&#x27;, &#123;skip: true&#125;, (t) =&gt; &#123; assert.strictEqual(1, 1);&#125;);test(&#x27;top level test&#x27;, &#123;skip: &#x27;skip message&#x27;&#125;, (t) =&gt; &#123; assert.strictEqual(1, 1);&#125;);test(&#x27;top level test&#x27;, (t) =&gt; &#123; assert.strictEqual(1, 1); t.skip(); assert.strictEqual(2, 2);&#125;);test(&#x27;top level test&#x27;, (t) =&gt; &#123; assert.strictEqual(1, 1); t.skip(&#x27;skip message&#x27;); assert.strictEqual(2, 2);&#125;); describe/it 语法运行测试也可以使用 describe 来声明套件和 it 来声明测试。 套件用于将相关测试组织和分组在一起。 it 是 test 的别名. 123456789101112131415describe(&#x27;test parent&#x27;, () =&gt; &#123; it(&#x27;first test&#x27;, () =&gt; &#123; assert.strictEqual(1, 1); &#125;); it(&#x27;second test&#x27;, () =&gt; &#123; assert.strictEqual(2, 2); &#125;); describe(&#x27;child test&#x27;, () =&gt; &#123; it(&#x27;grand test&#x27;, () =&gt; &#123; assert.strictEqual(3, 3); &#125;); &#125;);&#125;); only 测试如果 Node.js 使用 –test-only 命令行选项启动，则可以通过将 only 选项传给应该运行的测试来跳过除选定子集之外的所有顶层测试。 当运行带有 only 选项集的测试时，所有子测试也会运行。 测试上下文的 runOnly() 方法可用于在子测试级别实现相同的行为。 1234567891011121314151617181920212223test(&#x27;this test is run&#x27;, &#123; only: true &#125;, async (t) =&gt; &#123; // 在此测试中，默认运行所有子测试。 await t.test(&#x27;running subtest&#x27;); // 可以使用 &#x27;only&#x27; 选项更新测试上下文以运行子测试。 t.runOnly(true); await t.test(&#x27;this subtest is now skipped&#x27;); await t.test(&#x27;this subtest is run&#x27;, &#123; only: true &#125;); // 切换上下文以执行所有测试。 t.runOnly(false); await t.test(&#x27;this subtest is now run&#x27;); // 显式地不要运行这些测试。 await t.test(&#x27;skipped subtest 3&#x27;, &#123; only: false &#125;); await t.test(&#x27;skipped subtest 4&#x27;, &#123; skip: true &#125;);&#125;);// 未设置 &#x27;only&#x27; 选项，因此跳过此测试。test(&#x27;this test is not run&#x27;, () =&gt; &#123; // 此代码未运行。 throw new Error(&#x27;fail&#x27;);&#125;); 无关的异步活动一旦测试函数完成执行，则 TAP 结果会尽快输出，同时保持测试的顺序。 但是，测试函数可能会生成比测试本身寿命更长的异步活动。 测试运行器处理此类活动，但不会延迟报告测试结果以适应它。 describe.skip([name][, options][, fn])跳过套件的简写，与 describe([name], { skip: true }[, fn]) 相同。 describe.todo([name][, options][, fn])将套件标记为 TODO 的简写，与 describe([name], { todo: true }[, fn]) 相同。"},{"title":"nodejs基础知识(16)","date":"2023-04-01T02:29:12.000Z","updated":"2023-07-24T09:24:46.502Z","comments":true,"path":"nodejs/nodejs-note-26.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-26.html","excerpt":"","text":"tls 安全传输层tls 提供了构建在 OpenSSL 之上的传输层安全 (TLS) 和安全套接字层 (SSL) 协议的实现 TLS/SSL 概念TLS/SSL 是一组协议，它依赖于公钥基础设施 (PKI) 来实现客户端和服务器之间的安全通信。 对于最常见的情况，每个服务器都必须有私钥。 完美前向保密术语 前向保密 或 完美前向保密 描述了密钥协议（即密钥交换）方法的一个特征。 也就是说，服务器和客户端密钥用于协商新的临时密钥，这些密钥专门用于且仅用于当前通信会话。 实际上，这意味着即使服务器的私钥被泄露，如果攻击者设法获得专门为会话生成的密钥对，通信也只能被窃听者解密。 完美前向保密是通过在每次 TLS/SSL 握手时随机生成密钥对的密钥对来实现的（与对所有会话使用相同的密钥相反）。 实现这种技术的方法被称为”临时”。 目前常用两种方法来实现完美前向保密（注意繁体缩写后的字符 “E”）： DHE: Diffie-Hellman 密钥协议的临时版本。 ECDHE: 椭圆曲线 Diffie-Hellman 密钥协议的临时版本。要使用 DHE 和 node:tls 模块使用完美前向保密，需要生成 Diffie-Hellman 参数并使用 dhparam 选项指定它们到 tls.createSecureContext()。如果使用 ECDHE 使用完美前向保密，则不需要 Diffie-Hellman 参数，将使用默认 ECDHE 曲线。 创建 TLS 服务器时可以使用 ecdhCurve 属性来指定要使用的受支持曲线的名称列表，有关详细信息，请参阅 tls.createServer()。 完美前向保密在 TLSv1.2 之前是可选的，但它对于 TLSv1.3 不是可选的，因为所有 TLSv1.3 密码套件都使用 ECDHE。 ALPN 和 SNIALPN（应用层协议协商扩展）和 SNI（服务器名称指示）是 TLS 握手扩展： ALPN: 允许将 TLS 服务器用于多种协议（HTTP，HTTP/2） SNI: 允许将 TLS 服务器用于具有不同证书的多个主机名。 预共享的密钥（不建议使用，近年来安全漏洞较多）TLS-PSK 支持可作为普通基于证书的身份验证的替代方法。 它使用预共享密钥而不是证书来验证 TLS 连接，提供相互验证。 TLS-PSK 和公钥基础设施并不相互排斥。 客户端和服务器可以同时容纳两者，在正常的密码协商步骤中选择它们中的任何一个。 客户端发起的重协商攻击缓解TLS 协议允许客户端重新协商 TLS 会话的某些方面。 不幸的是，会话重新协商需要不成比例的服务器端资源，使其成为拒绝服务攻击的潜在载体。为了降低风险，每十分钟重新协商的次数限制为 3 次。 当超过此阈值时，tls.TLSSocket 实例上会触发 ‘error’ 事件。 限制是可配置的： tls.CLIENT_RENEG_LIMIT 指定重新协商请求的数量。 默认值: 3。 tls.CLIENT_RENEG_WINDOW 指定时间重新协商窗口（以秒为单位）。 默认值: 600 （10分钟）。在没有充分了解影响和风险的情况下，不应修改默认的重新协商限制。 TLSv1.3 不支持重新协商。 ‘newSession’ 事件在创建新的 TLS 会话时触发 ‘newSession’ 事件。 这可用于在外部存储中存储会话。 数据应该提供给 ‘resumeSession’ 回调。监听器回调在调用时传入三个参数： sessionId TLS 会话标识符 sessionData TLS 会话数据 callback 回调函数不带参数，必须调用这些参数才能通过安全连接发送或接收数据。 监听此事件只会对添加事件监听器后建立的连接有影响。 ‘resumeSession’ 事件当客户端请求恢复之前的 TLS 会话时，则会触发 ‘resumeSession’ 事件。 监听器回调在调用时传入两个参数： sessionId TLS 会话标识符 callback 恢复前一个会话时要调用的回调函数：callback([err[, sessionData]]) err sessionData 事件监听器应该使用给定的 sessionId 在外部存储中为 ‘newSession’ 事件处理程序保存的 sessionData 执行查找。 如果找到，则调用 callback(null, sessionData) 恢复会话。 如果没有找到，则会话将无法恢复。 callback() 必须在没有 sessionData 的情况下被调用，以便握手可以继续并可以创建新的会话。 可以调用 callback(err) 来终止传入的连接并销毁套接字。 监听此事件只会对添加事件监听器后建立的连接有影响。 server.close([callback])callback 监听器回调，将被注册以监听服务器实例的 ‘close’ 事件。server.close() 方法阻止服务器接受新连接。此函数异步地运行。 当服务器没有更多打开的连接时，则将触发 ‘close’ 事件。 server.getTicketKeys()返回: 包含会话票证密钥的 48 字节缓冲区。返回会话票证密钥。 tlsSocket.disableRenegotiation()禁用此 TLSSocket 实例的 TLS 重新协商。 一旦调用，则尝试重新协商将在 TLSSocket 上触发 ‘error’ 事件。 tlsSocket.enableTrace()当启用后，TLS 数据包跟踪信息将写入 stderr。 这可用于调试 TLS 连接问题。输出的格式与 openssl s_client -trace 或 openssl s_server -trace 的输出相同。 虽然它是由 OpenSSL 的 SSL_trace() 函数生成的，但格式未记录，可以在不通知的情况下更改，不应依赖。 tlsSocket.encrypted总是返回 true。 这可用于将 TLS 套接字与常规 net.Socket 实例区分开来。 tlsSocket.getSession()如果没有协商会话，则返回 TLS 会话数据或 undefined。 在客户端，可以将数据提供给 tls.connect() 的 session 选项来恢复连接。 在服务器上，它可能对调试有用。注意：getSession() 仅适用于 TLSv1.2 及以下版本。 对于 TLSv1.3，应用程序必须使用 ‘session’ 事件（它也适用于 TLSv1.2 及更低版本）。 tlsSocket.getTLSTicket()对于客户端，如果可用，则返回 TLS 会话票证，或 undefined。 对于服务器，总是返回 undefined。它可能对调试有用。 tlsSocket.isSessionReused()返回: 如果会话被重用则为 true，否则为 false。 tls.DEFAULT_ECDH_CURVEtls 服务器中用于 ECDH 密钥协议的默认曲线名称。 默认值为 ‘auto’。 tls.DEFAULT_MAX_VERSION tls.createSecureContext() 的 maxVersion 选项的默认值。 它可以分配任何支持的 TLS 协议版本，’TLSv1.3’、’TLSv1.2’、’TLSv1.1’ 或 ‘TLSv1’。 默认值: ‘TLSv1.3’, 除非使用 CLI 选项更改。 使用 –tls-max-v1.2 将默认设置为 ‘TLSv1.2’。 使用 –tls-max-v1.3 将默认设置为 ‘TLSv1.3’。 如果提供了多个选项，则使用最高的最大值。 tls.DEFAULT_MIN_VERSION与tls.DEFAULT_MAX_VERSION作用相反。 url 网址网址字符串与网址对象node:url 模块提供了两种用于处理网址的 API：一种是 Node.js 特定的旧版 API，一种是实现了与 Web 浏览器使用的相同的 WHATWG 网址标准的新版 API。下图中上方显示的是由旧版 url.parse() 返回的对象的属性。 下方则是 WHATWG URL 对象的属性。WHATWG 网址的 origin 属性包括 protocol 和 host，但不包括 username 或 password。 123456// 使用 WHATWG API 解析网址字符串：const myURL = new URL(&#x27;xxx&#x27;);// 使用旧版 API 解析网址字符串：import url from &#x27;node:url&#x27;;const myURL = url.parse(&#x27;xxx&#x27;); new URL(input[, base]) input 要解析的绝对或相对的输入网址。 如果 input 是相对的，则需要 base。 如果 input 是绝对的，则忽略 base。 如果 input 不是字符串，则先转换成字符串。 base 如果 input 不是绝对的，则为要解析的基本网址。 如果 base 不是字符串，则先转换成字符串。通过相对于 base 解析 input 来创建新的 URL 对象。 如果 base 作为字符串传入，则其将被解析为等效于 new URL(base)。网址构造函数可作为全局对象的属性访问。 也可以从内置的 url 模块中导入：12import &#123; URL &#125; from &#x27;node:url&#x27;;console.log(URL === globalThis.URL); // 打印 &#x27;true&#x27;. 如果 input 或 base 不是有效的网址，则将抛出 TypeError。 注意，会将给定的值强制转换为字符串。出现在 input 的主机名中的 Unicode 字符将使用 Punycode 算法自动转换为 ASCII。只有在启用 ICU 的情况下编译 node 可执行文件时，此功能才可用。 如果不是，则域名将原封不动地传入。 如果事先不知道 input 是否是绝对的网址并且提供了 base，则建议验证 URL 对象的 origin 是否符合预期。 url.password获取和设置网址的密码部分。 1234567const myURL = new URL(&#x27;https://abc:xyz@example.com&#x27;);console.log(myURL.password);// 打印 xyzmyURL.password = &#x27;123&#x27;;console.log(myURL.href);// 打印 https://abc:123@example.com 分配给 password 属性的值中包含的无效的网址字符会进行百分比编码。 选择要进行百分比编码的字符可能与 url.parse() 和 url.format() 方法产生的结果有所不同。 url.port获取和设置网址的端口部分。端口值可以是数字，也可以是包含 0 到 65535（含）范围内的数字的字符串。 将值设置为给定 protocol 的 URL 对象的默认端口将导致 port 值成为空字符串 (‘’)。端口值可以是空字符串，在这种情况下端口取决于协议/方案：| 协议 | 端口 || “ftp” | 21 || “file” | || “http” | 80 || “https” | 443 || “ws” | 80 || “wss” | 443 |为端口分配值后，该值将首先使用 .toString() 转换为字符串。如果该字符串无效但以数字开头，则将前导数字分配给 port。 如果数字在上述范围之外，则将其忽略。包含小数点的数字，例如浮点数或科学记数法中的数字，也不例外。 小数点前的前导数字将被设置为网址的端口 1234567891011121314151617181920212223242526272829303132333435363738394041const myURL = new URL(&#x27;https://example.org:8888&#x27;);console.log(myURL.port);// 打印 8888// 默认端口自动转换为空字符串//（HTTPS 协议的默认端口是 443）myURL.port = &#x27;443&#x27;;console.log(myURL.port);// 打印空字符串console.log(myURL.href);// 打印 https://example.org/myURL.port = 1234;console.log(myURL.port);// 打印 1234console.log(myURL.href);// 打印 https://example.org:1234/// 完全无效的端口字符串被忽略myURL.port = &#x27;abcd&#x27;;console.log(myURL.port);// 打印 1234// 前导数字被视为端口号myURL.port = &#x27;5678abcd&#x27;;console.log(myURL.port);// 打印 5678// 非整数被截断myURL.port = 1234.5678;console.log(myURL.port);// 打印 1234// 未用科学计数法表示的超出范围的数字将被忽略。myURL.port = 1e10; // 10000000000，将按如下所述进行范围检查console.log(myURL.port);// 打印 1234myURL.port = 4.567e21;console.log(myURL.port);// 打印 4（因为它是字符串 &#x27;4.567e21&#x27; 中的前导数字） url.protocolWHATWG 网址标准认为少数网址协议方案在解析和序列化方式方面具有特殊性。 当使用这些特殊协议之一解析网址时，url.protocol 属性可能会更改为另一种特殊协议，但不能更改为非特殊协议，反之亦然。根据 WHATWG 网址标准，特殊协议方案有 ftp、file、http、https、ws 和 wss。 1234567891011121314const u = new URL(&#x27;http://example.org&#x27;);u.protocol = &#x27;https&#x27;;console.log(u.href);// https://example.orgconst u = new URL(&#x27;http://example.org&#x27;);u.protocol = &#x27;fish&#x27;;console.log(u.href);// http://example.orgconst u = new URL(&#x27;fish://example.org&#x27;);u.protocol = &#x27;http&#x27;;console.log(u.href);// fish://example.org url.searchParams获取表示网址查询参数的 URLSearchParams 对象。 此属性是只读的，但它提供的 URLSearchParams 对象可用于更改网址实例； 要替换网址的整个查询参数，则使用 url.search 设置器。 有关详细信息，请参阅 URLSearchParams 文档。当使用 .searchParams 修改 URL 时要小心，因为根据 WHATWG 规范，URLSearchParams 对象使用不同的规则来确定要对哪些字符进行百分比编码。 例如，URL 对象不会对 ASCII 波浪号 (~) 字符进行百分比编码，而 URLSearchParams 将始终对其进行编码 url.toJSON()URL 对象上的 toJSON() 方法返回序列化的网址。 返回值等同于 url.href 和 url.toString() 的值。当 URL 对象用 JSON.stringify() 序列化时，会自动调用此方法。 123456const myURLs = [ new URL(&#x27;https://www.example.com&#x27;), new URL(&#x27;https://test.example.org&#x27;),];console.log(JSON.stringify(myURLs));// 打印 [&quot;https://www.example.com/&quot;,&quot;https://test.example.org/&quot;] URLSearchParams 类 new URLSearchParams()实例化新的空 URLSearchParams 对象。 new URLSearchParams(string)将 string 解析为查询字符串，并使用它来实例化新的 URLSearchParams 对象。 前导 ‘?’（如果存在）将被忽略。 new URLSearchParams(obj) obj 表示键值对集合的对象使用查询哈希映射实例化新的 URLSearchParams 对象。 obj 的每个属性的键和值总是被强制转换为字符串。 与 querystring 模块不同，不允许以数组值的形式出现重复的键。 数组使用 array.toString() 字符串化，它简单地用逗号连接所有数组元素。 new URLSearchParams(iterable) iterable 元素为键值对的可迭代对象以类似于 Map 的构造函数的方式使用可迭代映射实例化新的 URLSearchParams 对象。 iterable 可以是 Array 或任何可迭代对象。 这意味着 iterable 可以是另一个 URLSearchParams，在这种情况下，构造函数将简单地创建提供的 URLSearchParams 的克隆。 iterable 的元素是键值对，并且本身可以是任何可迭代对象。允许重复的键。12345678910111213141516171819202122232425262728293031323334let params;// 使用数组params = new URLSearchParams([ [&#x27;user&#x27;, &#x27;abc&#x27;], [&#x27;query&#x27;, &#x27;first&#x27;], [&#x27;query&#x27;, &#x27;second&#x27;],]);console.log(params.toString());// 打印 &#x27;user=abc&amp;query=first&amp;query=second&#x27;// 使用 Map 对象const map = new Map();map.set(&#x27;user&#x27;, &#x27;abc&#x27;);map.set(&#x27;query&#x27;, &#x27;xyz&#x27;);params = new URLSearchParams(map);console.log(params.toString());// 打印 &#x27;user=abc&amp;query=xyz&#x27;// 使用生成器函数function* getQueryPairs() &#123; yield [&#x27;user&#x27;, &#x27;abc&#x27;]; yield [&#x27;query&#x27;, &#x27;first&#x27;]; yield [&#x27;query&#x27;, &#x27;second&#x27;];&#125;params = new URLSearchParams(getQueryPairs());console.log(params.toString());// 打印 &#x27;user=abc&amp;query=first&amp;query=second&#x27;// 每个键值对必须恰好有两个元素param = new URLSearchParams([[&#x27;user&#x27;, &#x27;abc&#x27;, &#x27;error&#x27;]]);console.log(params.toString());// 抛出 TypeError [ERR_INVALID_TUPLE]:// Each query pair must be an iterable [name, value] tuple urlSearchParams.set(name, value)将与 name 关联的 URLSearchParams 对象中的值设置为 value。如果存在任何名称为 name 的预先存在的名称-值对，则将第一个此类对的值设置为 value 并删除所有其他名称。如果没有，则将名称-值对追加到查询字符串。 1234567891011const params = new URLSearchParams();params.append(&#x27;foo&#x27;, &#x27;bar&#x27;);params.append(&#x27;foo&#x27;, &#x27;baz&#x27;);params.append(&#x27;abc&#x27;, &#x27;def&#x27;);console.log(params.toString());// 打印 foo=bar&amp;foo=baz&amp;abc=defparams.set(&#x27;foo&#x27;, &#x27;def&#x27;);params.set(&#x27;xyz&#x27;, &#x27;opq&#x27;);console.log(params.toString());// 打印 foo=def&amp;abc=def&amp;xyz=opq urlSearchParams.sort()按名称对所有现有的名称-值对进行就地排序。 排序是使用稳定排序算法完成的，因此保留了具有相同名称的名称-值对之间的相对顺序。该方法尤其可用于增加缓存命中。 url.pathToFileURL(path) path 要转换为文件网址的路径。返回: 文件网址对象。该函数确保 path 被绝对解析，并且在转换为文件网址时正确编码网址控制字符。 url.urlToHttpOptions(url)该实用函数按照 http.request() 和 https.request() API 的预期将网址对象转换为普通选项对象。 12345678910111213141516import &#123; urlToHttpOptions &#125; from &#x27;node:url&#x27;;const myURL = new URL(&#x27;https://a:b@測試?abc#foo&#x27;);console.log(urlToHttpOptions(myURL));/*&#123; protocol: &#x27;https:&#x27;, hostname: &#x27;xn--g6w251d&#x27;, hash: &#x27;#foo&#x27;, search: &#x27;?abc&#x27;, pathname: &#x27;/&#x27;, path: &#x27;/?abc&#x27;, href: &#x27;https://a:b@xn--g6w251d/?abc#foo&#x27;, auth: &#x27;a:b&#x27;&#125;*/ 网址中的百分号编码网址只允许包含一定范围的字符。 任何超出该范围的字符都必须进行编码。 这些字符的编码方式以及要编码的字符完全取决于字符在网址结构中的位置。 旧版的 API在旧版 API 中，空格 (‘ ‘) 和以下字符将在网址对象的属性中自动转义：&lt; &gt; “ ` \\r \\n \\t { } | \\ ^ ‘例如，ASCII 空格字符 (‘ ‘) 被编码为 %20。 ASCII 正斜杠 (/) 字符编码为 %3C。 WHATWG APIWHATWG 算法定义了四个“百分比编码集”，用于描述必须进行百分比编码的字符范围： C0 控制百分比编码集，包括 U+0000 到 U+001F（含）范围内的代码点和所有大于 U+007E 的代码点。 片段百分比编码集，包括 C0 控制百分比编码集和代码点 U+0020、U+0022、U+003C、U+003E 和 U+0060。 路径百分比编码集，包括 C0 控制百分比编码集和代码点 U+0020、U+0022、U+0023、U+003C、U+003E、U+003F、U+0060、U +007B 和 U+007D。 userinfo 编码集，包括路径百分比编码集和代码点 U+002F、U+003A、U+003B、U+003D、U+0040、U+005B、U+005C、U+005D、 U+005E 和 U+007C。片段百分比编码集用于网址片段。路径百分比编码集用于大多数网址的路径。userinfo 百分比编码集专门用于网址中编码的用户名和密码。除了所有其他情况外，C0 控制百分比编码集用于某些特定条件下的主机和路径。当主机名中出现非 ASCII 字符时，主机名将使用 Punycode 算法进行编码。 但是请注意，主机名可能包含 Punycode 编码和百分比编码的字符：12345const myURL = new URL(&#x27;https://%CF%80.example.com/foo&#x27;);console.log(myURL.href);// 打印 https://xn--1xa.example.com/fooconsole.log(myURL.origin);// 打印 https://xn--1xa.example.com"},{"title":"深入浅出nodejs阅读笔记(3)","date":"2022-11-26T12:36:45.000Z","updated":"2023-07-24T09:24:46.503Z","comments":true,"path":"nodejs/nodejs-note-3.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-3.html","excerpt":"","text":"内存控制 V8 的对象分配 在V8中，所有的JavaScript对象都是通过堆来进行分配的。 V8为何要限制堆的大小，表层原因为V8最初为浏览器而设计，不太可能遇到用大量内存的场景。对于网页来说，V8的限制值已经绰绰有余。深层原因是V8的垃圾回收机制的限制 Node在启动时可以传递–max-old-space-size或–max-new-space-size来调整内存限制的大小 V8 的垃圾回收机制 V8主要的垃圾回收算法 V8的垃圾回收策略主要基于分代式垃圾回收机制。 V8的内存分代在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象 V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面提及的–max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，-max-new-space-size命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错 在默认设置下，如果一直分配内存，在64位系统和32位系统下会分别只能使用约1.4 GB和约0.7 GB的大小 新生代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB Scavenge算法 在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法 Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace空间之间进行复制。 在单纯的Scavenge过程中，From空间中的存活对象会被复制到To空间中去，然后对From空间和To空间进行角色对换（又称翻转）。但在分代式垃圾回收的前提下，From空间中的存活对象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象晋升。对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。 Mark-Sweep &amp; Mark-Compact V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。Mark-Sweep是标记清除的意思，它分为标记和清除两个阶段。与Scavenge相比，Mark-Sweep并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与Scavenge复制活着的对象不同，Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象 Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态 Mark-Compact被提出来。Mark-Compact是标记整理的意思，是在Mark-Sweep的基础上演变而来的。它们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存 V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用Mark-Compact Incremental Marking 垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”（stop-the-world）。在V8的分代式垃圾回收中，一次小垃圾回收只收集新生代，由于新生代默认配置得较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但V8的老生代通常配置得较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记（incremental marking），也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成 查看垃圾回收日志 查看垃圾回收日志的方式主要是在启动时添加–trace_gc参数 通过在Node启动时使用–prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾回收执行时占用的时间高效使用内存 作用域 标识符查找 作用域链 变量的主动释放 闭包 实现外部作用域访问内部作用域中变量的方法叫做闭包（closure） 内存指标: process.memoryUsage()可以查看内存使用情况。除此之外，os模块中的totalmem()和freemem()方法也可以查看内存使用情况 查看内存使用情况 查看进程的内存占用12345$ node &gt; process.memoryUsage() &#123; rss: 13852672, heapTotal: 6131200, heapUsed: 2757120 &#125; rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区（swap）或者文件系统（filesystem）中。除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节 查看系统的内存占用 与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位 堆外内存: 将那些不是通过V8分配的内存称为堆外内存 Buffer对象并非通过V8分配12345678var useMem = function () &#123; var size = 200 * 1024 * 1024; var buffer = new Buffer(size); for (var i = 0; i &lt; size; i++) &#123; buffer[i] = 0; &#125; return buffer; &#125;; 内存泄漏Node对内存泄漏十分敏感，一旦线上应用有成千上万的流量，那怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多时间进行对象扫描，应用响应缓慢，直到进程内存溢出，应用崩溃 造成内存泄漏的原因 缓存。 在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描和整理时，对这些对象做无用功 用对象的键值对来缓存东西，与严格意义上的缓存有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有 解决手段：限定缓存对象的大小，加上完善的过期策略以防止内存无限制增长 缓存限制策略 记录键在数组中，一旦超过数量，就以先进先出的方式进行淘汰 LRU算法的缓存，地址为https://github.com/isaacs/node-lru-cache 缓存的解决方案 采用进程外的缓存，进程自身不存储状态 (1) 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。 (2) 进程之间可以共享缓存 Redis：https://github.com/mranney/node_redis。 Memcached：https://github.com/3rd-Eden/node-memcached。 队列消费不及时。 监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关人员。 任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值 作用域未释放 内存泄漏排查常见工具： v8-profiler node-heapdump12345678910var leakArray = []; var leak = function () &#123; leakArray.push(&quot;leak&quot; + Math.random()); &#125;; http.createServer(function (req, res) &#123; leak(); res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); res.end(&#x27;Hello World\\n&#x27;); &#125;).listen(1337); console.log(&#x27;Server running at http://127.0.0.1:1337/&#x27;); node-mtrace dtrace node-memwatch1234567891011121314151617181920var memwatch = require(&#x27;memwatch&#x27;); memwatch.on(&#x27;leak&#x27;, function (info) &#123; console.log(&#x27;leak:&#x27;); console.log(info); &#125;); memwatch.on(&#x27;stats&#x27;, function (stats) &#123; console.log(&#x27;stats:&#x27;) console.log(stats); &#125;); var http = require(&#x27;http&#x27;); var leakArray = []; var leak = function () &#123; leakArray.push(&quot;leak&quot; + Math.random()); &#125;; http.createServer(function (req, res) &#123; leak(); res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); res.end(&#x27;Hello World\\n&#x27;); &#125;).listen(1337); console.log(&#x27;Server running at http://127.0.0.1:1337/&#x27;); stats事件 每次进行全堆垃圾回收时，将会触发一次stats事件12345678910stats: &#123; num_full_gc: 4, // 第几次全堆垃圾回收 num_inc_gc: 23, // 第几次增量垃圾回收 heap_compactions: 4, // 第几次对老生代进行整理 usage_trend: 0, // 使用趋势 estimated_base: 7152944, // 预估基数 current_base: 7152944, // 当前基数 min: 6720776, // 最小 max: 7152944 &#125; // 最大在这些数据中，num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况 leak事件 如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会出发一个leak事件 堆内存比较12345678910111213var memwatch = require(&#x27;memwatch&#x27;); var leakArray = []; var leak = function () &#123; leakArray.push(&quot;leak&quot; + Math.random()); &#125;; // Take first snapshot var hd = new memwatch.HeapDiff(); for (var i = 0; i &lt; 10000; i++) &#123; leak(); &#125; // Take the second snapshot and compute the diff var diff = hd.end(); console.log(JSON.stringify(diff, null, 2)); 大内存应用stream模块用于处理大文件。stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种 由于V8的内存限制，我们无法通过fs.readFile()和fs.writeFile()直接进行大文件的操作，而改用fs.createReadStream()和fs.createWriteStream()方法通过流的方式实现对大文件的操作 123var reader = fs.createReadStream(&#x27;in.txt&#x27;); var writer = fs.createWriteStream(&#x27;out.txt&#x27;); reader.pipe(writer); 理解BufferBuffer是一个像Array的对象，但它主要用于操作字节 模块结构 Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现 由于Buffer太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象（global）上。所以在使用Buffer时，无须通过require()即可直接使用 Buffer对象 Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值 给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只保留整数部分123456buf[20] = -100; console.log(buf[20]); // 156 buf[21] = 300; console.log(buf[21]); // 44 buf[22] = 3.1415; console.log(buf[22]); // 3 Buffer内存分配 Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的 此Node在内存的使用上应用的是在C++层面申请内存、在JavaScript中分配内存的策略 为了高效地使用申请来的内存，Node采用了slab分配机制,一种动态内存管理机制 full：完全分配状态。 partial：部分分配状态。 empty：没有被分配状态。 Node以8 KB为界限来区分Buffer是大对象还是小对象,这个8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配 分配小Buffer对象 如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它 当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足够，使用剩余空间，并更新slab的分配状态 如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费 注意的事项是，由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象，但是如果不释放它，实际可能是8 KB的内存没有释放 分配大Buffer对象 如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占 Buffer 的转换Buffer对象可以与字符串之间相互转换,目前支持的字符串编码类型有如下这几种: ASCII UTF-8 UTF-16LE/UCS-2 Base64 Binary Hex 字符串转Buffer 字符串转Buffer对象主要是通过构造函数完成的：new Buffer(str, [encoding]); 通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储 需要小心的是，每种编码所用的字节长度不同，将Buffer反转回字符串时需要谨慎处理 Buffer转字符串 实现Buffer向字符串的转换也十分简单，Buffer对象的toString()可以将Buffer对象转换为字符串，代码如下：buf.toString([encoding], [start], [end]) 可以设置encoding（默认为UTF-8）、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。 Buffer不支持的编码类型 Buffer提供了一个isEncoding()函数来判断编码是否支持转换：Buffer.isEncoding(encoding) 在中国常用的GBK、GB2312和BIG-5编码都不在支持的行列中 对于不支持的编码类型，可以借助Node生态圈中的模块完成转换。iconv和iconv-lite两个模块可以支持更多的编码类型转换，包括Windows 125系列、ISO-8859系列、IBM/DOS代码页系列、Macintosh系列、KOI8系列，以及Latin1、US-ASCII，也支持宽字节编码GBK和GB2312 Buffer 的拼接123456789var fs = require(&#x27;fs&#x27;); var rs = fs.createReadStream(&#x27;test.md&#x27;); var data = &#x27;&#x27;; rs.on(&quot;data&quot;, function (chunk)&#123; data += chunk; &#125;); rs.on(&quot;end&quot;, function () &#123; console.log(data); &#125;); 原因在于文件可读流在读取时会逐个读取Buffer setEncoding()与string_decoder() setEncoding该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串 string_decoder目前只能处理UTF-8、Base64和UCS-2/UTF-16LE这3种编码。通过setEncoding()的方式不可否认能解决大部分的乱码问题，但并不能从根本上解决该问题。 正确拼接Buffer1234567891011var chunks = []; var size = 0; res.on(&#x27;data&#x27;, function (chunk) &#123; chunks.push(chunk); size += chunk.length; &#125;); res.on(&#x27;end&#x27;, function () &#123; var buf = Buffer.concat(chunks, size); var str = iconv.decode(buf, &#x27;utf8&#x27;); console.log(str); &#125;); 正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度，然后调用Buffer.concat()方法生成一个合并的Buffer对象 Buffer.concat()方法封装的从小Buffer对象向大Buffer对象的复制过程：12345678910111213141516171819202122232425Buffer.concat = function(list, length) &#123; if (!Array.isArray(list)) &#123; throw new Error(&#x27;Usage: Buffer.concat(list, [length])&#x27;); &#125; if (list.length === 0) &#123; return new Buffer(0); &#125; else if (list.length === 1) &#123; return list[0]; &#125; if (typeof length !== &#x27;number&#x27;) &#123; length = 0; for (var i = 0; i &lt; list.length; i++) &#123; var buf = list[i]; length += buf.length; &#125; &#125; var buffer = new Buffer(length); var pos = 0; for (var i = 0; i &lt; list.length; i++) &#123; var buf = list[i]; buf.copy(buffer, pos); pos += buf.length; &#125; return buffer; &#125;; Buffer 与性能通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗 文件读取 在文件的读取时，有一个highWaterMark设置对性能的影响至关重要 highWaterMark的大小对性能有两个影响的点 highWaterMark设置对Buffer内存的分配和使用有一定影响。 highWaterMark设置过小，可能导致系统调用次数过多。 highWaterMark值的大小与读取速度的关系：该值越大，读取速度越快。 网络编程Node提供了net、dgram、http、https这4个模块，分别用于处理TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端 构建 TCP 服务 TCP TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于TCP构建，典型的是HTTP、SMTP、IMAP等协议 TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话 创建TCP服务器端1234567891011121314var net = require(&#x27;net&#x27;); var server = net.createServer(function (socket) &#123; // 新的连接 socket.on(&#x27;data&#x27;, function (data) &#123; socket.write(&quot;你好&quot;); &#125;); socket.on(&#x27;end&#x27;, function () &#123; console.log(&#x27;连接断开&#x27;); &#125;); socket.write(&quot;欢迎光临《深入浅出Node.js》示例：\\n&quot;); &#125;); server.listen(8124, function () &#123; console.log(&#x27;server bound&#x27;); &#125;); TCP服务的事件 服务器事件 listening：在调用server.listen()绑定端口或者Domain Socket后触发，简洁写法为server.listen(port,listeningListener)，通过listen()方法的第二个参数传入。 connection：每个客户端套接字连接到服务器端时触发，简洁写法为通过net.create\u0002Server()，最后一个参数传递。 close：当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。 error：当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发一个异常，如果不侦听error事件，服务器将会抛出异常 连接事件 data：当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是write()发送的数据。 end：当连接中的任意一端发送了FIN数据时，将会触发该事件。 connect：该事件用于客户端，当套接字与服务器端连接成功时会被触发。 drain：当任意一端调用write()发送数据时，当前这端会触发该事件。 error：当异常发生时，触发该事件。 close：当套接字完全关闭时，触发该事件。 timeout：当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了 TCP针对网络中的小数据包有一定的优化策略：Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效数据的数据包，将十分浪费网络资源。Nagle算法针对这种情况，要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是数据有可能被延迟发送。 在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDelay(true)去掉Nagle算法，使得write()可以立即发送数据到网络中 另一个需要注意的是，尽管在网络的一端调用write()会触发另一端的data事件，但是并不意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多个小数据包合并，然后只触发一次data事件构建 UDP 服务UDP又称用户数据包协议，与TCP一样同属于网络传输层。UDP与TCP最大的不同是UDP不是面向连接的。TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于它无须连接，资源消耗低，处理快速且灵活，所以常常应用在那种偶尔丢一两个数据包也不会产生重大影响的场景，比如音频、视频等。UDP目前应用很广泛，DNS服务即是基于它实现的。 创建UDP套接字 创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据。 var dgram = require(‘dgram’); var socket = dgram.createSocket(“udp4”); 创建UDP服务器端 若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可123456789101112var dgram = require(&quot;dgram&quot;); var server = dgram.createSocket(&quot;udp4&quot;); server.on(&quot;message&quot;, function (msg, rinfo) &#123; console.log(&quot;server got: &quot; + msg + &quot; from &quot; + rinfo.address + &quot;:&quot; + rinfo.port); &#125;); server.on(&quot;listening&quot;, function () &#123; var address = server.address(); console.log(&quot;server listening &quot; + address.address + &quot;:&quot; + address.port); &#125;); server.bind(41234); 创建UDP客户端123456789var dgram = require(&#x27;dgram&#x27;); var message = new Buffer(&quot;深入浅出Node.js&quot;); var client = dgram.createSocket(&quot;udp4&quot;); client.send(message, 0, message.length, 41234, &quot;localhost&quot;, function(err, bytes) &#123; client.close(); &#125;); socket.send(buf, offset, length, port, address, [callback])// 参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送完成后的回调 UDP套接字事件 UDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream的实例。它具备如下自定义事件 message：当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息。 listening：当UDP套接字开始侦听时触发该事件。 close：调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。 error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。 构建 HTTP 服务 HTTP 初识HTTP HTTP的全称是超文本传输协议，英文写作HyperText Transfer Protocol HTTP构建在TCP之上，属于应用层协议。在HTTP的两端是服务器和浏览器，即著名的B/S模式，如今精彩纷呈的Web即是HTTP的应用。 HTTP得以发展是W3C和IETF两个组织合作的结果，他们最终发布了一系列RFC标准，目前最知名的HTTP标准为RFC 2616。 HTTP报文12345678910111213141516171819$ curl -v http://127.0.0.1:1337 * About to connect() to 127.0.0.1 port 1337 (#0) * Trying 127.0.0.1... * connected * Connected to 127.0.0.1 (127.0.0.1) port 1337 (#0) &gt; GET / HTTP/1.1 &gt; User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 &gt; Host: 127.0.0.1:1337 &gt; Accept: */* &gt; &lt; HTTP/1.1 200 OK &lt; Content-Type: text/plain &lt; Date: Sat, 06 Apr 2013 08:01:44 GMT &lt; Connection: keep-alive &lt; Transfer-Encoding: chunked &lt; Hello World* Connection #0 to host 127.0.0.1 left intact * Closing connection #0 HTTP服务只做两件事情：处理HTTP请求和发送HTTP响应 http模块 在Node中，HTTP服务继承自TCP服务器（net模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。 http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象，它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业务逻辑 HTTP服务的事件 connection事件：在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。 request事件：建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在res.end()后，TCP连接可能将用于下一次请求响应。 close事件：与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给server.close()传递一个回调函数来快速注册该事件。 checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue事件；如果没有为服务器监听这个事件，服务器将会自动响应客户端100 Continue的状态码，表示接受数据上传；如果不接受数据的较多时，响应客户端400 Bad Request拒绝客户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件之间互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件。 connect事件：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭 upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。这在后文的WebSocket部分有详细流程的介绍。如果不监听该事件，发起该请求的连接将会关闭。 clientError事件：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件HTTP客户端http模块提供了一个底层API：http.request(options, connect)，用于构造HTTP客户端123456789101112131415var options = &#123; hostname: &#x27;127.0.0.1&#x27;, port: 1334, path: &#x27;/&#x27;, method: &#x27;GET&#x27; &#125;; var req = http.request(options, function(res) &#123; console.log(&#x27;STATUS: &#x27; + res.statusCode); console.log(&#x27;HEADERS: &#x27; + JSON.stringify(res.headers)); res.setEncoding(&#x27;utf8&#x27;); res.on(&#x27;data&#x27;, function (chunk) &#123; console.log(chunk); &#125;); &#125;); req.end(); HTTP请求头中的选项有: host：服务器的域名或IP地址，默认为localhost。 hostname：服务器名称。 port：服务器端口，默认为80。 localAddress：建立网络连接的本地网卡。 socketPath：Domain套接字路径。 method：HTTP请求方法，默认为GET。 path：请求路径，默认为/。 headers：请求头对象。 auth：Basic认证，这个值将被计算成请求头中的Authorization部分。 HTTP响应 HTTP客户端的响应对象与服务器端较为类似，在ClientRequest对象中，它的事件叫做response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一个响应对象以供操作ClientResponse。12345678function(res) &#123; console.log(&#x27;STATUS: &#x27; + res.statusCode); console.log(&#x27;HEADERS: &#x27; + JSON.stringify(res.headers)); res.setEncoding(&#x27;utf8&#x27;); res.on(&#x27;data&#x27;, function (chunk) &#123; console.log(chunk); &#125;); &#125; HTTP 代理 http提供的ClientRequest对象也是基于TCP层实现的，在keepalive的情况下，一个底层会话连接可以多次用于请求。为了重用TCP连接，http模块包含一个默认的客户端代理对象http.globalAgent。它对每个服务器端（host + port）创建的连接进行了管理，默认情况下，通过ClientRequest对象对同一个服务器端发起的HTTP请求最多可以创建5个连接 调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名有下载连接数的限制是相同的行为 如果你在服务器端通过ClientRequest调用网络中的其他HTTP服务，记得关注代理对象对网络请求的限制。一旦请求量过大，连接限制将会限制服务性能。如需要改变，可以在options中传递agent选项。默认情况下，请求会采用全局的代理对象，默认连接数限制的为512345678910var agent = new http.Agent(&#123; maxSockets: 10 &#125;); var options = &#123; hostname: &#x27;127.0.0.1&#x27;, port: 1334, path: &#x27;/&#x27;, method: &#x27;GET&#x27;, agent: agent &#125;; 可以设置agent选项为false值，以脱离连接池的管理，使得请求不受并发的限制 HTTP客户端事件 response：与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时，会触发该事件。 socket：当底层连接池中建立的连接分配给当前请求对象时，触发该事件。 connect：当客户端向服务器端发起CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。 upgrade：客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。 continue：客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件 构建 WebSocket 服务 WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。 WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。 websocket与http相比的优点： 客户端与服务器端只建立一个TCP连接，可以使用更少的连接。 WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。 有更轻量级的协议头，减少数据传送量。 12345678910var socket = new WebSocket(&#x27;ws://127.0.0.1:12010/updates&#x27;); socket.onopen = function () &#123; setInterval(function() &#123; if (socket.bufferedAmount == 0) socket.send(getUpdateData()); &#125;, 50); &#125;; socket.onmessage = function (event) &#123; // TODO：event.data &#125;; 在WebSocket之前，网页客户端与服务器端进行通信最高效的是Comet技术。实现Comet技术的细节是采用长轮询（long-polling）或iframe流。长轮询的原理是客户端向服务器端发起请求，服务器端只在超时或有数据响应时断开连接（res.end()）；客户端在收到数据或者超时后重新发起请求。这个请求行为拖着长长的尾巴，是故用Comet（彗星）来命名它 WebSocket握手1234567GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Upgrade/Connection两个字段表示请求服务器端升级协议为WebSocket。其中Sec-WebSocket-Key用于安全校验 Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，形成字符串dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11，然后通过sha1安全散列算法计算出结果后，再进行Base64编码，最后返回给客户端 服务器端在处理完请求后，响应如下报文：12345HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Sec-WebSocket-Protocol: chat WebSocket数据传输 12345678WebSocket.prototype.setSocket = function (socket) &#123; this.socket = socket; this.socket.on(&#x27;data&#x27;, this.receiver); &#125;; WebSocket.prototype.send = function (data) &#123; this._send(data); &#125;; 为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧（比如中间拦截破坏），连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭 fin：如果这个数据帧是最后一帧，这个fin位为1，其余情况为0。当一个数据没有被分为多帧时，它既是第一帧也是最后一帧。 rsv1、rsv2、rsv3：各为1位长，3个标识用于扩展，当有已协商的扩展时，这些值可能为1，其余情况为0。 opcode：长为4位的操作码，可以用来表示0到15的值，用于解释当前数据帧。0表示附加数据帧，1表示文本数据帧，2表示二进制数据帧，8表示发送一个连接关闭的数据帧，9表示ping数据帧，10表示pong数据帧，其余值暂时没有定义。ping数据帧和pong数据帧用于心跳检测，当一端发送ping数据帧时，另一端必须发送pong数据帧作为响应，告知对方这一端仍然处于响应状态。 masked：表示是否进行掩码处理，长度为1。客户端发送给服务器端时为1，服务器端发送给客户端时为0。 payload length：一个7、7+16或7+64位长的数据位，标识数据的长度，如果值在0~125之间，那么该值就是数据的真实长度；如果值是126，则后面16位的值是数据的真实长度；如果值是127，则后面64位的值是数据的真实长度。 masking key：当masked为1时存在，是一个32位长的数据位，用于解密数据。 payload data：我们的目标数据，位数为8的倍数。 node与websocket共性 基于事件的编程接口。 基于JavaScript，以封装良好的WebSocket实现，API与客户端可以高度相似。 网络服务与安全Node在网络安全上提供了3个模块，分别为crypto、tls、https。其中crypto主要用于加密解密，，tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接之上 TLS/SSL 密钥 TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间需要互换公钥 Node在底层采用的是openssl实现TLS/SSL的，为此要生成公钥和私钥可以通过openssl完成。123456789# 私钥// 生成服务器端私钥$ openssl genrsa -out server.key 1024 // 生成客户端私钥$ openssl genrsa -out client.key 1024#公钥$ openssl rsa -in server.key -pubout -out server.pem $ openssl rsa -in client.key -pubout -out client.pem 传递公私钥中可能存在中间人攻击，为了解决这个问题，TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名 数字证书 CA（Certificate Authority，数字证书认证中心）。CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名 通过CA机构颁发证书通常是一个烦琐的过程，需要付出一定的精力和费用。对于中小型企业而言，多半是采用自签名证书来构建安全网络的。所谓自签名证书，就是自己扮演CA机构，给自己的服务器端颁发签名证书123$ openssl genrsa -out ca.key 1024 $ openssl req -new -key ca.key -out ca.csr $ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt TLS服务 创建服务器端1234567891011121314151617181920var tls = require(&#x27;tls&#x27;); var fs = require(&#x27;fs&#x27;); var options = &#123; key: fs.readFileSync(&#x27;./keys/server.key&#x27;), cert: fs.readFileSync(&#x27;./keys/server.crt&#x27;), requestCert: true, ca: [ fs.readFileSync(&#x27;./keys/ca.crt&#x27;) ] &#125;; var server = tls.createServer(options, function (stream) &#123; console.log(&#x27;server connected&#x27;, stream.authorized ? &#x27;authorized&#x27; : &#x27;unauthorized&#x27;); stream.write(&quot;welcome!\\n&quot;); stream.setEncoding(&#x27;utf8&#x27;); stream.pipe(stream); &#125;); server.listen(8000, function() &#123; console.log(&#x27;server bound&#x27;); &#125;); # 通过下面的命令可以测试证书是否正常$ openssl s_client -connect 127.0.0.1:8000 TLS客户端12345678910111213141516171819202122232425// 创建私钥$ openssl genrsa -out client.key 1024 // 生成CSR $ openssl req -new -key client.key -out client.csr // 生成签名证书$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crtvar tls = require(&#x27;tls&#x27;); var fs = require(&#x27;fs&#x27;); var options = &#123; key: fs.readFileSync(&#x27;./keys/client.key&#x27;), cert: fs.readFileSync(&#x27;./keys/client.crt&#x27;), ca: [ fs.readFileSync(&#x27;./keys/ca.crt&#x27;) ] &#125;; var stream = tls.connect(8000, options, function () &#123; console.log(&#x27;client connected&#x27;, stream.authorized ? &#x27;authorized&#x27; : &#x27;unauthorized&#x27;); process.stdin.pipe(stream); &#125;); stream.setEncoding(&#x27;utf8&#x27;); stream.on(&#x27;data&#x27;, function(data) &#123; console.log(data); &#125;); stream.on(&#x27;end&#x27;, function() &#123; server.close(); &#125;); HTTPS服务 创建HTTPS服务12345678910111213141516171819202122232425var https = require(&#x27;https&#x27;); var fs = require(&#x27;fs&#x27;); var options = &#123; key: fs.readFileSync(&#x27;./keys/server.key&#x27;), cert: fs.readFileSync(&#x27;./keys/server.crt&#x27;) &#125;; https.createServer(options, function (req, res) &#123; res.writeHead(200); res.end(&quot;hello world\\n&quot;); &#125;).listen(8000);$ curl https://localhost:8000/ curl: (60) SSL certificate problem, verify that the CA cert is OK. Details: error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed More details here: http://curl.haxx.se/docs/sslcerts.html curl performs SSL certificate verification by default, using a &quot;bundle&quot; of Certificate Authority (CA) public keys (CA certs). If the default bundle file isn&#x27;t adequate, you can specify an alternate file using the --cacert option. If this HTTPS server uses a certificate signed by a CA represented in the bundle, the certificate verification probably failed due to a problem with the certificate (it might be expired, or the name might not match the domain name in the URL). If you&#x27;d like to turn off curl&#x27;s verification of the certificate, use the -k (or --insecure) option. 由于是自签名的证书，curl工具无法验证服务器端证书是否正确，所以出现了上述的抛错，解决方案： 一种是加-k选项，让curl工具忽略掉证书的验证，这样的结果是数据依然会通过公钥加密传输，但是无法保证对方是可靠的，会存在中间人攻击的潜在风险 一种解决的方式是给curl设置–cacert选项，告知CA证书使之完成对服务器证书的验证12345$ curl -k https://localhost:8000/ hello world$ curl --cacert keys/ca.crt https://localhost:8000/ hello world HTTPS客户端12345678910111213141516171819202122var https = require(&#x27;https&#x27;); var fs = require(&#x27;fs&#x27;); var options = &#123; hostname: &#x27;localhost&#x27;, port: 8000, path: &#x27;/&#x27;, method: &#x27;GET&#x27;, key: fs.readFileSync(&#x27;./keys/client.key&#x27;), cert: fs.readFileSync(&#x27;./keys/client.crt&#x27;), ca: [fs.readFileSync(&#x27;./keys/ca.crt&#x27;)] &#125;; options.agent = new https.Agent(options); var req = https.request(options, function(res) &#123; res.setEncoding(&#x27;utf-8&#x27;); res.on(&#x27;data&#x27;, function(d) &#123; console.log(d); &#125;); &#125;); req.end(); req.on(&#x27;error&#x27;, function(e) &#123; console.log(e); &#125;); 如果不设置ca选项，将会得到如下异常: [Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE]解决该异常的方案是添加选项属性rejectUnauthorized为false，它的效果与curl工具加-k一样，都会在数据传输过程中会加密，但是无法保证服务器端的证书不是伪造的 ??? 当客户端调用send()发送数据时，服务器端触发onmessage()；当服务器端调用send()发送数据时，客户端的onmessage()触发。当我们调用send()发送一条数据时，协议可能将这个数据封装为一帧或多帧数据，然后逐帧发送"},{"title":"深入浅出nodejs阅读笔记(5)","date":"2022-12-26T13:26:47.000Z","updated":"2023-07-24T09:24:46.503Z","comments":true,"path":"nodejs/nodejs-note-5.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-5.html","excerpt":"","text":"测试单元测试单元测试的意义编写可测试代码有以下几个原则可以遵循： 单一职责。如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输入数据，然后推测它的输出 接口抽象。通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码实现的变化不影响为接口编写的单元测试。 层次分离。层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之后，可以逐层测试，逐层保证 单元测试介绍单元测试主要包含断言、测试框架、测试用例、测试覆盖率、mock、持续集成等几个方面，由于Node的特殊性，它还会加入异步代码测试和私有方法的测试这两个部分 断言：断言就是单元测试中用来保证最小单元是否正常的检测方法断言用于检查程序在运行时是否满足期望。JavaScript的断言规范最早来自于CommonJS的单元测试规范（详见http://wiki.commonjs.org/wiki/Unit_Testing/1.0），Node实现了规范中的断言部分。 12var assert = require(&#x27;assert&#x27;); assert.equal(Math.max(1, 100), 100); 在断言规范中，定义了以下几种检测方法: ok()：判断结果是否为真。 equal()：判断实际值与期望值是否相等。 notEqual()：判断实际值与期望值是否不相等。 deepEqual()：判断实际值与期望值是否深度相等（对象或数组的元素是否相等）。 notDeepEqual()：判断实际值与期望值是否不深度相等。 strictEqual()：判断实际值与期望值是否严格相等（相当于===）。 notStrictEqual()：判断实际值与期望值是否不严格相等（相当于!==）。 throws()：判断代码块是否抛出异常。除此之外，Node的assert模块还扩充了如下两个断言方法。 doesNotThrow()：判断代码块是否没有抛出异常。 ifError()：判断实际值是否为一个假值（null、undefined、0、’’、false），如果实际值为真值，将会抛出异常。 测试框架测试框架用于为测试服务，它本身并不参与测试，主要用于管理测试用例和生成测试报告，提升测试用例的开发速度，提高测试用例的可维护性和可读性，以及一些周边性的工作 测试风格测试用例的不同组织方式称为测试风格，现今流行的单元测试风格主要有TDD（测试驱动开发）和BDD（行为驱动开发）两种，它们的差别如下所示: 关注点不同。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。 表达方式不同。TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯 mocha的BDD风格示例 12345678910describe(&#x27;Array&#x27;, function()&#123; before(function()&#123; // ... &#125;); describe(&#x27;#indexOf()&#x27;, function()&#123; it(&#x27;should return -1 when not present&#x27;, function()&#123; [1,2,3].indexOf(4).should.equal(-1); &#125;); &#125;); &#125;); BDD对测试用例的组织主要采用describe和it进行组织。describe可以描述多层级的结构，具体到测试用例时，用it。另外，它还提供before、after、beforeEach和afterEach这4个钩子方法，用于协助describe中测试用例的准备、安装、卸载和回收等工作。before和after分别在进入和退出describe时触发执行，beforeEach和afterEach则分别在describe中每一个测试用例（it）执行前和执行后触发执行mocha的TDD风格示例 12345678910suite(&#x27;Array&#x27;, function()&#123; setup(function()&#123; // ... &#125;); suite(&#x27;#indexOf()&#x27;, function()&#123; test(&#x27;should return -1 when not present&#x27;, function()&#123; assert.equal(-1, [1,2,3].indexOf(4)); &#125;); &#125;); &#125;); TDD对测试用例的组织主要采用suite和test完成。suite也可以实现多层级描述，测试用例用test。它提供的钩子函数仅包含setup和teardown，对应BDD中的before和after。 测试报告mocha提供了相当丰富的报告格式，调用mocha –reporters即可查看所有的报告格式默认的报告格式为dot，其他比较常用的格式有spec、json、html-cov等。执行mocha -R 命令即可采用这些报告。json报告因为其格式非常通用，多用于将结果传递给其他程序进行处理，而html-cov则用于可视化地观察代码覆盖率 测试用例测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用例。对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注 异步测试123456it(&#x27;fs.readFile should be ok&#x27;, function (done) &#123; fs.readFile(&#x27;file_path&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123; should.not.exist(err); done(); &#125;); &#125;); 测试用例方法it()接受两个参数；用例标题（title）和回调函数（fn）。通过检查这个回调函数的形参长度（fn.length）来判断这个用例是否是异步调用，如果是异步调用，在执行测试用例时，会将一个函数done()注入为实参，测试代码需要主动调用这个函数通知测试框架当前测试用例执行完成，然后测试框架才进行下一个测试用例的执行 超时设置mocha给所有涉及异步的测试用例添加了超时限制，如果一个用例的执行时间超过了预期时间，将会记录下一个超时错误，然后执行下一个测试用例1234it(&#x27;async test&#x27;, function (done) &#123; // 模拟一个要执行很久的异步方法 setTimeout(done, 10000); &#125;); mocha的默认超时时间为2000毫秒。一般情况下，通过mocha -t 设置所有用例的超时时间。若需更细粒度地设置超时时间，可以在测试用例it中调用this.timeout(ms)实现对单个用例的特殊设置1234it(&#x27;should take less than 500ms&#x27;, function (done) &#123; this.timeout(500); setTimeout(done, 300); &#125;); 也可以在描述describe中调用this.timeout(ms)设置描述下当前层级的所有用例123456789describe(&#x27;a suite of tests&#x27;, function()&#123; this.timeout(500); it(&#x27;should take less than 500ms&#x27;, function (done) &#123; setTimeout(done, 300); &#125;); it(&#x27;should take less than 500ms as well&#x27;, function (done) &#123; setTimeout(done, 200); &#125;); &#125;); 测试覆盖率测试覆盖率是单元测试中的一个重要指标，它能够概括性地给出整体的覆盖度，也能明确地给出统计到行的覆盖情况 若要探知这个测试用例对源代码的覆盖率，需要一种工具来统计每一行代码是否执行，这里要介绍的相关工具是jscover模块。通过npm install jscover -g的方式可以安装该模块 jscover模块虽然已经够用，但是还有两个问题: 它的编译部分是通过Java实现的，这样环境依赖上就多出了Java。 它需要编译代码到一个额外的新目录，这个过程相对麻烦。blanket模块解决了这两个问题，它由纯JavaScript实现，编译代码的过程也是隐式的，无须配置额外的目录，对于原模块项目没有额外的侵入 blanket与jscover的原理基本一致，在实现过程上有所不同，其差别在于blanket将编译的步骤注入在require中，而不是去额外编译成文件，执行测试时再去引用编译后的文件，它的技巧在require中 它的配置比jscover要简单，只需要在所有测试用例运行之前通过–require选项引入它即可：mocha –require blanket -R html-cov &gt; coverage.html 另一个需要注意的是，在包描述文件中配置scripts节点。在scripts节点中，pattern属性用以匹配需要编译的文件： 12345&quot;scripts&quot;: &#123; &quot;blanket&quot;: &#123; &quot;pattern&quot;: &quot;eventproxy/lib&quot; &#125; &#125;, 当在测试文件中通过require引入一个文件模块时，它将判断这个文件的实际路径，如果符合这个匹配规则，就对它进行编译 使用blanket之后，就无须配置环境变量了，也无须根据环境去判断引入哪种代码 mock在测试领域里，模拟异常其实是一个不小的科目，它有着一个特殊的名词：mock。我们通过伪造被调用方来测试上层代码的健壮性等 由于mock的过程比较烦琐，这里推荐一个模块来解决此事——muk 123456789101112131415161718192021222324var fs = require(&#x27;fs&#x27;); var muk = require(&#x27;muk&#x27;); before(function () &#123; muk(fs, &#x27;readFileSync&#x27;, function(path, encoding) &#123; throw new Error(&quot;mock readFileSync error&quot;); &#125;); &#125;); // it(); after(function () &#123; muk.restore(); &#125;); var fs = require(&#x27;fs&#x27;); var muk = require(&#x27;muk&#x27;); beforeEach(function () &#123; muk(fs, &#x27;readFileSync&#x27;, function(path, encoding) &#123; throw new Error(&quot;mock readFileSync error&quot;); &#125;); &#125;); // it(); // it(); afterEach(function () &#123; muk.restore(); &#125;); 模拟时无须临时缓存正确引用，用例执行结束后调用muk.restore()恢复即可 值得注意的一点是，对于异步方法的模拟，需要十分小心是否将异步方法模拟为同步 12345fs.readFile = function (filename, encoding, callback) &#123; process.nextTick(function () &#123; callback(new Error(&quot;mock readFile error&quot;)); &#125;); &#125;; 私有方法的测试除了将这些私有方法通过exports导出外。rewire模块提供了一种巧妙的方式实现对私有方法的访问。rewire的调用方式与require十分类似。对于如下的私有方法，我们获取它并为其执行测试用例非常简单： 123456789var limit = function (num) &#123; return num &lt; 0 ? 0 : num; &#125;; it(&#x27;limit should return success&#x27;, function () &#123; var lib = rewire(&#x27;../lib/index.js&#x27;); var litmit = lib.__get__(&#x27;limit&#x27;); litmit(10).should.be.equal(10); &#125;); 每一个被rewire引入的模块都有__set__()和__get__()方法。它巧妙地利用了闭包的诀窍，在eval()执行时，实现了对模块内部局部变量的访问，从而可以将局部变量导出给测试用例调用执行 工程化与自动化工程化Node在*nix系统下可以很好地利用一些成熟工具，其中Makefile比较小巧灵活，适合用来构建工程 持续集成travis-ci 性能测试单元测试主要用于检测代码的行为是否符合预期。在完成代码的行为检测后，还需要对已有代码的性能作出评估，检测已有功能是否能满足生产环境的性能要求，能否承担实际业务带来的压力。换句话说，性能也是功能。性能测试的范畴比较广泛，包括负载测试、压力测试和基准测试等 基准测试基准测试要统计的就是在多少时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以此来判别性能的差距 为了得到更规范和更好的输出结果，这里介绍benchmark这个模块是如何组织基准测试的 12345678910111213141516var Benchmark = require(&#x27;benchmark&#x27;); var suite = new Benchmark.Suite(); var arr = [0, 1, 2, 3, 5, 6]; suite.add(&#x27;nativeMap&#x27;, function () &#123; return arr.map(callback); &#125;).add(&#x27;customMap&#x27;, function () &#123; var ret = []; for (var i = 0; i &lt; arr.length; i++) &#123; ret.push(callback(arr[i])); &#125; return ret; &#125;).on(&#x27;cycle&#x27;, function (event) &#123; console.log(String(event.target)); &#125;).on(&#x27;complete&#x27;, function() &#123; console.log(&#x27;Fastest is &#x27; + this.filter(&#x27;fastest&#x27;).pluck(&#x27;name&#x27;)); &#125;).run(); 压力测试对网络接口做压力测试需要考查的几个指标有吞吐率、响应时间和并发数，这些指标反映了服务器的并发处理能力 最常用的工具是ab、siege、http_load等，下面我们通过ab工具来构造压力测试 12345678910111213141516171819202122232425262728293031323334353637383940$ ab -c 10 -t 3 http://localhost:8001/ This is ApacheBench, Version 2.3 &lt;$Revision: 655654 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking localhost (be patient) Completed 5000 requests Completed 10000 requests Finished 11573 requests Server Software: Server Hostname: localhost Server Port: 8001 Document Path: / Document Length: 10240 bytes Concurrency Level: 10 Time taken for tests: 3.000 seconds Complete requests: 11573 Failed requests: 0 Write errors: 0 Total transferred: 119375495 bytes HTML transferred: 118507520 bytes Requests per second: 3857.60 [#/sec] (mean) Time per request: 2.592 [ms] (mean) Time per request: 0.259 [ms] (mean, across all concurrent requests) Transfer rate: 38858.59 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.3 0 31 Processing: 1 2 1.9 2 35 Waiting: 0 2 1.9 2 35 Total: 1 3 2.0 2 35 Percentage of the requests served within a certain time (ms) 50% 2 66% 3 75% 3 80% 3 90% 3 95% 3 98% 5 99% 6 100% 35 (longes % t request) 各个参数的含义: Document Path：表示文档的路径，此处为/。 Document Length：表示文档的长度，就是报文的大小，这里有10KB。 Concurrency Level：并发级别，就是我们在命令中传入的c，此处为10，即10个并发。 Time taken for tests：表示完成所有测试所花费的时间，它与命令行中传入的t选项有细微出入。 Complete requests：表示在这次测试中一共完成多少次请求。 Failed requests：表示其中产生失败的请求数，这次测试中没有失败的请求。 Write errors：表示在写入过程中出现的错误次数（连接断开导致的）。 Total transferred：表示所有的报文大小。 HTML transferred：表示仅HTTP报文的正文大小，它比上一个值小。 Requests per second：这是我们重点关注的一个值，它表示服务器每秒能处理多少请求，是重点反映服务器并发能力的指标。这个值又称RPS或QPS。 两个Time per request值：第一个代表的是用户平均等待时间，第二个代表的是服务器平均请求处理事件，前者除以并发数得到后者。 Transfer rate：表示传输率，等于传输的大小除以传输时间，这个值受网卡的带宽限制。 Connection Times：连接时间，它包括客户端向服务器端建立连接、服务器端处理请求、等待报文响应的过程。 基准测试驱动开发简称也是BDD，全称为Benchmark Driven Development，即基准测试驱动开发，其中主要分为如下几步:(1) 写基准测试。(2) 写/改代码。(3) 收集数据。(4) 找出问题。(5)回到第(2)步 产 品 化项目工程化所谓的工程化，可以理解为项目的组织能力。体现在文件上，就是文件的组织能力 目录结构 主要的两类项目为Web应用和模块应用。普通的模块应用遵循CommonJS的模块和包规范即可 构建工具在Node的应用中，主流的构建工具还是老牌的make，但它的缺点是只在*nix操作系统下有效。为了实现跨平台，Grunt应运而生。Grunt通过Node写成，借助Node的跨平台能力，实现了很好的平台兼容性。Makefile Makefile文件是*nix系统下经典的构建工具。除了Windows系统外，其他系统几乎都能使用它。受Makefile影响的还有Ruby的Rakefile和Gemfile等。Makefile文件通常用来管理一些编译相关Grunt Makefile唯一的缺陷也许就是跨平台问题了，为此才有ant、rake等工具的出现。在Node生态系统中，也有一款构建工具解决了Makefile无法跨平台的问题——Grunt。 Grunt用Node写成，能够同时在Windows和*nix平台下运行。 Grunt结合NPM的包依赖管理，完全可以媲美Java世界的Maven工具，同时它又如Makefile一样，能够用来构建完善的自动化任务工具。 它的设计理念与Makefile并不相同：Makefile依托强大的bash编程，Grunt则依托它丰富的插件，它自身提供通用接口用于插件的接入，具体的任务则由插件完成。 Grunt的核心插件以grunt-contrib-开头，在NPM包管理平台上可以找到和查看。Grunt提供了3个模块分别用于运行时、初始化和命令行：grunt、grunt-init、grunt-cli。后面两个模块都可以作为命令行工具使用，安装时带-g即可 编码规范编码规范的统一一般有几种实现方式，一种是文档式的约定，一种是代码提交时的强制检查。前者靠自觉，后者靠工具 代码审查代码审查主要在请求合并的过程中完成，需要审查的点有功能是否正确完成、编码风格是否符合规范、单元测试是否有同步添加等 部署流程部署环境普通测试环境称为stage环境，预发布环境称为pre-release环境，实际的生产环境称为product环境 部署操作为了能让进程持续执行，我们可能会用到nohup和&amp;以不挂断进程的方式执行：nohup node app.js &amp; 性能对于Web应用而言，最直接有效的莫过于动静分离、多进程架构、分布式，其中涉及的几个拆分原则如下所示。 做专一的事。 让擅长的工具做擅长的事情。 将模型简化。 将风险分离 动静分离将图片、脚本、样式表和多媒体等静态文件都引导到专业的静态文件服务器上，让Node只处理动态请求即可。这个过程可以用Nginx或者专业的CDN来处理 启用缓存提升性能其实差不多只有两个途经，一是提升服务的速度，二是避免不必要的计算。前者提升的性能在海量流量面前终有瓶颈，但后者却能够在访问量越大时收益越多。避免不必要的计算，应用场景最多的就是缓存 多进程架构读写分离 日志访问日志访问日志一般用来记录每个客户端对应用的访问。在Web应用中，主要记录HTTP请求中的关键数据。中间件框架Connect在其众多中间件中提供了一个日志中间件，通过它可以将关键数据按一定格式输出到日志文件中。 12345678var app = connect(); // 记录访问日志connect.logger.format(&#x27;home&#x27;, &#x27;:remote-addr :response-time - [:date] &quot;:method :url HTTP/:http-version&quot; :status :res[content-length] &quot;:referrer&quot; &quot;:user-agent&quot; :res[content-length]&#x27;); app.use(connect.logger(&#123; format: &#x27;home&#x27;, stream: fs.createWriteStream(__dirname + &#x27;/logs/access.log&#x27;) &#125;)); 异常日志异常日志通常用来记录那些意外产生的异常错误。通过日志的记录，开发者可以根据异常信息去定位bug出现的具体位置，以快速修复问题。异常日志通常有完善的分级，Node中提供的console对象就简单地实现了这几种划分，具体如下所示: console.log：普通日志。 console.info：普通信息。 console.warn：警告信息。 console.error：错误信息。console模块在具体实现时，log与info方法都将信息输出给标准输出process.stdout，warn与error方法则将信息输出到标准错误process.stderr，而info和error分别是log和warn的别名。 console对象上具有一个Console属性，它是console对象的构造函数。借助这个构造函数，我们可以实现自己的日志对象 12345var info = fs.createWriteStream(logdir + &#x27;/info.log&#x27;, &#123;flags: &#x27;a&#x27;, mode: &#x27;0666&#x27;&#125;); var error = fs.createWriteStream(logdir + &#x27;/error.log&#x27;, &#123;flags: &#x27;a&#x27;, mode: &#x27;0666&#x27;&#125;); var logger = new console.Console(info, error); logger.log(&#x27;Hello world!&#x27;); logger.error(&#x27;segment fault&#x27;); 对于未捕获的异常，Node提供了机制以免进程直接退出，但是发生未捕获异常的进程也不能继续在线上进行服务了，因为可能有内存泄漏的风险产生 日志与数据库将日志分析和日志记录这两个步骤分离开来是较好的选择。日志记录可以在线写，日志分析则可以借助一些工具同步到数据库中，通过离线分析的方式反馈出来 分割日志日志的写入一般都是依托在可写流上的。对于Console对象，它的内部属性_stdout和_stderr就是指向我们传入的两个输入流对象的 监控报警监控监控的主要目的是为了将一些重要指标采样记录下来，一旦这些指标发生较大变化，可以配合报警系统将问题反馈到负责人那 日志监控业务逻辑型的监控主要体现在日志上,除了异常日志的监控外，对于访问日志的监控也能体现出实际的业务QPS值。观察QPS的表现能够检查业务在时间上的分布 响应时间响应时间也是一个需要监控的点。一旦系统的某个子系统出现异常或者性能瓶颈，将会导致系统的响应时间变长健康的系统响应时间应该是波动较小的、持续均衡的 进程监控监控进程一般是检查操作系统中运行的应用进程数，比如对于采用多进程架构的Web应用，就需要检查工作进程的数量，如果低于预估值，就应当发出报警声。 磁盘监控磁盘监控主要是监控磁盘的用量。给磁盘的使用量设置一个上限，一旦磁盘用量超过警戒值，服务器的管理者就应该整理日志或清理磁盘了 内存监控如果内存只升不降，那么铁定存在内存泄漏问题。健康的内存使用应当是有升有降，在访问量大的时候上升，在访问量回落的时候，占用量也随之回落如果进程中存在内存泄漏，又一时没有排查解决，有一种方案可以解决这种状况。这种方案应用于多进程架构的服务集群，让每个工作进程指定服务多少次请求，达到请求数之后进程就不再服务新的连接，主进程启动新的工作进程来服务客户，旧的进程等所有连接断开后就退出。这样即使存在内存泄漏的风险，也能有效地规避内存泄漏带来的影响 CPU占用监控服务器的CPU占用监控也是必不可少的项，CPU的使用分为用户态、内核态、IOWait等CPU的使用率中，用户态小于70%、内核态小于35%且整体小于70%时，处于健康状态 CPU load监控CPU load又称CPU平均负载，它用来描述操作系统当前的繁忙程度，可以简单地理解为CPU在单位时间内正在使用和等待使用CPU的平均任务数。它有3个指标，即1分钟的平均负载、5分钟的平均负载、15分钟的平均负载 I/O负载I/O负载指的主要是磁盘I/O。反应的是磁盘上的读写情况，对于Node编写的应用，主要是面向网络服务，是故不太可能出现I/O负载过高的情况，大多数的I/O压力来自于数据库 网络监控网络流量监控的两个主要指标是流入流量和流出流量 应用状态监控除了这些硬性需要检测的指标外，应用还应当提供一种机制来反馈其自身的状态信息，外部监控将会持续性地调用应用的反馈接口来检查它的健康状态 DNS监控DNS是网络应用的基础，在实际的对外服务产品中，多数都对域名有依赖。DNS故障导致产品出现大面积影响的事件并不少见。由于DNS服务通常是稳定的，容易让人忽略，但一旦出现故障，就可能是史无前例的故障。对于产品的稳定性，域名DNS状态也需要加入监控 报警的实现搭配监控系统的则是报警系统，空有监控而没有通知功能，故障也是无法及时反馈给开发者的。如今的报警已经能够多样化，- 邮件报警、IM报警适合在线工作状态 短信或电话报警适合非在线状态 邮件报警: 如果报警系统由Node编写，可以调用nodemailer模块来实现邮件的发送 12345678910111213141516171819202122232425var nodemailer = require(&quot;nodemailer&quot;); // 建立一个SMTP传输连接var smtpTransport = nodemailer.createTransport(&quot;SMTP&quot;, &#123; service: &quot;Gmail&quot;, auth: &#123; user: &quot;gmail.user@gmail.com&quot;, pass: &quot;userpass&quot; &#125; &#125;); // 邮件选项var mailOptions = &#123; from: &quot;Fred Foo ✔ &lt;foo@bar.com&gt;&quot;, // 发件人邮件地址 to: &quot;bar@bar.com, baz@bar.com&quot;, // 收件人邮件地址列表 subject: &quot;Hello ✔&quot;, // 标题 text: &quot;Hello world ✔&quot;, // 纯文本内容 html: &quot;&lt;b&gt;Hello world ✔&lt;/b&gt;&quot; // HTML内容&#125; // 发送邮件smtpTransport.sendMail(mailOptions, function (err, response) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&quot;Message sent: &quot; + response.message); &#125; &#125;); 短信或电话报警。一些短信服务平台提供短信接入服务，可以在监控系统中接入此类服务时，一旦线上出现到达阈值的异常时，就将信息发送给应用相关的责任人。 稳定性 多机器：多机器部署应用带来的好处是能利用更多的硬件资源，为更多的请求服务。同时能够在有故障时，继续服务用户请求，保证整体系统的高可用性。但是一旦出现分布式，就需要考虑负载均衡、状态共享和数据一致性等问题。 多机房：多机房部署是比多机器部署更高层次的部署，目的是为了解决地理位置给用户访问带来的延迟等问题。在容灾方面，机房与机房之间可以互为备份 容灾备份：在多机房和多机器的部署结构下，十分容易通过备份的方式进行容灾，任何一台机器或者一个机房停止了服务，都能有其余的服务器来接替新的任务"},{"title":"深入浅出nodejs阅读笔记(4)","date":"2022-12-25T11:56:24.000Z","updated":"2023-07-24T09:24:46.503Z","comments":true,"path":"nodejs/nodejs-note-4.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-4.html","excerpt":"","text":"构建Web应用cookie告知客户端的方式是通过响应报文实现的，响应的Cookie值在Set-Cookie字段中。它的格式与请求中的格式不太相同，规范中对它的定义如下所示：Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;其中name=value是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将Cookie发送给服务器端的行为。以下为主要的几个选项: path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie。 Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久后过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。 HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。 Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到 在YSlow的性能优化规则: 减小Cookie的大小 为静态组件使用不同的域名 减少DNS查询 SessionSession的数据只保留在服务器端，客户端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递 常见的两种实现方式: 基于Cookie来实现用户和数据的映射一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid，Tomcat会采用jsessionid等。一旦服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间123456789101112var sessions = &#123;&#125;; var key = &#x27;session_id&#x27;; var EXPIRES = 20 * 60 * 1000; var generate = function () &#123; var session = &#123;&#125;; session.id = (new Date()).getTime() + Math.random(); session.cookie = &#123; expire: (new Date()).getTime() + EXPIRES &#125;; sessions[session.id] = session; return session; &#125;; 通过查询字符串来实现浏览器端和服务器端数据的对应 采用高速缓存的理由有以下几条: Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。 高速缓存直接在内存中进行数据存储和访问。 缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。 缓存关于缓存的规则： 添加Expires 或Cache-Control 到报文头中。 配置 ETags。 让Ajax 可缓存 时间戳有一些缺陷存在: 文件的时间戳改动但内容并不一定改动。 时间戳只能精确到秒级别，更新频繁的内容将无法生效 ETag的全称是Entity Tag，由服务器端生成，服务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳改动造成的带宽浪费。ETag的请求和响应是If-None-Match/ETag 1234567891011121314var handle = function (req, res) &#123; fs.readFile(filename, function(err, file) &#123; var hash = getHash(file); var noneMatch = req.headers[&#x27;if-none-match&#x27;]; if (hash === noneMatch) &#123; res.writeHead(304, &quot;Not Modified&quot;); res.end(); &#125; else &#123; res.setHeader(&quot;ETag&quot;, hash); res.writeHead(200, &quot;Ok&quot;); res.end(file); &#125; &#125;); &#125;; HTTP1.0时，在服务器端设置Expires可以告知浏览器要缓存文件内容，如下代码所示: 123456789var handle = function (req, res) &#123; fs.readFile(filename, function(err, file) &#123; var expires = new Date(); expires.setTime(expires.getTime() + 10 * 365 * 24 * 60 * 60 * 1000); res.setHeader(&quot;Expires&quot;, expires.toUTCString()); res.writeHead(200, &quot;Ok&quot;); res.end(file); &#125;); &#125;; Expires是一个GMT格式的时间字符串。浏览器在接到这个过期值后，只要本地还存在这个缓存文件，在到期时间之前它都不会再发起请求 Expires的缺陷在于浏览器与服务器之间的时间可能不一致，这可能会带来一些问题，比如文件提前过期，或者到期后并没有被删除。在这种情况下，Cache-Control以更丰富的形式，实现相同的功能，如下所示： 1234567var handle = function (req, res) &#123; fs.readFile(filename, function(err, file) &#123; res.setHeader(&quot;Cache-Control&quot;, &quot;max-age=&quot; + 10 * 365 * 24 * 60 * 60 * 1000); res.writeHead(200, &quot;Ok&quot;); res.end(file); &#125;); &#125;; Cache-Control能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算过期时间即可。除此之外，Cache-Control的值还能设置public、private、no-cache、no-store等能够更精细地控制缓存的选项 由于在HTTP1.0时还不支持max-age，如今的服务器端在模块的支持下多半同时对Expires和Cache-Control进行支持。在浏览器中如果两个值同时存在，且被同时支持时，max-age会覆盖Expires。 一般的更新机制有如下两种: 每次发布，路径中跟随Web应用的版本号：http://url.com/?v=20130501。 每次发布，路径中跟随该文件内容的hash值：http://url.com/?hash=afadfadwe Basic认证一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的浏览器都支持它 数据上传如果请求中还带有内容部分（如POST请求，它具有报头和内容），内容部分需要用户自行接收和解析。通过报头的Transfer-Encoding或Content-Length即可判断请求中是否带有内容，如下所示： 123var hasBody = function(req) &#123; return &#x27;transfer-encoding&#x27; in req.headers || &#x27;content-length&#x27; in req.headers; &#125;; 在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可，如下所示： 1234567891011121314function (req, res) &#123; if (hasBody(req)) &#123; var buffers = []; req.on(&#x27;data&#x27;, function (chunk) &#123; buffers.push(chunk); &#125;); req.on(&#x27;end&#x27;, function () &#123; req.rawBody = Buffer.concat(buffers).toString(); handle(req, res); &#125;); &#125; else &#123; handle(req, res); &#125; &#125; 将接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在req.rawBody处 获取数据 1234567891011121314151617181920212223242526var handle = function (req, res) &#123; if (req.headers[&#x27;content-type&#x27;] === &#x27;application/x-www-form-urlencoded&#x27;) &#123; req.body = querystring.parse(req.rawBody); &#125; todo(req, res); &#125;; var mime = function (req) &#123; var str = req.headers[&#x27;content-type&#x27;] || &#x27;&#x27;; return str.split(&#x27;;&#x27;)[0]; &#125;;var handle = function (req, res) &#123; if (mime(req) === &#x27;application/json&#x27;) &#123; try &#123; req.body = JSON.parse(req.rawBody); &#125; catch (e) &#123; // 异常内容，响应Bad request res.writeHead(400); res.end(&#x27;Invalid JSON&#x27;); return; &#125; &#125; todo(req, res); &#125;; 解析XML文件稍微复杂一点，建议使用支持XML文件到JSON对象转换的库，这里以xml2js模块为例，如下所示： 123456789101112131415var xml2js = require(&#x27;xml2js&#x27;); var handle = function (req, res) &#123; if (mime(req) === &#x27;application/xml&#x27;) &#123; xml2js.parseString(req.rawBody, function (err, xml) &#123; if (err) &#123; // 异常内容，响应Bad request res.writeHead(400); res.end(&#x27;Invalid XML&#x27;); return; &#125; req.body = xml; todo(req, res); &#125;); &#125; &#125;; 附件上传 12345678910111213141516function (req, res) &#123; if (hasBody(req)) &#123; var done = function () &#123; handle(req, res); &#125;; if (mime(req) === &#x27;application/json&#x27;) &#123; parseJSON(req, done); &#125; else if (mime(req) === &#x27;application/xml&#x27;) &#123; parseXML(req, done); &#125; else if (mime(req) === &#x27;multipart/form-data&#x27;) &#123; parseMultipart(req, done); &#125; &#125; else &#123; handle(req, res); &#125; &#125; formidable基于流式处理解析报文，将接收到的文件写入到系统的临时文件夹中，并返回对应的路径，如下所示： 123456789101112131415var formidable = require(&#x27;formidable&#x27;); function (req, res) &#123; if (hasBody(req)) &#123; if (mime(req) === &#x27;multipart/form-data&#x27;) &#123; var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) &#123; req.body = fields; req.files = files; handle(req, res); &#125;); &#125; &#125; else &#123; handle(req, res); &#125; &#125; 数据上传与安全内存限制主要有两个方案。 限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。 通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据 1234567891011121314151617181920var bytes = 1024; function (req, res) &#123; var received = 0, var len = req.headers[&#x27;content-length&#x27;] ? parseInt(req.headers[&#x27;content-length&#x27;], 10) : null; // 如果内容超过长度限制，返回请求实体过长的状态码 if (len &amp;&amp; len &gt; bytes) &#123; res.writeHead(413); res.end(); return; &#125; // limit req.on(&#x27;data&#x27;, function (chunk) &#123; received += chunk.length; if (received &gt; bytes) &#123; // 停止接收数据，触发end() req.destroy(); &#125; &#125;); handle(req, res); &#125;; CSRFCSRF的全称是Cross-Site Request Forgery，中文意思为跨站请求伪造。 解决CSRF攻击的方案有添加随机值的方式，如下所示： 12345var generateRandom = function(len) &#123; return crypto.randomBytes(Math.ceil(len * 3 / 4)) .toString(&#x27;base64&#x27;) .slice(0, len); &#125;; 路由解析文件路径型 静态文件 动态文件 MVCMVC模型的主要思想是将业务逻辑按职责分离，主要分为以下几种。 控制器（Controller），一组行为的集合。 模型（Model），数据相关的操作和封装。 视图（View），视图的渲染。 这是目前最为经典的分层模式，大致而言，它的工作模式如下说明。 路由解析，根据URL寻找到对应的控制器和行为。 行为调用相关的模型，进行数据操作。 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。 如何根据URL做路由映射，这里有两个分支实现。一种方式是通过手工关联映射一种是自然关联映射前者会有一个对应的路由文件来将URL映射到对应的控制器，后者没有这样的文件 手工映射除了需要手工配置路由外较为原始外，它对URL的要求十分灵活，几乎没有格式上的限制。 正则匹配 参数解析 自然映射这种路由方式在PHP的MVC框架CodeIgniter中应用十分广泛，设计十分简洁，在Node中实现它也十分容易。与手工映射相比，如果URL变动，它的文件也需要发生变动，手工映射只需要改动路由映射即可。 RESTfulREST的全称是Representational State Transfer，中文含义为表现层状态转化。符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在URL上 RESTful与MVC设计并不冲突，而且是更好的改进。相比MVC，RESTful只是将HTTP请求方法也加入了路由的过程，以及在URL路径上体现得更资源化 中间件 异常处理 12345678910111213141516171819var handle = function (req, res, stack) &#123; var next = function (err) &#123; if (err) &#123; return handle500(err, req, res, stack); &#125; // 从stack数组中取出中间件并执行 var middleware = stack.shift(); if (middleware) &#123; // 传入next()函数自身，使中间件能够执行结束后递归 try &#123; middleware(req, res, next); &#125; catch (ex) &#123; next(err); &#125; &#125; &#125;; // 启动执行 next(); &#125;; 中间件与性能编写高效的中间件 使用高效的方法。必要时通过jsperf.com测试基准性能。 缓存需要重复计算的结果（需要控制缓存用量）。 避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要。 合理使用路由 页面渲染内容响应 MIME: 浏览器正是通过不同的Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值MIME的全称是Multipurpose Internet Mail Extensions，从名字可以看出，它最早用于电子邮件，后来也应用到浏览器中。不同的文件类型具有不同的MIME值，如JSON文件的值为application/json、XML文件的值为application/xml、PDF文件的值为application/pdf。为了方便获知文件的MIME值，社区有专有的mime模块可以用判段文件类型。它的调用十分简单，如下所示：12345var mime = require(&#x27;mime&#x27;); mime.lookup(&#x27;/path/to/file.txt&#x27;); // =&gt; &#x27;text/plain&#x27; mime.lookup(&#x27;file.txt&#x27;); // =&gt; &#x27;text/plain&#x27; mime.lookup(&#x27;.TXT&#x27;); // =&gt; &#x27;text/plain&#x27; mime.lookup(&#x27;htm&#x27;); // =&gt; &#x27;text/html&#x27; 除了MIME值外，Content-Type的值中还可以包含一些参数，如字符集。示例如下：Content-Type: text/javascript; charset=utf-8 附件下载Content-Disposition字段影响的行为是客户端会根据它的值判断是应该将报文数据当做即时浏览的内容，还是可下载的附件。当内容只需即时查看时，它的值为inline，当数据可以存为附件时，它的值为attachment。另外，Content-Disposition字段还能通过参数指定保存时应该使用的文件名 响应JSON 响应跳转 视图渲染集成文件系统 12345678910111213141516171819var cache = &#123;&#125;; var VIEW_FOLDER = &#x27;/path/to/wwwroot/views&#x27;; res.render = function (viewname, data) &#123; if (!cache[viewname]) &#123; var text; try &#123; text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), &#x27;utf8&#x27;); &#125; catch (e) &#123; res.writeHead(500, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); res.end(&#x27;模板文件错误&#x27;); return; &#125; cache[viewname] = complie(text); &#125; var complied = cache[viewname]; res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); var html = complied(data); res.end(html); &#125;; BigpipeBigpipe的解决思路则是将页面分割成多个部分（pagelet），先向用户输出没有数据的布局（框架），将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。 Bigpipe是一个需要前后端配合实现的优化技术，这个技术有几个重要的点。 页面布局框架（无数据的）。 后端持续性的数据输出。 前端渲染1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var cache = &#123;&#125;; var layout = &#x27;layout.html&#x27;; app.get(&#x27;/profile&#x27;, function (req, res) &#123; if (!cache[layout]) &#123; cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), &#x27;utf8&#x27;); &#125; res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); res.write(render(complie(cache[layout]))); // TODO &#125;); app.get(&#x27;/profile&#x27;, function (req, res) &#123; if (!cache[layout]) &#123; cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), &#x27;utf8&#x27;); &#125; res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); res.write(render(complie(cache[layout]))); ep.all(&#x27;users&#x27;, &#x27;articles&#x27;, function () &#123; res.end(); &#125;); ep.fail(function (err) &#123; res.end(); &#125;); db.getData(&#x27;sql1&#x27;, function (err, data) &#123; data = err ? &#123;&#125; : data; res.write(&#x27;&lt;script&gt;bigpipe.set(&quot;articles&quot;, &#x27; + JSON.stringify(data) + &#x27;);&lt;/script&gt;&#x27;; &#125;); db.getData(&#x27;sql2&#x27;, function (err, data) &#123; data = err ? &#123;&#125; : data; res.write(&#x27;&lt;script&gt;bigpipe.set(&quot;copyright&quot;, &#x27; + JSON.stringify(data) + &#x27;);&lt;/script&gt;&#x27;; &#125;); &#125;);var Bigpipe = function () &#123; this.callbacks = &#123;&#125;; &#125;; Bigpipe.prototype.ready = function (key, callback) &#123; if (!this.callbacks[key]) &#123; this.callbacks[key] = []; &#125; this.callbacks[key].push(callback); &#125;; Bigpipe.prototype.set = function (key, data) &#123; var callbacks = this.callbacks[key] || []; for (var i = 0; i &lt; callbacks.length; i++) &#123; callbacks[i].call(this, data); &#125; &#125;; Bigpipe将网页布局和数据渲染分离，使得用户在视觉上觉得网页提前渲染好了，其随着数据输出的过程逐步渲染页面，使得用户能够感知到页面是活的。这远比一开始给出空白页面，然后在某个时候突然渲染好带给用户的体验更好 玩转进程服务模型的变迁石器时代：同步最早的服务器，其执行模型是同步的，它的服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。它的处理能力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N 青铜时代：复制进程为了解决同步架构的并发问题，一个简单的改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据，启动是较为缓慢的。为了解决启动缓慢的问题，预复制（prefork）被引入服务模型中，即预先复制一定数量的进程。同时将进程复用，避免进程创建、销毁带来的开销。但是这个模型并不具备伸缩性，一旦并发请求过高，内存使用随着进程数的增长将会被耗尽假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类服务的QPS为M/N 白银时代：多线程为了解决进程复制中的浪费问题，多线程被引入服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线程池可以减少创建和销毁线程的开销。但是多线程所面临的并发问题只能说比多进程略好，因为每个线程都拥有自己独立的堆栈，这个堆栈都需要占用一定的内存空间。另外，由于一个CPU核心在一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时，时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的影响，它的QPS则为M * L/N。 黄金时代：事件驱动基于事件的服务模型存在的两个问题：CPU的利用率和进程的健壮性 多进程架构面对单进程单线程对多核使用不足的问题，前人的经验是启动多进程即可。理想状态下每个进程各自利用一个CPU，以此实现多核CPU的利用。所幸，Node提供了child_process模块，并且也提供了child_process.fork()函数供我们实现进程的复制。 123456789101112// worker.jsvar http = require(&#x27;http&#x27;); http.createServer(function (req, res) &#123; res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); res.end(&#x27;Hello World\\n&#x27;); &#125;).listen(Math.round((1 + Math.random()) * 1000), &#x27;127.0.0.1&#x27;); var fork = require(&#x27;child_process&#x27;).fork; var cpus = require(&#x27;os&#x27;).cpus(); for (var i = 0; i &lt; cpus.length; i++) &#123; fork(&#x27;./worker.js&#x27;); &#125; Master-Worker模式，又称主从模式。进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性值得开发者关注。 通过fork()复制的进程都是一个独立的进程，这个进程中有着独立而全新的V8实例。它需要至少30毫秒的启动时间和至少10 MB的内存。尽管Node提供了fork()供我们复制进程使每个CPU内核都使用上，但是依然要切记fork()进程是昂贵的 创建子进程child_process模块给予Node可以随意创建子进程（child_process）的能力。它提供了4个方法用于创建子进程。 spawn()：启动一个子进程来执行命令。 exec()：启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。 execFile()：启动一个子进程来执行可执行文件。 fork()：与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件 123456789var cp = require(&#x27;child_process&#x27;); cp.spawn(&#x27;node&#x27;, [&#x27;worker.js&#x27;]); cp.exec(&#x27;node worker.js&#x27;, function (err, stdout, stderr) &#123; // some code &#125;); cp.execFile(&#x27;worker.js&#x27;, function (err, stdout, stderr) &#123; // some code &#125;); cp.fork(&#x27;./worker.js&#x27;); 进程间通信通过fork()或者其他API，创建子进程之后，为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息 进程间通信原理IPC的全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道、匿名管道、socket、信号量、共享内存、消息队列、Domain Socket等。Node中实现IPC通道的是管道（pipe）技术父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接 句柄传递通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡，使得每个子进程可以较为均衡地执行任务。 child.send(message, [sendHandle])句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。比如句柄可以用来标识一个服务器端socket对象、一个客户端socket对象、一个UDP套接字、一个管道等 1234567891011121314151617var child = require(&#x27;child_process&#x27;).fork(&#x27;child.js&#x27;); // Open up the server object and send the handle var server = require(&#x27;net&#x27;).createServer(); server.on(&#x27;connection&#x27;, function (socket) &#123; socket.end(&#x27;handled by parent\\n&#x27;); &#125;); server.listen(1337, function () &#123; child.send(&#x27;server&#x27;, server); &#125;); process.on(&#x27;message&#x27;, function (m, server) &#123; if (m === &#x27;server&#x27;) &#123; server.on(&#x27;connection&#x27;, function (socket) &#123; socket.end(&#x27;handled by child\\n&#x27;); &#125;); &#125; &#125;); 主进程发送完句柄并关闭监听之后 句柄发送与还原目前子进程对象send()方法可以发送的句柄类型包括如下几种。 net.Socket。TCP套接字。 net.Server。TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的好处。 net.Native。C++层面的TCP套接字或IPC管道。 dgram.Socket。UDP套接字。 dgram.Native。C++层面的UDP套接字。send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个是message。message参数如下所示：{cmd: ‘NODE_HANDLE’,type: ‘net.Server’,msg: message} 连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。 Node进程之间只有消息传递，不会真正地传递对象，这种错觉是抽象封装的结果 端口共同监听多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。这些进程服务是抢占式的 集群稳定之路进程事件除了message事件外，Node还有如下这些事件。 error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。 exit：子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。 close：在子进程的标准输入输出流中止时触发该事件，参数与exit相同。 disconnect：在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。 在命令行中执行kill -l可以看到详细的信号列表 自动重启 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// master.js var fork = require(&#x27;child_process&#x27;).fork; var cpus = require(&#x27;os&#x27;).cpus(); var server = require(&#x27;net&#x27;).createServer(); server.listen(1337); var workers = &#123;&#125;; var createWorker = function () &#123; var worker = fork(__dirname + &#x27;/worker.js&#x27;); // 退出时重新启动新的进程 worker.on(&#x27;exit&#x27;, function () &#123; console.log(&#x27;Worker &#x27; + worker.pid + &#x27; exited.&#x27;); delete workers[worker.pid]; createWorker(); &#125;); // 句柄转发 worker.send(&#x27;server&#x27;, server); workers[worker.pid] = worker; console.log(&#x27;Create worker. pid: &#x27; + worker.pid); &#125;; for (var i = 0; i &lt; cpus.length; i++) &#123; createWorker(); &#125; // 进程自己退出时，让所有工作进程退出process.on(&#x27;exit&#x27;, function () &#123; for (var pid in workers) &#123; workers[pid].kill(); &#125; &#125;);// worker.js var http = require(&#x27;http&#x27;); var server = http.createServer(function (req, res) &#123; res.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;); res.end(&#x27;handled by child, pid is &#x27; + process.pid + &#x27;\\n&#x27;); &#125;); var worker; process.on(&#x27;message&#x27;, function (m, tcp) &#123; if (m === &#x27;server&#x27;) &#123; worker = tcp; worker.on(&#x27;connection&#x27;, function (socket) &#123; server.emit(&#x27;connection&#x27;, socket); &#125;); &#125; &#125;); process.on(&#x27;uncaughtException&#x27;, function () &#123; // 停止接收新的连接 worker.close(function () &#123; // 所有已有连接断开后，退出进程 process.exit(1); &#125;); &#125;); 限量重启 12345678910111213141516171819202122232425262728293031323334353637383940// 重启次数var limit = 10; // 时间单位var during = 60000; var restart = []; var isTooFrequently = function () &#123; // 记录重启时间 var time = Date.now(); var length = restart.push(time); if (length &gt; limit) &#123; // 取出最后10个记录 restart = restart.slice(limit * -1); &#125; // 最后一次重启到前10次重启之间的时间间隔 return restart.length &gt;= limit &amp;&amp; restart[restart.length - 1] - restart[0] &lt; during; &#125;; var workers = &#123;&#125;; var createWorker = function () &#123; // 检查是否太过频繁 if (isTooFrequently()) &#123; // 触发giveup事件后，不再重启 process.emit(&#x27;giveup&#x27;, length, during); return; &#125; var worker = fork(__dirname + &#x27;/worker.js&#x27;); worker.on(&#x27;exit&#x27;, function () &#123; console.log(&#x27;Worker &#x27; + worker.pid + &#x27; exited.&#x27;); delete workers[worker.pid]; &#125;); // 重新启动新的进程 worker.on(&#x27;message&#x27;, function (message) &#123; if (message.act === &#x27;suicide&#x27;) &#123; createWorker(); &#125; &#125;); // 句柄转发 worker.send(&#x27;server&#x27;, server); workers[worker.pid] = worker; console.log(&#x27;Create worker. pid: &#x27; + worker.pid); &#125;; 负载均衡在多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，这带来的好处是可以将CPU资源都调用起来,这种保证多个处理单元工作量公平的策略叫负载均衡 Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务 对于Node而言，需要分清的是它的繁忙是由CPU、I/O两个部分构成的，影响抢占的是CPU的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能够抢到较多请求，形成负载不均衡的情况 为 此 Node在 v0.11中提供了一种新的策略使得负载均衡更合理，这种新的策略叫Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) mod n个进程来发送连接 状态共享 第三方数据存储这种方式存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得到更新。实现状态同步的机制有两种，一种是各个子进程去向第三方进行定时轮询定时轮询带来的问题是轮询时间不能过密，如果子进程过多，会形成并发处理，如果数据没有发生改变，这些轮询会没有意义，白白增加查询状态的开销。如果轮询时间过长，数据发生改变时，不能及时更新到子进程中，会有一定的延迟 主动通知一种改进的方式是当数据发生更新时，主动通知子进程。当然，即使是主动通知，也需要一种机制来及时获取数据的改变。这个过程仍然不能脱离轮询，但我们可以减少轮询的进程数量，我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用TCP或UDP的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程 Cluster 模块1234567891011121314151617181920212223242526272829// cluster.js var cluster = require(&#x27;cluster&#x27;); cluster.setupMaster(&#123; exec: &quot;worker.js&quot; &#125;); var cpus = require(&#x27;os&#x27;).cpus(); for (var i = 0; i &lt; cpus.length; i++) &#123; cluster.fork(); &#125; var cluster = require(&#x27;cluster&#x27;); var http = require(&#x27;http&#x27;); var numCPUs = require(&#x27;os&#x27;).cpus().length; if (cluster.isMaster) &#123; // Fork workers for (var i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; cluster.on(&#x27;exit&#x27;, function(worker, code, signal) &#123; console.log(&#x27;worker &#x27; + worker.process.pid + &#x27; died&#x27;); &#125;); &#125; else &#123; // Workers can share any TCP connection // In this case its a HTTP server http.createServer(function(req, res) &#123; res.writeHead(200); res.end(&quot;hello world\\n&quot;); &#125;).listen(8000); &#125; 在进程中判断是主进程还是工作进程，主要取决于环境变量中是否有NODE_UNIQUE_ID 12cluster.isWorker = (&#x27;NODE_UNIQUE_ID&#x27; in process.env); cluster.isMaster = (cluster.isWorker === false); 官方示例中忽而判断cluster.isMaster、忽而判断cluster.isWorker，对于代码的可读性十分差。建议用cluster.setupMaster()这个API，将主进程和工作进程从代码上完全剥离 通过cluster.setupMaster()创建子进程而不是使用cluster.fork() Cluster 工作原理事实上cluster模块就是child_process和net模块的组合应用 Cluster 事件 fork：复制一个工作进程后触发该事件。 online：复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。 listening：工作进程中调用listen()（共享了服务器端Socket）后，发送一条listening消息给主进程，主进程收到消息后，触发该事件。 disconnect：主进程和工作进程之间IPC通道断开后会触发该事件。 exit：有工作进程退出时触发该事件。 setup：cluster.setupMaster()执行后触发该事件"},{"title":"nodejs基础知识(2)","date":"2022-10-19T11:12:12.000Z","updated":"2023-07-24T09:24:46.504Z","comments":true,"path":"nodejs/nodejs-note-6.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-6.html","excerpt":"","text":"nodejs文档知识点assert-断言作用：用于测试不变式 assert.deepEqual(a, b[, message])只测试可枚举的自身属性，原始值使用 == 进行比较，不测试对象原型、连接符、不可枚举属性等注意：子对象中可枚举的属性也会被测试 assert.deepStrictEqual(a, b[, message])与assert.deepEqual作用类似，使用全等 === 进行比较 assert.doesNotThrow(block[, error][, message])调用block函数，如果抛出错误且错误类型与error类型一致，则抛出AssertionError，否则抛出错误 assert.equal(actual, expected[, message])使用相等运算符 == 测试actual与expected是否相等 assert.fail(message)assert.fail(actual, expected[, message[, operator[, stackStartFunction]]])抛出AssertionError。如果 message 参数为空，则错误信息为 actual 参数 + operator 参数 + expected 参数。 如果只提供了 actual 参数与 expected 参数，则 operator 参数默认为 ‘!=’。 如果提供了 message 参数，则它会作为错误信息，其他参数会保存在错误对象的属性中。 如果提供了 stackStartFunction 参数，则该函数上的栈帧都会从栈信息中移除 assert.ifError(value)如果value为真，则抛出value，即value为错误信息 assert.notDeepEqual(actual, expected[, message])测试不深度相等，与assert.deepEqual()相反 assert.notDeepStrictEqual(actual, expected[, message])测试是否不深度全等，与assert.deepStrictEqual()相反 assert.notEqual(actual, expected[, message])使用 != 不等运算符测试参数是否不相等 assert.notStrictEqual(actual, expected[, message])使用不全等运算符（!==）测试参数是否不全等 assert.ok(value[, message])测试 value 是否为真值。 相当于 assert.equal(!!value, true, message) 异步钩子(Async Hooks)Error handling(错误处理)应用程序运行时带有–abort on uncaught可以实现退出后，打印堆栈跟踪，留下一个核心文件If any AsyncHook callbacks throw, the application will print the stack trace and exit. The exit path does follow that of an uncaught exception, but all ‘uncaughtException’ listeners are removed, thus forcing the process to exit. The ‘exit’ callbacks will still be called unless the application is run with –abort-on-uncaught-exception, in which case a stack trace will be printed and the application exits, leaving a core file. Printing in AsyncHook callbacks(异步钩子打印信息)在异步钩子函数中，打印信息查看数据不能使用 console.log等异步操作，会导致无限递归。推荐使用 fs.writeSync(1, msg). 1234567const fs = require(&#x27;fs&#x27;);const util = require(&#x27;util&#x27;);function debug(...args) &#123; // use a function like this one when debugging inside an AsyncHooks callback fs.writeSync(1, `$&#123;util.format(...args)&#125;\\n`);&#125; Because printing to the console is an asynchronous operation, console.log() will cause AsyncHook callbacks to be called. Using console.log() or similar asynchronous operations inside an AsyncHook callback function will cause an infinite recursion. An easy solution to this when debugging is to use a synchronous logging operation such as fs.writeFileSync(file, msg, flag). This will print to the file and will not invoke AsyncHook recursively because it is synchronous. asyncHook.enable()启用异步钩子 asyncHook.disable()禁用异步钩子 init(asyncId, type, triggerAsyncId, resource)asyncId: number类型，唯一标识符type: string类型，异步类型triggerAsyncId: number类型，在其执行上下文中创建此异步资源的异步资源的唯一IDresource: object类型，异步操作的资源的引用，需要在销毁期间释放应用场景：用于资源开启，被调用之前 123require(&#x27;net&#x27;).createServer().listen(function() &#123; this.close(); &#125;);// ORclearTimeout(setTimeout(() =&gt; &#123;&#125;, 10)); 注意：每个资源的ID在当前进程作用域中唯一 type命名一般符合资源结构，比如： 12345FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,SIGNALWRAP, STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, TIMERWRAP, TTYWRAP,UDPSENDWRAP, UDPWRAP, WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST,RANDOMBYTESREQUEST, TLSWRAP, Timeout, Immediate, TickObject, PROMISE 备注：type类型可能存在冲突，推荐给type添加前缀，比如 package name triggerAsyncId引起新资源初始化，调用init函数的资源的唯一标识符，triggerAsyncId展示资源为什么被创建 123456789async_hooks.createHook(&#123; init(asyncId, type, triggerAsyncId) &#123; const eid = async_hooks.executionAsyncId(); fs.writeSync( 1, `$&#123;type&#125;($&#123;asyncId&#125;): trigger: $&#123;triggerAsyncId&#125; execution: $&#123;eid&#125;\\n`); &#125;&#125;).enable();require(&#x27;net&#x27;).createServer((conn) =&gt; &#123;&#125;).listen(8080); resource实际初始化的异步资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let indent = 0;async_hooks.createHook(&#123; init(asyncId, type, triggerAsyncId) &#123; const eid = async_hooks.executionAsyncId(); const indentStr = &#x27; &#x27;.repeat(indent); fs.writeSync( 1, `$&#123;indentStr&#125;$&#123;type&#125;($&#123;asyncId&#125;):` + ` trigger: $&#123;triggerAsyncId&#125; execution: $&#123;eid&#125;\\n`); &#125;, before(asyncId) &#123; const indentStr = &#x27; &#x27;.repeat(indent); fs.writeSync(1, `$&#123;indentStr&#125;before: $&#123;asyncId&#125;\\n`); indent += 2; &#125;, after(asyncId) &#123; indent -= 2; const indentStr = &#x27; &#x27;.repeat(indent); fs.writeSync(1, `$&#123;indentStr&#125;after: $&#123;asyncId&#125;\\n`); &#125;, destroy(asyncId) &#123; const indentStr = &#x27; &#x27;.repeat(indent); fs.writeSync(1, `$&#123;indentStr&#125;destroy: $&#123;asyncId&#125;\\n`); &#125;,&#125;).enable();require(&#x27;net&#x27;).createServer(() =&gt; &#123;&#125;).listen(8080, () =&gt; &#123; // Let&#x27;s wait 10ms before logging the server started. setTimeout(() =&gt; &#123; console.log(&#x27;&gt;&gt;&gt;&#x27;, async_hooks.executionAsyncId()); &#125;, 10);&#125;);// 打印TCPSERVERWRAP(2): trigger: 1 execution: 1TickObject(3): trigger: 2 execution: 1before: 3 Timeout(4): trigger: 3 execution: 3 TIMERWRAP(5): trigger: 3 execution: 3after: 3destroy: 3before: 5 before: 4 TTYWRAP(6): trigger: 4 execution: 4 SIGNALWRAP(7): trigger: 4 execution: 4 TTYWRAP(8): trigger: 4 execution: 4&gt;&gt;&gt; 4 TickObject(9): trigger: 4 execution: 4 after: 4after: 5before: 9after: 9destroy: 4destroy: 9destroy: 5 before(asyncId)当异步操作启动（如 TCP 服务器接收新连接）或完成（如将数据写入磁盘）时，会调用回调通知用户。 before 回调在所述回调执行之前被调用。 asyncId 是分配给即将执行回调的资源的唯一标识符。 after(asyncId)在 before 中指定的回调完成后立即调用。注意：callback执行中产生异常，after在’uncaughtException’ 事件或域的处理程序运行后运行 destroy(asyncId)asyncId 对应的资源销毁后调用。 它也从嵌入器 API emitDestroy() 异步调用。注意：如果资源的回收依赖于垃圾回收机制，由于内存泄露，通过resource对象传给init的引用，destroy不会被调用。???如果不依赖垃圾回收机制，则没有上述问题。 promiseResolve(asyncId)当调用传给 Promise 构造函数的 resolve 函数时调用（直接或通过其他解决 promise 的方法）。注意：这并不一定意味着promise在此时被resolve或reject，promise可能是通过假设另一个Promise的状态来解决的 async_hooks.executionAsyncResource()executionAsyncResource() 返回的资源对象通常是带有未记录 API 的内部 Node.js 句柄对象。 在对象上使用任何函数或属性都可能使您的应用程序崩溃，应该避免。 async_hooks.executionAsyncId()当前执行上下文的asyncId，可用于跟踪某些函数被调用的情况 123456const async_hooks = require(&#x27;async_hooks&#x27;);console.log(async_hooks.executionAsyncId()); // 1 - bootstrapfs.open(path, &#x27;r&#x27;, (err, fd) =&gt; &#123; console.log(async_hooks.executionAsyncId()); // 6 - open()&#125;); executionAsyncId() 返回的 ID 与执行时机有关，与因果无关（被 triggerAsyncId() 涵盖） 1234567891011const server = net.createServer(function onConnection(conn) &#123; // Returns the ID of the server, not of the new connection, because the // onConnection callback runs in the execution scope of the server&#x27;s // MakeCallback(). async_hooks.executionAsyncId();&#125;).listen(port, function onListening() &#123; // Returns the ID of a TickObject (i.e. process.nextTick()) because all // callbacks passed to .listen() are wrapped in a nextTick(). async_hooks.executionAsyncId();&#125;); async_hooks.triggerAsyncId()返回正在执行资源的Id默认情况下，promise 上下文可能无法获得有效的 triggerAsyncId。 123456789101112const server = net.createServer((conn) =&gt; &#123; // The resource that caused (or triggered) this callback to be called // was that of the new connection. Thus the return value of triggerAsyncId() // is the asyncId of &quot;conn&quot;. async_hooks.triggerAsyncId();&#125;).listen(port, () =&gt; &#123; // Even though all callbacks passed to .listen() are wrapped in a nextTick() // the callback itself exists because the call to the server&#x27;s .listen() // was made. So the return value would be the ID of the server. async_hooks.triggerAsyncId();&#125;); async_hooks.asyncWrapProviders返回：提供程序类型到相应数字id的map映射。此映射包含可能由async_hooks.init发出的所有事件类型此特性禁止使用 process.binding(‘async_wrap’).Providers Promise 执行跟踪默认情况下，由于 V8 提供的 promise 自省 API 相对昂贵，因此不会为 promise 执行分配 asyncId。 这意味着默认情况下，使用 promise 或 async/await 的程序将无法正确执行并触发 promise 回调上下文的 id。 1234567import &#123; executionAsyncId, triggerAsyncId &#125; from &#x27;node:async_hooks&#x27;;Promise.resolve(1729).then(() =&gt; &#123; console.log(`eid $&#123;executionAsyncId()&#125; tid $&#123;triggerAsyncId()&#125;`);&#125;);// produces:// eid 1 tid 0 1234567import &#123; createHook, executionAsyncId, triggerAsyncId &#125; from &#x27;node:async_hooks&#x27;;createHook(&#123; init() &#123;&#125; &#125;).enable(); // forces PromiseHooks to be enabled.Promise.resolve(1729).then(() =&gt; &#123; console.log(`eid $&#123;executionAsyncId()&#125; tid $&#123;triggerAsyncId()&#125;`);&#125;);// produces:// eid 7 tid 6 AsyncResource类AsyncResource类被设计为由嵌入程序的异步资源扩展。使用它，用户可以轻松地触发自己资源的生命周期事件。 12345678910111213141516171819202122232425import &#123; AsyncResource, executionAsyncId &#125; from &#x27;node:async_hooks&#x27;;// AsyncResource() is meant to be extended. Instantiating a// new AsyncResource() also triggers init. If triggerAsyncId is omitted then// async_hook.executionAsyncId() is used.const asyncResource = new AsyncResource( type, &#123; triggerAsyncId: executionAsyncId(), requireManualDestroy: false &#125;);// Run a function in the execution context of the resource. This will// * establish the context of the resource// * trigger the AsyncHooks before callbacks// * call the provided function `fn` with the supplied arguments// * trigger the AsyncHooks after callbacks// * restore the original execution contextasyncResource.runInAsyncScope(fn, thisArg, ...args);// Call AsyncHooks destroy callbacks.asyncResource.emitDestroy();// Return the unique ID assigned to the AsyncResource instance.asyncResource.asyncId();// Return the trigger ID for the AsyncResource instance.asyncResource.triggerAsyncId(); AsyncLocalStorage 类参考https://www.jianshu.com/p/4a568dac41ed"},{"title":"nodejs基础知识(2)","date":"2022-10-19T11:12:12.000Z","updated":"2023-07-24T09:24:46.504Z","comments":true,"path":"nodejs/nodejs-note-7.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-7.html","excerpt":"","text":"Buffer(缓冲)ES6引入TypedArray???之前，JavaScript 语言没有读取或操作二进制数据流的机制。Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。 TypedArray 现已被添加进 ES6 中，Buffer 类以一种更优化、更适合 Node.js 用例的方式实现了 Uint8Array API。 Buffer 类的实例类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’).Buffer。 1234567891011121314151617181920// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from(&#x27;tést&#x27;);// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from(&#x27;tést&#x27;, &#x27;latin1&#x27;); Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()注意：nodejs v6之前，uffer 实例是通过 Buffer 构造函数创建的，它根据提供的参数返回不同的 Buffer nodejs 8.0.0之前分配给Buffer实例的内存是没有初始化的，且可能包含敏感数据；8.0.0之后，返回的是初始化内存之后的buffer 传递一个字符串、数组 或 Buffer 作为第一个参数，会将所传对象的数据拷贝到Buffer中 传入 ArrayBuffer 或 SharedArrayBuffer，则返回一个与传入的 ArrayBuffer 共享所分配内存的 Buffer 出于安全性和可靠性考虑，new Buffer()构造函数已被废弃，由Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()方法代替 Buffer.from(array) 返回一个新建的包含所提供的字节数组的副本的 Buffer。 [Buffer.from(arrayBuffer[, byteOffset [, length]])]Buffer.from(arrayBuffer) 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer) 返回一个新建的包含所提供的 Buffer 的内容的副本的 Buffer。 Buffer.from(string[, encoding]) 返回一个新建的包含所提供的字符串的副本的 Buffer。 [Buffer.alloc(size[, fill[, encoding]])]Buffer.alloc() 返回一个指定大小的被填满的 Buffer 实例。 这个方法会明显地比 Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝不会包含旧的和潜在的敏感数据。 Buffer.allocUnsafe(size) 与 Buffer.allocUnsafeSlow(size) 返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。 如果 size 小于或等于 Buffer.poolSize 的一半，则 Buffer.allocUnsafe() 返回的 Buffer 实例可能会被分配进一个共享的内部内存池。 –zero-fill-buffers命令行选项强制所有新分配的buffer实例在创建时自动用0填充注意：使用这个选项会改变新建buffer实例方法的默认行为，对性能有明显的影响。建议只在需要强制新分配的 Buffer 实例不能包含潜在的敏感数据时才使用 –zero-fill-buffers 选项。 buffer.allocUnsafe()和buffer.allocUnsafeSlow()不安全的原因buffer.allocUnsafe()和buffer.allocUnsafeSlow()创建的buffer实例，被分配的内存段是**未初始化的(未用0填充)**，这样的设计使得内存的分配很快，但分配的内存可能含有潜在的敏感旧数据，从而给程序引入安全漏洞 buffer与字符编码Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。 123456const buf = Buffer.from(&#x27;hello world&#x27;, &#x27;ascii&#x27;);console.log(buf.toString(&#x27;hex&#x27;));// 输出 68656c6c6f20776f726c64console.log(buf.toString(&#x27;base64&#x27;));// 输出 aGVsbG8gd29ybGQ= nodejs目前支持的字符编码 ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，编码非常快 utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF） ucs2 - ‘utf16le’ 的别名 base64 - Base64 编码。当从字符串创建 Buffer 时，按照 RFC4648 第 5 章的规定，这种编码也将正确地接受“URL 与文件名安全字母表” latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式（由 IANA 定义在 RFC1345 第 63 页，用作 Latin-1 补充块与 C0/C1 控制码） binary - ‘latin1’ 的别名 hex - 将每个字节编码为两个十六进制字符 注意：现代浏览器遵循 WHATWG 编码标准 将 ‘latin1’ 和 ISO-8859-1 别名为 win-1252。 这意味着当进行例如 http.get() 这样的操作时，如果返回的字符编码是 WHATWG 规范列表中的，则有可能服务器真的返回 win-1252 编码的数据，此时使用 ‘latin1’ 字符编码可能会错误地解码数据 Buffer 与 TypedArrayBuffer 实例也是 Uint8Array 实例从一个 Buffer 创建一个新的 TypedArray 实例需要遵循的注意事项： Buffer 对象的内存是拷贝到 TypedArray 的，而不是共享的。 Buffer 对象的内存是被解析为一个明确元素的数组，而不是一个目标类型的字节数组。 也就是说，new Uint32Array(Buffer.from([1, 2, 3, 4])) 会创建一个包含 [1, 2, 3, 4] 四个元素的 Uint32Array，而不是一个只包含一个元素 [0x1020304] 或 [0x4030201] 的 Uint32Array 123456789101112131415161718192021222324const arr = new Uint16Array(2);arr[0] = 5000;arr[1] = 4000;// 拷贝 `arr` 的内容const buf1 = Buffer.from(arr);// 与 `arr` 共享内存const buf2 = Buffer.from(arr.buffer);// 输出: &lt;Buffer 88 a0&gt;console.log(buf1);// 输出: &lt;Buffer 88 13 a0 0f&gt;console.log(buf2);arr[1] = 6000;// 输出: &lt;Buffer 88 a0&gt;console.log(buf1);// 输出: &lt;Buffer 88 13 70 17&gt;console.log(buf2); 注意，当使用 TypedArray 的 .buffer 创建 Buffer 时，也可以通过传入 byteOffset 和 length 参数只使用 ArrayBuffer 的一部分 12345const arr = new Uint16Array(20);const buf = Buffer.from(arr.buffer, 0, 16);// 输出: 16console.log(buf.length); Buffer 实例可以使用 ECMAScript 2015 (ES6) 的 for..of 语法进行遍历 123456789const buf = Buffer.from([1, 2, 3]);// 输出:// 1// 2// 3for (const b of buf) &#123; console.log(b);&#125; buf.values() 、buf.keys() 和 buf.entries() 方法可用于创建迭代器 Buffer类Buffer 类是一个全局变量类型，用来直接处理二进制数据的。 它能够使用多种方式构建。 类方法：Buffer.allocUnsafe(size)分配一个大小为 size 字节的新建的 Buffer 。 如果 size 大于 buffer.constants.MAX_LENGTH 或小于 0，则抛出 RangeError 错误。 如果 size 为 0，则创建一个长度为 0 的 Buffer。以这种方式创建的 Buffer 实例的底层内存是未初始化的。 新创建的 Buffer 的内容是未知的，且可能包含敏感数据。 可以使用 buf.fill(0) 初始化 Buffer 实例为0。 12345678const buf = Buffer.allocUnsafe(10);console.log(buf);// 输出: (内容可能不同): &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;buf.fill(0);// 输出: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;console.log(buf); 如果 size 不是一个数值，则抛出 TypeError 错误。 注意，Buffer 模块会预分配一个大小为 Buffer.poolSize 的内部 Buffer 实例作为快速分配池， 用于使用 Buffer.allocUnsafe() 新创建的 Buffer 实例，以及废弃的 new Buffer(size) 构造器， 仅限于当 size 小于或等于 Buffer.poolSize &gt;&gt; 1 （Buffer.poolSize 除以2后的最大整数值）。 对这个预分配的内部内存池的使用，是调用 Buffer.alloc(size, fill) 和 Buffer.allocUnsafe(size).fill(fill) 的关键区别。 具体地说，Buffer.alloc(size, fill) 永远不会使用这个内部的 Buffer 池，但如果 size 小于或等于 Buffer.poolSize 的一半， Buffer.allocUnsafe(size).fill(fill) 会使用这个内部的 Buffer 池。 当应用程序需要 Buffer.allocUnsafe() 提供额外的性能时，这个细微的区别是非常重要的。 类方法：Buffer.allocUnsafeSlow(size)当使用 Buffer.allocUnsafe() 分配新建的 Buffer 时，当分配的内存小于 4KB 时，默认会从一个单一的预分配的 Buffer 切割出来。 这使得应用程序可以避免垃圾回收机制因创建太多独立分配的 Buffer 实例而过度使用。 这个方法通过像大多数持久对象一样消除追踪与清理的需求，改善了性能与内存使用。 当然，在开发者可能需要在不确定的时间段从内存池保留一小块内存的情况下，使用 Buffer.allocUnsafeSlow() 创建一个非池的 Buffer 实例然后拷贝出相关的位元是合适的做法。 1234567891011121314// 需要保留一小块内存块const store = [];socket.on(&#x27;readable&#x27;, () =&gt; &#123; const data = socket.read(); // 为保留的数据分配内存 const sb = Buffer.allocUnsafeSlow(10); // 拷贝数据进新分配的内存 data.copy(sb, 0, 0, 10); store.push(sb);&#125;); Buffer.allocUnsafeSlow() 应当仅仅作为开发者已经在他们的应用程序中观察到过度的内存保留之后的终极手段使用。 类方法：Buffer.byteLength(string[, encoding])返回一个字符串的实际字节长度。 这与 String.prototype.length 不同，因为那返回字符串的字符数。 注意 对于 ‘base64’ 和 ‘hex’， 该函数假定有效的输入。 对于包含 non-Base64/Hex-encoded 数据的字符串 (e.g. 空格)， 返回值可能大于 从字符串中创建的 Buffer 的长度。 当 string 是一个 Buffer/DataView/TypedArray/ArrayBuffer/SharedArrayBuffer 时，返回实际的字节长度。 类方法：Buffer.compare(buf1, buf2)比较 buf1 和 buf2 ，通常用于 Buffer 实例数组的排序。 相当于调用 buf1.compare(buf2) 。 1234567const buf1 = Buffer.from(&#x27;1234&#x27;);const buf2 = Buffer.from(&#x27;0123&#x27;);const arr = [buf1, buf2];console.log(arr.sort(Buffer.compare));// 输出: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]// (结果相当于: [buf2, buf1]) 类方法：Buffer.concat(list[, totalLength])返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。 如果 list 中没有元素、或 totalLength 为 0 ，则返回一个新建的长度为 0 的 Buffer 。 如果没有提供 totalLength ，则从 list 中的 Buffer 实例计算得到。 为了计算 totalLength 会导致需要执行额外的循环，所以提供明确的长度会运行更快。如果提供了 totalLength，totalLength 必须是一个正整数。如果从 list 中计算得到的 Buffer 长度超过了 totalLength，则合并的结果将会被截断为 totalLength 的长度。 1234567891011121314const buf1 = Buffer.alloc(10);const buf2 = Buffer.alloc(14);const buf3 = Buffer.alloc(18);const totalLength = buf1.length + buf2.length + buf3.length;console.log(totalLength);// 输出: 42const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);console.log(bufA);// 输出: &lt;Buffer 00 00 00 00 ...&gt;console.log(bufA.length);// 输出: 42 类方法：Buffer.from(array)如果 array 不是一个数组，则抛出 TypeError 错误类方法：Buffer.from(arrayBuffer[, byteOffset[, length]])arrayBuffer | ArrayBuffer 或 SharedArrayBuffer 或 TypedArray 的 .buffer 属性。byteOffset 开始拷贝的索引。默认为 0。length 拷贝的字节数。默认为 arrayBuffer.length - byteOffset。 该方法将创建一个 ArrayBuffer 的视图，而不会复制底层内存。例如，当传入一个 TypedArray 实例的 .buffer 属性的引用时，这个新建的 Buffer 会像 TypedArray 那样共享同一分配的内存。 12345678910111213141516const arr = new Uint16Array(2);arr[0] = 5000;arr[1] = 4000;const buf = Buffer.from(arr.buffer);// 与 `arr` 共享内存console.log(buf);// 输出: &lt;Buffer 88 13 a0 0f&gt;arr[1] = 6000;// 改变原始的 Uint16Array 也会改变 Bufferconsole.log(buf);// 输出: &lt;Buffer 88 13 70 17&gt; 可选的 byteOffset 和 length 参数指定将与 Buffer 共享的 arrayBuffer 的内存范围 1234const ab = new ArrayBuffer(10);const buff = Buffer.from(ab, 0, 2);console.log(buff.length);// 输出: 2 如果 arrayBuffer 不是 ArrayBuffer 或 SharedArrayBuffer，则抛出 TypeError 错误 类方法：Buffer.from(buffer)将传入的 buffer 数据拷贝到一个新建的 Buffer 实例。 12345678const buf1 = Buffer.from(&#x27;buffer&#x27;);const buf2 = Buffer.from(buf1);buf1[0] = 0x61;console.log(buf1.toString());// 输出: aufferconsole.log(buf2.toString());// 输出: buffer 类方法：Buffer.from(string[, encoding])新建一个包含所给的 JavaScript 字符串 string 的 Buffer 。 encoding 参数指定 string 的字符编码。 123456789101112const buf1 = Buffer.from(&#x27;this is a tést&#x27;);console.log(buf1.toString());// 输出: this is a téstconsole.log(buf1.toString(&#x27;ascii&#x27;));// 输出: this is a tC)stconst buf2 = Buffer.from(&#x27;7468697320697320612074c3a97374&#x27;, &#x27;hex&#x27;);console.log(buf2.toString());// 输出: this is a tést Class Method: Buffer.from(object[, offsetOrEncoding[, length]])object 一个支持 Symbol.toPrimitive 或 valueOf() 的对象offsetOrEncoding | 字节偏移量或编码，取决于 object.valueOf() 或 objectSymbol.toPrimitive 的返回值。length 长度值，取决于 object.valueOf() 或 objectSymbol.toPrimitive 的返回值。那些其 valueOf() 方法返回值如果不严格等于 object 的对象，返回Buffer.from(object.valueOf(), offsetOrEncoding, length)。 12const buf = Buffer.from(new String(&#x27;this is a test&#x27;));// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt; 那些支持 Symbol.toPrimitive 的对象， 返回 Buffer.from(objectSymbol.toPrimitive, offsetOrEncoding, length)。 12345678class Foo &#123; [Symbol.toPrimitive]() &#123; return &#x27;this is a test&#x27;; &#125;&#125;const buf = Buffer.from(new Foo(), &#x27;utf8&#x27;);// &lt;Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74&gt; 类方法：Buffer.isBuffer(obj)如果 obj 是一个 Buffer 则返回 true ，否则返回 false类方法：Buffer.isEncoding(encoding)如果 encoding 是一个支持的字符编码则返回 true，否则返回 false 。类属性：Buffer.poolSize这是用于决定预分配的、内部 Buffer 实例池的大小的字节数。 这个值可以修改。默认值：8192 buf[index]索引操作符 [index] 可用于获取或设置 buf 中指定 index 位置的八位字节。 这个值指向的是单个字节，所以合法的值范围是的 0x00 至 0xFF（十六进制），或 0 至 255（十进制）。 该操作符继承自 Uint8Array，所以它对越界访问的处理与 UInt8Array 相同（也就是说，获取时返回 undefined，设置时什么也不做）。 123456789const str = &#x27;Node.js&#x27;;const buf = Buffer.allocUnsafe(str.length);for (let i = 0; i &lt; str.length; i++) &#123; buf[i] = str.charCodeAt(i);&#125;console.log(buf.toString(&#x27;ascii&#x27;));// 输出: Node.js buf.bufferbuffer 属性指向创建该 Buffer 的底层的 ArrayBuffer 对象。 12345const arrayBuffer = new ArrayBuffer(16);const buffer = Buffer.from(arrayBuffer);console.log(buffer.buffer === arrayBuffer);// 输出: true buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])target | 要比较的 Buffer 或 Uint8Array。targetStart target 中开始对比的偏移量。 默认: 0targetEnd target 中结束对比的偏移量（不包含）。 默认: target.lengthsourceStart buf 中开始对比的偏移量。 默认: 0sourceEnd buf 中结束对比的偏移量（不包含）。 默认: buf.length返回: 比较 buf 与 target，返回表明 buf 在排序上是否排在 target 之前、或之后、或相同。 对比是基于各自 Buffer 实际的字节序列。 如果 target 与 buf 相同，则返回 0 。如果 target 排在 buf 前面，则返回 1 。如果 target 排在 buf 后面，则返回 -1 。 12345678910111213141516171819202122const buf1 = Buffer.from(&#x27;ABC&#x27;);const buf2 = Buffer.from(&#x27;BCD&#x27;);const buf3 = Buffer.from(&#x27;ABCD&#x27;);console.log(buf1.compare(buf1));// 输出: 0console.log(buf1.compare(buf2));// 输出: -1console.log(buf1.compare(buf3));// 输出: -1console.log(buf2.compare(buf1));// 输出: 1console.log(buf2.compare(buf3));// 输出: 1console.log([buf1, buf2, buf3].sort(Buffer.compare));// 输出: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]// (结果相当于: [buf1, buf3, buf2]) 可选的 targetStart 、 targetEnd 、 sourceStart 与 sourceEnd 参数可用于分别在 target 与 buf 中限制对比在指定的范围内。 1234567891011const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);console.log(buf1.compare(buf2, 5, 9, 0, 4));// 输出: 0console.log(buf1.compare(buf2, 0, 6, 4));// 输出: -1console.log(buf1.compare(buf2, 5, 6, 5));// 输出: 1 如果 targetStart &lt; 0 、 sourceStart &lt; 0 、 targetEnd &gt; target.byteLength 或 sourceEnd &gt; source.byteLength，则抛出 RangeError 错误。 buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])target | 要拷贝进的 Buffer 或 Uint8Array。targetStart target 中开始拷贝进的偏移量。 默认: 0sourceStart buf 中开始拷贝的偏移量。 默认: 0sourceEnd buf 中结束拷贝的偏移量（不包含）。 默认: buf.length返回: 被拷贝的字节数。拷贝 buf 的一个区域的数据到 target 的一个区域，即便 target 的内存区域与 buf 的重叠。 12345678910111213141516171819202122232425const buf1 = Buffer.allocUnsafe(26);const buf2 = Buffer.allocUnsafe(26).fill(&#x27;!&#x27;);for (let i = 0; i &lt; 26; i++) &#123; // 97 是 &#x27;a&#x27; 的十进制 ASCII 值 buf1[i] = i + 97;&#125;buf1.copy(buf2, 8, 16, 20);console.log(buf2.toString(&#x27;ascii&#x27;, 0, 25));// 输出: !!!!!!!!qrst!!!!!!!!!!!!!// 创建一个 Buffer ，并拷贝同一 Buffer 中一个区域的数据到另一个重叠的区域。const buf = Buffer.allocUnsafe(26);for (let i = 0; i &lt; 26; i++) &#123; // 97 是 &#x27;a&#x27; 的十进制 ASCII 值 buf[i] = i + 97;&#125;buf.copy(buf, 0, 4, 10);console.log(buf.toString());// 输出: efghijghijklmnopqrstuvwxyz"},{"title":"nodejs基础知识(3)","date":"2022-12-28T09:12:45.000Z","updated":"2023-07-24T09:24:46.504Z","comments":true,"path":"nodejs/nodejs-note-9.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-9.html","excerpt":"","text":"Node.js 插件是用 C++ 编写的动态链接共享对象，可以使用 require() 函数加载到 Node.js 中，且像普通的 Node.js 模块一样被使用。 它们主要用于为运行在 Node.js 中的 JavaScript 与 C/C++ 库之间提供接口。 目前用于实现插件的方法相当复杂，涉及多个组件和 API 的知识： V8：Node.js 目前用于提供 JavaScript 实现的 C++ 库。 V8 提供了用于创建对象、调用函数等的机制。 V8 的 API 文档主要在 v8.h 头文件中（Node.js 源代码中的 deps/v8/include/v8.h），也可以在查看 V8 在线文档。 libuv：实现了 Node.js 的事件循环、工作线程、以及平台所有的的异步操作的 C 库。 它也是一个跨平台的抽象库，使所有主流操作系统中可以像 POSIX 一样访问常用的系统任务，比如与文件系统、socket、定时器、以及系统事件的交互。 libuv 还提供了一个类似 POSIX 多线程的线程抽象，可被用于强化更复杂的需要超越标准事件循环的异步插件。 建议插件开发者多思考如何通过在 libuv 的非阻塞系统操作、工作线程、或自定义的 libuv 线程中降低工作负载来避免在 I/O 或其他时间密集型任务中阻塞事件循环。 内置的 Node.js 库。Node.js 自身开放了一些插件可以使用的 C++ API。 其中最重要的是 node::ObjectWrap 类。 Node.js 包含一些其他的静态链接库，如 OpenSSL。 这些库位于 Node.js 源代码中的 deps/ 目录。 只有 V8 和 OpenSSL 符号是被 Node.js 开放的，并且通过插件被用于不同的场景。 创建 hello.cc 文件123456789101112131415161718192021222324// hello.cc#include &lt;node.h&gt;namespace demo &#123;using v8::FunctionCallbackInfo;using v8::Isolate;using v8::Local;using v8::Object;using v8::String;using v8::Value;void Method(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Isolate* isolate = args.GetIsolate(); args.GetReturnValue().Set(String::NewFromUtf8(isolate, &quot;world&quot;));&#125;void init(Local&lt;Object&gt; exports) &#123; NODE_SET_METHOD(exports, &quot;hello&quot;, Method);&#125;NODE_MODULE(NODE_GYP_MODULE_NAME, init)&#125; // namespace demo 注意，所有的 Node.js 插件必须导出一个如下模式的初始化函数：12void Initialize(Local&lt;Object&gt; exports);NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize) NODE_MODULE 后面没有分号，因为它不是一个函数（详见 node.h）。 module_name 必须匹配最终的二进制文件名（不包括 .node 后缀）。 在 hello.cc 示例中，初始化函数是 init，插件模块名是 addon。 构建 当源代码已被编写，它必须被编译成二进制 addon.node 文件。 要做到这点，需在项目的顶层创建一个名为 binding.gyp 的文件，它使用一个类似 JSON 的格式来描述模块的构建配置。 该文件会被 node-gyp（一个用于编译 Node.js 插件的工具）使用。 12345678&#123; &quot;targets&quot;: [ &#123; &quot;target_name&quot;: &quot;addon&quot;, &quot;sources&quot;: [ &quot;hello.cc&quot; ] &#125; ]&#125; 当使用 npm install 安装一个 Node.js 插件时，npm 会使用自身捆绑的 node-gyp 版本来执行同样的一套动作，为用户要求的平台生成一个插件编译后的版本。 当构建完成时，二进制插件就可以在 Node.js 中被使用，通过 require() 构建后的 addon.node 模块 12345// hello.jsconst addon = require(&#x27;./build/Release/addon&#x27;);console.log(addon.hello());// 打印: &#x27;world&#x27; 因为编译后的二进制插件的确切路径取决于它如何被编译（比如有时它可能在 ./build/Debug/ 中），所以插件可以使用 bindings 包加载编译后的模块。 注意，虽然 bindings 包在如何定位插件模块的实现上更复杂，但它本质上使用了一个 try-catch 模式 12345try &#123; return require(&#x27;./build/Release/addon.node&#x27;);&#125; catch (err) &#123; return require(&#x27;./build/Debug/addon.node&#x27;);&#125; 链接到 Node.js 自有的依赖Node.js 使用了一些静态链接库，所有的插件都需要链接到 V8，也可能链接到任何其他依赖。 通常情况下，只要简单地包含相应的 #include &lt;…&gt; 声明（如 #include &lt;v8.h&gt;），则 node-gyp 会自动定位到相应的头文件。 但是也有一些注意事项需要注意： 当 node-gyp 运行时，它会检测指定的 Node.js 发行版本，并下载完整的源代码包或只是头文件。 如果下载了完整的源代码，则插件对全套的 Node.js 依赖有完全的访问权限。 如果只下载了 Node.js 的文件头，则只有 Node.js 导出的符号可用。 node-gyp 可使用指向一个本地 Node.js 源代码镜像的 –nodedir 标志来运行。 如果使用该选项，则插件有全套依赖的访问权限。 使用 require() 加载插件编译后的二进制插件的文件扩展名是 .node（而不是 .dll 或 .so）。 require() 函数用于查找具有 .node 文件扩展名的文件，并初始化为动态链接库。 当调用 require() 时，.node 拓展名通常可被省略，Node.js 仍会找到并初始化该插件。 注意，Node.js 会优先尝试查找并加载同名的模块或 JavaScript 文件。 例如，如果与二进制的 addon.node 同一目录下有一个 addon.js 文件，则 require(‘addon’) 会优先加载 addon.js 文件。"},{"title":"nodejs问题整理","date":"2023-02-22T10:11:10.000Z","updated":"2023-07-24T09:24:46.504Z","comments":true,"path":"nodejs/nodejs-note-question.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-question.html","excerpt":"","text":"使用module.createRequire创建的require和直接使用require有什么区别？？？ 问题来源：nodejs module模块使用createRequire创建的require独立于直接使用的require，可以读取新文件，直接使用的require是从cache缓存中读取文件，不能及时读取到刚更新后的文件 Node.js 不能保证拷贝操作的原子性，是什么意思？ 问题来源：fs.copyFile原子性在这里的意思是指要么复制之前报错，要么全部复制，不会复制一半。nodejs会尝试保证拷贝操作的原子性，但是可能由于缺少权限等原因导致无法保证。比如：执行复制操作，打开文件出错，nodejs会尝试删除它，但是没有权限，删除失败。 beforeunload监听页面是否存在操作，存在操作时提示，需要鼠标点击页面事件才生效 一定要是手动操作、模拟执行的都不能使事件生效 Nagle 算法与ack机制 为什么有的方法在文档中废弃了还有人用？ 怎么区分是否是注释中的中文？ 获取中文所在的行，通过抽象语法树ast，有其他方法吗？readline ELU 类似于 CPU 使用率，不同之处在于它只测量事件循环统计信息而不是 CPU 使用率。 它表示事件循环在事件循环的事件提供者（例如 epoll_wait）之外花费的时间百分比。 不考虑其他 CPU 空闲时间。ELU和CPU使用率不是同一概念，ELU高可能CPU使用率低 performance高解析度毫秒时间戳是什么意思？更精确细分的时间 当执行观察时，应使用 performance.clearResourceTimings 手动从全局的性能时间轴中清除条目之前的标记可能影响观察，先清除一下？？ performanceEntry.duration值对所有性能条目类型都没有意义。 句柄是什么意思？通过向 ‘warning’ 事件添加句柄来监听句柄：事件处理？？ IPC 通道衍生 Node.js 进程nodejs中process.getegid 和process.getgid区别 滴答队列和微任务队列 事件句柄就是时间发生时进行的操作，在javascript中，onclick,onload等这些就是事件句柄 方法setPromat(promat) ，就是给每一行设置一个提示符，就好比window命令行的&gt; ，这里设置的是Test&gt;。prompt()是最重要的方法，因为它体现了readline的核心作用，以行为单位读取数据，prompt方法就是在等待用户输入数据。在‘line’事件中的r1.prompt()：监听了’line’ 事件，因为prompt方法调用一次就只会读取一次数据，所以，在这个方法又调用了一次prompt方法，这样就可以继续读取用户输入，从而达到一种命令行的效果。 什么是分布式？拒绝服务攻击（DoS） Node.js 和底层 V8 引擎使用 Unicode 国际组件（ICU）"},{"title":"nodejs基础知识(3)","date":"2022-12-28T04:18:33.000Z","updated":"2023-07-24T09:24:46.504Z","comments":true,"path":"nodejs/nodejs-note-8.html","permalink":"https://sunjinkang.github.io/nodejs/nodejs-note-8.html","excerpt":"","text":"Buffer(缓冲)buf.entries()从 buf 的内容中，创建并返回一个 [index, byte] 形式的迭代器 123456789101112131415const buf = Buffer.from(&#x27;buffer&#x27;);for (const pair of buf.entries()) &#123; console.log(pair);&#125;// 输出:// [ 0, 0 ]// [ 1, 0 ]// [ 2, 0 ]// [ 3, 0 ]// [ 4, 0 ]// [ 5, 0 ]// [ 6, 0 ]// [ 7, 0 ]// [ 8, 0 ]// [ 9, 0 ] buf.equals(otherBuffer)如果 buf 与 otherBuffer 具有完全相同的字节，则返回 true，否则返回 false。 123456789const buf1 = Buffer.from(&#x27;ABC&#x27;);const buf2 = Buffer.from(&#x27;414243&#x27;, &#x27;hex&#x27;);const buf3 = Buffer.from(&#x27;ABCD&#x27;);console.log(buf1.equals(buf2));// 输出: trueconsole.log(buf1.equals(buf3));// 输出: false buf.fill(value[, offset[, end]][, encoding])value | | 用来填充 buf 的值。offset 开始填充 buf 前要跳过的字节数。默认: 0。end 结束填充 buf 的位置（不包含）。默认: buf.length。encoding 如果 value 是一个字符串，则这是它的字符编码。默认: ‘utf8’。返回: buf 的引用。如果未指定 offset 和 end，则填充整个 buf。 这个简化使得一个 Buffer 的创建与填充可以在一行内完成。 123const b = Buffer.allocUnsafe(50).fill(&#x27;h&#x27;);console.log(b.toString());// 输出: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh value 如果不是一个字符串或整数，则会被强行转换为 uint32 值。如果 fill() 操作的最后一次写入的是一个多字节字符，则只有字符中适合 buf 的第一个字节会被写入。 12345678910console.log(Buffer.allocUnsafe(3).fill(&#x27;\\u0222&#x27;));// 输出: &lt;Buffer c8 a2 c8&gt;const buf = Buffer.allocUnsafe(5);console.log(buf.fill(&#x27;a&#x27;));// Prints: &lt;Buffer 61 61 61 61 61&gt;console.log(buf.fill(&#x27;aazz&#x27;, &#x27;hex&#x27;));// Prints: &lt;Buffer aa aa aa aa aa&gt;console.log(buf.fill(&#x27;zz&#x27;, &#x27;hex&#x27;));// Prints: &lt;Buffer aa aa aa aa aa&gt; buf.includes(value[, byteOffset][, encoding])value | | 要搜索的值byteOffset buf 中开始搜索的位置。默认: 0encoding 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’返回: 如果 buf 找到 value，则返回 true，否则返回 false相当于 buf.indexOf() !== -1。 buf.indexOf(value[, byteOffset][, encoding])value | | | 要搜索的值byteOffset buf 中开始搜索的位置。默认: 0encoding 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’返回: buf 中 value 首次出现的索引，如果 buf 没包含 value 则返回 -1如果 value 是： 字符串，则 value 根据 encoding 的字符编码进行解析。 Buffer 或 Uint8Array，则 value 会被作为一个整体使用。如果要比较部分 Buffer，可使用 buf.slice()。 数值, 则 value 会解析为一个 0 至 255 之间的无符号八位整数值。 如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。 如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN 或者 0, 像 {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#indexOf() 保持一致。 如果 value 是一个空字符串或空 Buffer，并且 byteOffset 小于 buf.length，返回 byteOffset。如果 value 是一个空字符串，并且 byteOffset 大于 buf.length，返回 buf.length。 12345678910111213const b = Buffer.from(&#x27;abcdef&#x27;);console.log(b.indexOf(99.9));console.log(b.indexOf(256 + 99));// 传入一个不是有效字节的数字// 输出：2，相当于搜索 99 或 &#x27;c&#x27;console.log(b.indexOf(&#x27;b&#x27;, undefined));console.log(b.indexOf(&#x27;b&#x27;, &#123;&#125;));console.log(b.indexOf(&#x27;b&#x27;, null));console.log(b.indexOf(&#x27;b&#x27;, []));// 传入 byteOffset，其值强制转换为 NaN 或 0// 输出：1，搜索整个 buffer buf.keys()创建并返回一个包含 buf 键名（索引）的迭代器。 buf.lastIndexOf(value[, byteOffset][, encoding])value | | | 要搜索的值byteOffset buf 中开始搜索的位置。 默认: buf.length- 1encoding 如果 value 是一个字符串，则这是它的字符编码。 默认: ‘utf8’返回: buf 中 value 最后一次出现的索引，如果 buf 没包含 value 则返回 -1与 buf.indexOf() 类似，除了 buf 是从后往前搜索而不是从前往后。 如果 value 不是一个字符串， 数字， 或者 Buffer， 该方法会抛出一个 TypeError 异常， 如果 value 是一个数字， 它将会被强制转换成一个有效的 byte 值， 该值介于0到255之间。 如果 byteOffset 不是一个数字， 它将会被强制转换成一个数字。 任何对 NaN or 0, like {}, [], null or undefined， 的参数， 将会搜索整个 buffer。 该行为和 String#lastIndexOf() 保持一致。 如果 value 是一个空字符串或者空 Buffer，返回 byteOffset。 12345678910111213141516const b = Buffer.from(&#x27;abcdef&#x27;);console.log(b.lastIndexOf(99.9));console.log(b.lastIndexOf(256 + 99));// 传入一个不是有效字节的数字// 输出：2，相当于搜索 99 或 &#x27;c&#x27;console.log(b.lastIndexOf(&#x27;b&#x27;, undefined));console.log(b.lastIndexOf(&#x27;b&#x27;, &#123;&#125;));// 传入 byteOffset，其值强制转换为 NaN// 输出：-1，搜索整个 bufferconsole.log(b.lastIndexOf(&#x27;b&#x27;, null));console.log(b.lastIndexOf(&#x27;b&#x27;, []));// 传入 byteOffset，其值强制转换为 0// 输出：-1，相当于传入 0 buf.length返回 buf 在字节数上分配的内存量。 注意，这并不一定反映 buf 内可用的数据量。 123456789const buf = Buffer.alloc(1234);// 输出: 1234console.log(buf.length);buf.write(&#x27;some string&#x27;, 0, &#x27;ascii&#x27;);// 输出: 1234console.log(buf.length); 虽然 length 属性不是不可变的，但改变 length 的值可能会导致不确定、不一致的行为。 那些希望修改一个 Buffer 的长度的应用程序应当将 length 视为只读的，且使用 buf.slice() 创建一个新的 Buffer 1234567891011let buf = Buffer.allocUnsafe(10);buf.write(&#x27;abcdefghj&#x27;, 0, &#x27;ascii&#x27;);console.log(buf.length);// 输出: 10buf = buf.slice(0, 5);console.log(buf.length);// 输出: 5 buf.readDoubleBE(offset[, noAssert])、buf.readDoubleLE(offset[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 8。noAssert 是否跳过 offset 检验？默认: false。返回: 用指定的字节序格式（readDoubleBE() 返回大端序，readDoubleLE() 返回小端序）从 buf 中指定的 offset 读取一个64位双精度值。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 1234567891011121314const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);console.log(buf.readDoubleBE());// 输出: 8.20788039913184e-304console.log(buf.readDoubleLE());// 输出: 5.447603722011605e-270console.log(buf.readDoubleLE(1));// 抛出异常: RangeError: Index out of rangeconsole.log(buf.readDoubleLE(1, true));// 警告: 读取超出 buffer 的最后一位字节！// 这会导致内存区段错误！不要这么做！ buf.readFloatBE(offset[, noAssert])、buf.readFloatLE(offset[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。noAssert 是否跳过 offset 检验？默认: false。返回: 用指定的字节序格式（readFloatBE() 返回大端序，readFloatLE() 返回小端序）从 buf 中指定的 offset 读取一个32位浮点值。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 1234567891011121314const buf = Buffer.from([1, 2, 3, 4]);console.log(buf.readFloatBE());// 输出: 2.387939260590663e-38console.log(buf.readFloatLE());// 输出: 1.539989614439558e-36console.log(buf.readFloatLE(1));// 抛出异常: RangeError: Index out of rangeconsole.log(buf.readFloatLE(1, true));// 警告: 读取超出 buffer 的最后一位字节！// 这会导致内存区段错误！不要这么做！ buf.readInt8(offset[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 1。noAssert 是否跳过 offset 检验？默认: false。返回: 从 buf 中指定的 offset 读取一个有符号的8位整数值。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 从 Buffer 中读取的整数值会被解析为二进制补码值。 buf.readInt16BE(offset[, noAssert])、buf.readInt16LE(offset[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 2。noAssert 是否跳过 offset 检验？默认: false。返回: 用指定的字节序格式（readInt16BE() 返回大端序，readInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的16位整数值。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 从 Buffer 中读取的整数值会被解析为二进制补码值。 buf.readInt32BE(offset[, noAssert])、buf.readInt32LE(offset[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。noAssert 是否跳过 offset 检验？默认: false。返回: 用指定的字节序格式（readInt32BE() 返回大端序，readInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个有符号的32位整数值。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 从 Buffer 中读取的整数值会被解析为二进制补码值。 buf.readIntBE(offset, byteLength[, noAssert])、buf.readIntLE(offset, byteLength[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - byteLength。byteLength 要读取的字节数。必须满足：0 &lt; byteLength &lt;= 6。noAssert 是否跳过 offset 和 byteLength 校验？ 默认: false。返回: 从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为二进制补码值。 最高支持48位精度。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 buf.readUInt8(offset[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 1。noAssert 是否跳过 offset 检验？默认: false。返回: 从 buf 中指定的 offset 读取一个无符号的8位整数值。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 buf.readUInt16BE(offset[, noAssert])、buf.readUInt16LE(offset[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 2。noAssert 是否跳过 offset 检验？默认: false。返回: 用指定的字节序格式（readUInt16BE() 返回大端序，readUInt16LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的16位整数值。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 buf.readUInt32BE(offset[, noAssert])、buf.readUInt32LE(offset[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - 4。noAssert 是否跳过 offset 检验？默认: false。返回: 用指定的字节序格式（readUInt32BE() 返回大端序，readUInt32LE() 返回小端序）从 buf 中指定的 offset 读取一个无符号的32位整数值。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 buf.readUIntBE(offset, byteLength[, noAssert])、buf.readUIntLE(offset, byteLength[, noAssert])offset 开始读取前要跳过的字节数，必须满足：0 &lt;= offset &lt;= buf.length - byteLength。byteLength 要读取的字节数。必须满足：0 &lt; byteLength &lt;= 6。noAssert 是否跳过 offset 和 byteLength 校验？ 默认: false。返回: 从 buf 中指定的 offset 读取 byteLength 个字节，且读取的值会被解析为无符号的整数。 最高支持48位精度。 设置 noAssert 为 true 则 offset 可超出 buf 的最后一位字节，但后果是不确定的。 buf.slice([start[, end]])start 新建的 Buffer 开始的位置。 默认: 0end 新建的 Buffer 结束的位置（不包含）。 默认: buf.length返回: 返回一个指向相同原始内存的新建的 Buffer，但做了偏移且通过 start 和 end 索引进行裁剪。 指定大于buf.length的结束值，与结束值设置为buf.length的结果一样。 注意，修改这个新建的 Buffer 切片，也会同时修改原始的 Buffer 的内存，因为这两个对象所分配的内存是重叠的。 指定负的索引会导致切片的生成是相对于 buf 的末尾而不是开头 12345678910111213141516171819202122232425262728293031const buf1 = Buffer.allocUnsafe(26);for (let i = 0; i &lt; 26; i++) &#123; // 97 是 &#x27;a&#x27; 的十进制 ASCII 值 buf1[i] = i + 97;&#125;const buf2 = buf1.slice(0, 3);console.log(buf2.toString(&#x27;ascii&#x27;, 0, buf2.length));// 输出: abcbuf1[0] = 33;console.log(buf2.toString(&#x27;ascii&#x27;, 0, buf2.length));// 输出: !bcconst buf = Buffer.from(&#x27;buffer&#x27;);console.log(buf.slice(-6, -1).toString());// 输出: buffe// (相当于 buf.slice(0, 5))console.log(buf.slice(-6, -2).toString());// 输出: buff// (相当于 buf.slice(0, 4))console.log(buf.slice(-5, -2).toString());// 输出: uff// (相当于 buf.slice(1, 4)) buf.swap16()将 buf 解析为一个无符号16位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是2的倍数，则抛出 RangeError 错误。 123456789101112131415const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;console.log(buf1);buf1.swap16();// 输出: &lt;Buffer 02 01 04 03 06 05 08 07&gt;console.log(buf1);const buf2 = Buffer.from([0x1, 0x2, 0x3]);// 抛出异常: RangeError: Buffer size must be a multiple of 16-bitsbuf2.swap16(); buf.swap32()将 buf 解析为一个无符号32位的整数数组，并且以字节顺序原地进行交换。 如果 buf.length 不是4的倍数，则抛出 RangeError 错误。 123456789101112131415const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);// 输出: &lt;Buffer 01 02 03 04 05 06 07 08&gt;console.log(buf1);buf1.swap32();// 输出: &lt;Buffer 04 03 02 01 08 07 06 05&gt;console.log(buf1);const buf2 = Buffer.from([0x1, 0x2, 0x3]);// 抛出异常: RangeError: Buffer size must be a multiple of 32-bitsbuf2.swap32(); buf.swap64()将 buf 解析为一个64位的数值数组，并且以字节顺序原地进行交换。 如果 buf.length 不是8的倍数，则抛出 RangeError 错误。注意，JavaScript 不能编码64位整数。 该方法是用来处理64位浮点数的。 buf.toJSON()返回 buf 的 JSON 格式。 当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该函数。 1234567891011121314const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);const json = JSON.stringify(buf);// 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;console.log(json);const copy = JSON.parse(json, (key, value) =&gt; &#123; return value &amp;&amp; value.type === &#x27;Buffer&#x27; ? Buffer.from(value.data) : value;&#125;);// 输出: &lt;Buffer 01 02 03 04 05&gt;console.log(copy); buf.toString([encoding[, start[, end]]])encoding 解码使用的字符编码。默认: ‘utf8’start 开始解码的字节偏移量。默认: 0end 结束解码的字节偏移量（不包含）。 默认: buf.length返回: 根据 encoding 指定的字符编码解码 buf 成一个字符串。 start 和 end 可传入用于只解码 buf 的一部分。 字符串实例的最大长度（以UTF-16代码为单位）可查看buffer.constants.MAX_STRING_LENGTH。 buf.values()创建并返回一个包含 buf 的值（字节）的迭代器。 当 Buffer 使用 for..of 时会自动调用该函数。 buf.write(string[, offset[, length]][, encoding])string 要写入 buf 的字符串。offset 开始写入 string 前要跳过的字节数。默认: 0。length 要写入的字节数。默认: buf.length - offset。encoding string 的字符编码。默认: ‘utf8’。返回: 写入的字节数。根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。 buf.writeDoubleBE(value, offset[, noAssert])、buf.writeDoubleLE(value, offset[, noAssert])用指定的字节序格式（writeDoubleBE() 写入大端序，writeDoubleLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的64位双精度值。 当 value 不是一个64位双精度值时，反应是不确定的。 buf.writeFloatBE(value, offset[, noAssert])、buf.writeFloatLE(value, offset[, noAssert])用指定的字节序格式（writeFloatBE() 写入大端序，writeFloatLE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的32位浮点值。 当 value 不是一个32位浮点值时，反应是不确定的 buf.writeInt8(value, offset[, noAssert])写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的8位整数。 当 value 不是一个有符号的8位整数时，反应是不确定的。 buf.writeInt16BE(value, offset[, noAssert])、buf.writeInt16LE(value, offset[, noAssert])用指定的字节序格式（writeInt16BE() 写入大端序，writeInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的16位整数。 当 value 不是一个有符号的16位整数时，反应是不确定的。 buf.writeInt32BE(value, offset[, noAssert])、buf.writeInt32LE(value, offset[, noAssert])用指定的字节序格式（writeInt32BE() 写入大端序，writeInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的有符号的32位整数。 当 value 不是一个有符号的32位整数时，反应是不确定的。 buf.writeIntBE(value, offset, byteLength[, noAssert])、buf.writeIntLE(value, offset, byteLength[, noAssert])写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个有符号的整数时，反应是不确定的。 buf.writeUInt8(value, offset[, noAssert])写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的8位整数。 当 value 不是一个无符号的8位整数时，反应是不确定的。 buf.writeUInt16BE(value, offset[, noAssert])、buf.writeUInt16LE(value, offset[, noAssert])用指定的字节序格式（writeUInt16BE() 写入大端序，writeUInt16LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的16位整数。 当 value 不是一个无符号的16位整数时，反应是不确定的。 buf.writeUInt32BE(value, offset[, noAssert])、buf.writeUInt32LE(value, offset[, noAssert])用指定的字节序格式（writeUInt32BE() 写入大端序，writeUInt32LE() 写入小端序）写入 value 到 buf 中指定的 offset 位置。 value 应当是一个有效的无符号的32位整数。 当 value 不是一个无符号的32位整数时，反应是不确定的。 buf.writeUIntBE(value, offset, byteLength[, noAssert])、buf.writeUIntLE(value, offset, byteLength[, noAssert])写入 value 中的 byteLength 个字节到 buf 中指定的 offset 位置。 最高支持48位精度。 当 value 不是一个无符号的整数时，反应是不确定的。 buffer.INSPECT_MAX_BYTES当调用 buf.inspect() 时返回的最大字节数。 可以被用户模块重写。 详见 util.inspect() 了解更多 buf.inspect() 的行为。 注意，这个属性是在通过 require(‘buffer’) 返回的 buffer 模块上，而不是在 Buffer 的全局变量或 Buffer 实例上。默认值：50 buffer.kMaxLength分配给单个 Buffer 实例的最大内存注意整个属性是通过 require(‘buffer’) 返回的 buffer 模块的属性，而不是全局 Buffer 对象或 Buffer 实例的属性。 buffer.transcode(source, fromEnc, toEnc)source | 一个 Buffer 或 Uint8Array 实例fromEnc 当前编码toEnc 目标编码将给定的 Buffer 或 Uint8Array 实例从一个字符编码重新编码到另一个字符。 返回一个新的Buffer实例。如果 fromEnc 或 toEnc 指定的字符串编码无效，或者不允许从 fromEnc 转换为 toEnc，将抛出异常。如果给定的字节序列不能在目标编码中充分表示，转码过程将使用替代字符。 12345const buffer = require(&#x27;buffer&#x27;);const newBuf = buffer.transcode(Buffer.from(&#x27;€&#x27;), &#x27;utf8&#x27;, &#x27;ascii&#x27;);console.log(newBuf.toString(&#x27;ascii&#x27;));// 输出: &#x27;?&#x27; 因为欧元符号（€）不能在 US-ASCII 中表示，所以在转换 Buffer 的时候使用 ? 代替。 Buffer Constants请注意buffer.constants是通过require(‘buffer’)返回的buffer模块的一个属性，而不是全局Buffer或Buffer实例 buffer.constants.MAX_LENGTH 单个Buffer实例允许的最大量度。在32位体系结构上，这个值是(2^30)-1 (1GB)。 在64位体系结构上，这个值是(2^31)-1 (2GB)。也可在buffer.kMaxLength查看该值。 buffer.constants.MAX_STRING_LENGTH 单个string实例允许的最大长度。代表string能有的原始最大长度，以UTF-16代码为单位。该值可能取决于正在使用的JS引擎。"},{"title":"commonweal","date":"2022-08-09T05:51:41.000Z","updated":"2023-07-24T09:24:46.478Z","comments":true,"path":"commonweal/index.html","permalink":"https://sunjinkang.github.io/commonweal/index.html","excerpt":"","text":"找不到对应页面，请确认是否存在页面！！！"},{"title":"unity","date":"2023-12-21T08:56:23.000Z","updated":"2024-02-27T03:22:02.698Z","comments":true,"path":"unity/index.html","permalink":"https://sunjinkang.github.io/unity/index.html","excerpt":"","text":"Unity unity手册笔记（1） unity手册笔记（2） unity手册笔记（3） unity手册笔记（4） unity手册笔记（5） unity手册笔记（6）"},{"title":"unity手册笔记（1）","date":"2023-12-21T08:58:12.000Z","updated":"2024-02-27T03:22:02.698Z","comments":true,"path":"unity/unity-note-1.html","permalink":"https://sunjinkang.github.io/unity/unity-note-1.html","excerpt":"","text":"安装Unity Editor 使用Hub安装教程：https://docs.unity.cn/hub/manual/InstallHub.html 使用命令行安装教程：https://docs.unity.cn/cn/current/Manual/InstallingUnity.html 离线安装教程：https://docs.unity.cn/cn/current/Manual/DeployingUnityOffline.html Unity界面 场景拾取控件要切换场景可拾取性，请执行以下操作： 单击 Hierarchy 窗口中游戏对象的可拾取性图标，在启用和禁用游戏对象及其子项的拾取之间进行切换。注意：切换游戏对象及其子项的可拾取性会影响所有子游戏对象（从“目标”游戏对象一直到层级视图的底部）。 按住 Alt 并单击 Hierarchy 窗口中游戏对象的可拾取性图标，在仅启用和禁用这个游戏对象的拾取之间进行切换。注意：切换单个游戏对象的可拾取性不会影响其子项。这些子项会保留以前具有的任何可拾取性状态。 资源工作流程资源表示 Unity 项目中用来创建游戏或应用的任何项。资源可以代表项目中的视觉或音频元素，例如 3D 模型、纹理、精灵、音效或音乐。资源还可以表示更抽象的项目，例如任何用途的颜色渐变、动画遮罩或任意文本或数字数据。流程：导入、创建、构建、分发、加载，具体如下：将资源导入 Unity 编辑器使用 Unity 编辑器通过这些资源创建内容。构建您的应用或游戏文件，以及可选的随附内容包分发构建的文件，以便您的用户可以通过发布者或应用程序商店访问根据您用户的行为以及您对内容进行分组和捆绑的方式，在运行时根据需要加载进一步更新。 工作流程考虑事项如果您使用大量作为单独包发布的资源，可能会发现将部分资源组分离为单独的项目很有帮助，这样您的团队成员就不需要一次性加载大型项目来使用这些资源包。 平台注意事项用户对平台的期望也是一个重要的考虑因素。例如，在移动平台上，漫长的初始下载和安装过程可能会导致玩家尚未尝试就放弃了您的应用。出于这个原因，移动应用通常在初始构建中只包含最少的资源集，并在用户第一次运行您的应用时从远程服务器下载剩余的资源。 常用的资源类型3D 模型文件图像文件音频文件||Text、HTML、XML、JSON 内置导入器unity有自己的内置导入期，具体可查看：内置导入器 脚本化导入器 (Scripted Importer)Scripted Importer 是 Unity Scripting API 的一部分。您可以使用 Scripted Importer 使用 C# 为 Unity 本身不支持的文件格式编写自定义资源导入器，从而添加支持。 注意：Scripted Importer 无法处理已由 Unity 本身处理的文件扩展名。脚本化导入器 导入器一致性资源导入器，包括您编写的任何脚本化导入器，应产生一致（确定性）的结果。这意味着它们应始终从相同的输入和依赖集产生相同的输出。检查一致性的两种方法是：在编辑器中手动重新导入一项或多项资源使用 -consistencyCheck 命令行参数打开编辑器。 Text assets__文本资源__是导入的文本文件的格式。将文本文件拖放到 Project 文件夹中时，它将转换为文本资源。支持的文本格式如下：.txt.html.htm.xml.bytes.json.csv.yaml.fnt 注意：文本资源与所有其他资源一样会在构建中经过序列化。发布游戏时并不包含物理文本文件。文本资源不适用于在运行时生成文本文件。(https://docs.unity.cn/cn/current/Manual/class-TextAsset.html) 资源元数据Unity 为资源分配唯一 ID。（ID 通常在编辑器中不可见）Unity 创建一个伴随资源文件的 .meta 文件。Unity 对资源进行处理。 Unity 针对空文件夹采用以下特定方式：如果 Unity 检测到一个空文件夹不再含有相应的元文件，如果该文件夹以前有元文件，Unity 会假设元文件被另一个用户通过在 VCS 中删除该文件夹时删除，并在本地删除该空文件夹。如果 Unity 检测到文件夹有一个新的元文件，但该文件夹在本地不存在，则 Unity 会假设新元文件是被另一个用户通过在 VCS 中添加文件夹而创建，并在本地创建相应的空文件夹。 Unity中常见的资源类型1、原始资源文件（从外部创建并导入Unity，每一个类型都对应一个AssetImporter）：Texture、Model、AudioClip、VideoClip、TextAsset、Font、其他。 2、代码文件：C#脚本文件、代码库文件、shader文件 等。导入时Unity会进行一次编译 3、序列化文件（可在Unity中创建、编辑，能够被Unity运行时反序列化的文件）Sprite、SpriteAtlas、Prefab、Scene、Script、Shader、Materrial、AnimationClip、RenderTexture、CustomRenderTexture、AudioMixer、CustomFont、GUISkin、PhysicMaterial、ComputeShader、AnimatorController、AnimatorOverrideController、AvatarMask、Brush、Cubemap、LightmapParameters、Timeline、Signal、TerrainLayer、AssemblyDefinition、AssemblyDefinitionReference、Asset(ScriptableObject)文件、其他。 4、文本文档（Unity 识别为 TextAsset，无 ImportSetting）txt、xml、json、二进制文件、其他。 5、非序列化文件（Unity无法识别的文件，如文件夹） 6、Meta文件可能会依赖其他资源的资源：Model、SpriteAtlas、Prefab、Scene、Materrial、CustomFont、GUISkin、AnimatorController、AnimatorOverrideController、AvatarMask、Brush、Cubemap、Timeline、TerrainLayer、其他。 特定资源文件夹Unity会将许多文件夹名解释为一条指令，说明文件夹中的内容应该以一种特殊的方式处理。 1、Assets: Unity项目资源主文件夹。除了部分函数需要将Assets文件夹包含在资源路径名中(例如，AssetDatabase类中的某些函数)， 其他大部分都不用。 2、Editor: 放在Editor文件夹中的脚本被视为Editor脚本而不是运行时脚本，这些脚本在开发期间向Editor添加功能，并在运行时的构建中不可用。可在Assets文件夹中的任何位置添加多个Editor文件夹。应将Editor脚本放在Editor文件夹内或其子文件夹内。 3、Editor Default Resources：Editor脚本可以通过 EditorGUIUtility.Load 函数按需加载资源文件，此函数将在 Editor Default Resources 文件夹中查找资源文件（也可放在Editor/Resources下）。只能有一个 Editor Default Resources 文件夹，且必须放在项目的根目录（直接位于Assets文件夹中）。资源可放在其子文件夹，加载时需拼上路径。 4、Gizmos：此文件夹允许将图形添加到Scene视图，以帮助可视化不可见的设计细节。Gizmos.DrawIcon 函数在场景中放置一个图标，作为特殊对象或位置标记。必须将图像放在Gizmos文件夹中，才能被DrawIcon函数找到。只能有一个Gizmos 文件夹，且必须放在项目的根目录（直接位于Assets文件夹中）。资源可放在其子文件夹，加载时需拼上路径。 5、Plugins：可为项目添加插件来扩展Unity的功能。插件通常是用C/C++编写的本地DLL。这些插件可以访问第三方代码库、系统调用和其他Unity内置功能。请始终将插件放在 名为 Plugins 的文件夹中，才能被Unity检测到。只能有一个Plugins 文件夹，且必须放在项目的根目录（直接位于Assets文件夹中）。 6、Resources: 可从脚本中按需加载资源。应将资源放在名为 Resources的文件夹中，使用 Resources.Load函数加载。可在Assets文件夹中的任何位置添加多个Resources文件夹。资源可放在其子文件夹，加载时需拼上路径。注意，如果Resources是Ediotr的子文件夹，则其中的资源可通过Editor脚本加载，但会从构建中剥离。 7、Standard Assets: 标准资源导入后的文件夹。只能有一个Standard Assets文件夹，且必须放在项目的根目录（直接位于Assets文件夹中）。资源可放在其子文件夹。 8、StreamingAssets: 希望资源以其原始格式作为单独的文件使用。例如文件系统访问视频文件。StreamingAssets中的文件可以按原样复制到目标计算机，然后就能从特定文件夹中访问该文件。只能有一个StreamingAssets文件夹，且必须放在项目的根目录（直接位于Assets文件夹中）。资源可放在其子文件夹，加载时需拼上路径。 9、隐藏的资源：为防止导入由操作系统或其他应用程序创建的特殊文件和临时文件，Unity会忽略Assets文件夹中的以下文件：隐藏的文件夹、以**.开头的文件和文件夹、以~**结尾的文件和文件夹、名为cvs的文件和文件夹、扩展名为.tmp的文件。 系统资源路径1、Application.dataPath：包含游戏数据文件夹的路径（只读）。和平台相关：Unity Editor: /AssetsiOS: /&lt;AppName.app&gt;/Data（只读文件夹，可使用Application.persistentDataPath保存）Android: 通常它会直接指向APK。但如果正在运行拆分的二进制构建，它将指向OBB（Opaque Binary Blob ）Mac player: /ContentsWin/Linux player: （请注意，大多数Linux安装都区分大小写！）WebGL: 播放器数据文件目录的绝对url(不含实际的数据文件名)Windows Store Apps: 播放器数据文件目录的绝对url（只读文件夹，可使用Application.persistentDataPath保存） 2、Application.persistentDataPath：包含持久数据目录的路径（可读可写）。该值是一个目录路径，其中可以存储需要在运行之间保留的数据。在 iOS 和 Android 上发布时，persistentDataPath 将指向设备上的公共目录。每次更新应用程序时，不会擦除此位置中的文件。但用户可以直接删除这些文件。 请注意，在构建应用程序时，将基于 Bundle ID 生成 GUID，并且此 GUID 将成为 persistentDataPath 的一部分。如果您在将来的版本中保留相同的 Bundle ID，那么应用程序将在每次更新时继续访问相同的位置。Windows Store Apps: 指向 %userprofile%\\AppData\\Local\\Packages&lt;productname&gt;\\LocalState.iOS: 指向 /var/mobile/Containers/Data/Application//Documents.Android: 通常指向 /storage/emulated/0/Android/data//files (一些旧手机可能会指向SD卡上的位置), 可使用 android.content.Context.getExternalFilesDir 解析路径。 3、Application.streamingAssetsPath：StreamingAssets文件夹的路径(只读)。在运行时，Application.streamingAssetsPath 提供文件夹的路径。如果将资产添加到 StreamingAssets文件夹。构建的应用程序就可以在这个地址加载资产。在WebGL和Android平台上不能访问StreamingAssets文件夹。因为 WebGL上没有可用的文件访问；而Android使用一个压缩的 .apk 文件，文件会被包含在压缩在 .jar文件（其格式与标准的zip压缩文件基本相同）中。这些平台返回一个URL，可以使用UnityWebRequest类访问URL来获得资产。Windows/MacOS: Application.dataPath + “/StreamingAssets”. iOS: Application.dataPath + “/RAW”. Android: “jar://file://“ + Application.dataPath + “!/assets/“. 注意：位于 StreamingAssets 文件夹中的 .dll 文件不参与编译。4、Application.temporaryCachePath：包含临时数据/缓存目录的路径（只读）。 该值是可以存储临时数据的目录路径。 资源数据库对于大多数类型的资源，Unity 需要将资源的源文件中的数据转换为可用于游戏或实时应用程序的格式。这些转换后的文件及其关联的数据会存储在资源数据库 (Asset Database) 中。 资源导入依赖项资源数据库可以跟踪每个资源的所有依赖项，并保留导入版本的所有资源的缓存。资源的导入依赖项包括可能影响所导入数据的全部数据。例如，一个资源的源文件是一个依赖项以及资源的导入设置（例如纹理的压缩类型）或项目的目标平台（例如，PS4 硬件要求的数据格式与 Android 硬件不同）。如果修改其中任意一个依赖项，则缓存版本的已导入资源都将变为无效状态，并且 Unity 必须将其重新导入才能反映所做的更改。 资源缓存资源缓存是 Unity 存储导入版本的资源的位置。默认情况下，Unity 使用本地缓存，这意味着导入版本的资源将缓存在本地计算机上项目文件夹的 Library 文件夹中。应该使用 ignore file 从版本控制中排除此文件夹。类似Git。团队成员并且使用版本控制系统，最好使用 Unity Accelerator，它可以跨 LAN 共享资源缓存。 源资源和 ArtifactUnity 在 Library 文件夹中保留两个数据库文件，它们统称为资源数据库。这两个数据库可以跟踪有关源资源文件和 Artifact（这是有关导入结果的信息）的信息。数据库文件位于项目的 Library 文件夹中，因此应从版本控制系统中将这些文件排除。可以在以下位置找到它们：(1).源资源数据库：Library\\SourceAssetDB(2).Artifact 数据库：Library\\ArtifactDB 特殊文件夹名称Assets: Assets 文件夹是包含 Unity 项目使用的资源的主文件夹。Editor: Editor脚本在开发过程中为Unity添加功能，Editor文件夹中的脚本作为Editor脚本运行，而不是运行时脚本。Editor Default Resources：Editor 脚本可以使用通过 EditorGUIUtility.Load 函数按需加载的资源文件。此函数在名为 Editor Default Resources 的文件夹中查找资源文件。Gizmos：Gizmos 允许将图形添加到 Scene 视图，以帮助可视化不可见的设计细节。Gizmos.DrawIcon 函数在场景中放置一个图标，作为特殊对象或位置的标记。必须将用于绘制此图标的图像文件放在名为 Gizmos 的文件夹中，这样才能被 DrawIcon 函数找到。Resources：可从脚本中按需加载资源，而不必在场景中创建资源实例以用于游戏。为此，应将资源放在一个名为 Resources 的文件夹中。通过使用 Resources.Load 函数即可加载这些资源。Standard AssetsStreamingAssets：流媒体文件Android Asset Packs：以.androidpack结尾的文件夹Android 库项目：以.androidlib结尾的文件夹 隐藏的资源在导入过程中，Unity 忽略 Assets 文件夹（或其子文件夹）中的以下文件和文件夹：隐藏的文件夹。以“.”开头的文件和文件夹。以“~”结尾的文件和文件夹。名为 cvs 的文件和文件夹。扩展名为 .tmp 的文件。 四、发布时会被打入包内的资源：1、Assets下所有非编辑器脚本文件。2、Assets下所有 参与构建的Scene文件（BuildSettings Scenes In Build 处设置）。3、Assets下直接或间接被 “参与构建的Scene文件” 所依赖的文件。4、Resources下的所有文件。5、Assets下直接或间接被 “Resources下的文件” 所依赖的文件。6、StreamingAssets下的所有文件（会被逐字拷入目标平台的特定文件夹）。7、Assets下所有 参与构建的Shader文件（ProjectSetting Built-in Shader Setting处设置）。8、Plugins下的对应平台下的文件。 文本资源不适用于在运行时生成文本文件？？？？VCS: version control system (版本控制系统)unity的开发保存在哪里？本地？线上？不可序列化变量??? (https://docs.unity.cn/cn/current/Manual/AssetDatabaseRefreshing.html)"},{"title":"unity手册笔记（2）","date":"2023-12-29T12:18:53.000Z","updated":"2024-02-27T03:22:02.698Z","comments":true,"path":"unity/unity-note-2.html","permalink":"https://sunjinkang.github.io/unity/unity-note-2.html","excerpt":"","text":"输入输入允许用户使用设备、触摸或手势来控制您的应用程序。您可以对应用程序内的元素（例如图形用户界面 (GUI) 或用户头像）进行编程，以不同方式响应用户输入。 Unity 支持来自多种输入设备的输入，包括： 键盘和鼠标 游戏杆 控制器 触摸屏 加速度计或陀螺仪等移动设备的运动感应功能 VR 和 AR 控制器 Unity 通过两个独立的系统提供输入支持： 输入管理器 (Input Manager) 是 Unity 核心平台的一部分，默认情况下可用。输入系统 (Input System) 是一个包，必须先通过 Package Manager 进行安装后才能使用。它需要 .NET 4 运行时，并且不能在使用旧版 .NET 3.5 运行时的项目中使用。 Input Manager 使用以下类型的控件： 键指物理键盘上的任何键，例如 W、Shift 键或空格键。 Button refers to any button on a physical controller (for example, gamepads), such as the X button on a remote control. 虚拟轴被映射到控件（例如按钮或键）。用户激活控件后，该轴会收到 [–1..1] 范围中的某个值。您可以将该值用于您的脚本。 移动设备输入 在移动设备上，Input 类提供对触摸屏、加速度计和地理/位置输入的访问。通过 iOS 键盘可以访问移动设备上的键盘。多点触控屏幕iPhone、iPad 和 iPod Touch 设备最多可跟踪五根手指同时触摸屏幕。可通过访问 Input.touches 属性数组来获取在最后一帧期间触摸屏幕的每根手指的状态。Android 设备对其跟踪的手指数量没有统一限制。相反，此限制因设备而异，可能是旧设备上的双手指触摸到某些新设备上的五指触摸。 移动键盘在大多数情况下，Unity 将自动处理 GUI 元素的键盘输入，但也很容易通过脚本按需显示键盘。GUI 元素当用户点击可编辑的 GUI 元素时，键盘将自动显示。目前，GUI.TextField、GUI.TextArea 和 GUI.PasswordField 将显示键盘；有关更多详细信息，请参阅 GUI 类文档。手动键盘处理使用 TouchScreenKeyboard.Open() 函数打开键盘。有关此函数所用的参数，请参阅 TouchScreenKeyboard 脚本参考。 文本预览默认情况下将创建一个编辑框，并在出现后放置在键盘顶部。此编辑框用于预览用户正在键入的文本，因此文本始终对用户可见。但是，可通过将 TouchScreenKeyboard.hideInput 设置为 true 来禁用文本预览。请注意，此设置仅适用于某些键盘类型和输入模式。例如，不适用于电话键盘和多行文本输入。在此类情况下将始终显示编辑框。TouchScreenKeyboard.hideInput 是一个全局变量，会影响所有键盘。 安全文本输入可配置键盘以使其在输入时隐藏符号。当用户需要输入敏感信息（例如密码）时，此功能非常有用。要在启用安全文本输入的情况下手动打开键盘，请使用以下代码： TouchScreenKeyboard.Open(“”, TouchScreenKeyboardType.Default, false, false, true); 警报键盘要显示带有黑色半透明背景而不是经典不透明背景的键盘，请调用 TouchScreenKeyboard.Open()，如下所示： TouchScreenKeyboard.Open(“”, TouchScreenKeyboardType.Default, false, false, true, true); 2DGameplay in 2D虽然 Unity 以 3D 功能而闻名，但也可用于创建 2D 游戏。熟悉的 Editor 功能仍然可用，但还添加了有助于简化 2D 开发的功能。 最明显的功能是 Scene 视图工具栏中的 2D 视图模式按钮。启用 2D 模式时将会设置正交（即无透视）视图：摄像机沿 Z 轴观察，而 Y 轴向上增加。因此可以轻松可视化场景并放置 2D 对象。 2D 图形2D 图形对象称为__精灵__。精灵本质上只是标准纹理，但可通过一些特殊技巧在开发过程中组合和管理精灵纹理以提高效率和方便性。Unity 提供内置的 Sprite Editor，允许从更大图像提取精灵图形。因此可以在图像编辑器中编辑单个纹理内的多个组件图像。例如，可以使用此工具将角色的手臂、腿和身体保持为一个图像中的单独元素。 2D 物理Unity 有一个独立物理引擎来处理 2D 物理，以便利用仅适用于 2D 的优化。2D 物理组件对应于标准 3D 物理组件（例如刚体 (Rigidbody)、盒型碰撞体 (Box Collider) 和铰链关节 (Hinge Joint)，但名称中附加了“2D”字样。因此，精灵可以配备 2D 刚体 (Rigidbody 2D)、2D 盒型碰撞体 (Box Collider 2D) 和 2D 铰链关节 (Hinge Joint 2D)。大多数 2D 物理组件都是 3D 对等组件的简单“平坦”版本（例如，_2D 盒型碰撞体_是正方形，而_盒型碰撞体_是立方体），但是也有一些例外。 2D 排序透明队列按优先级排序透明队列中的 2D 渲染器通常遵循以下优先级顺序： 排序图层和图层中的顺序 指定渲染队列 与摄像机的距离 透视/正交 自定义轴排序模式 精灵排序点 排序组 材质/着色器 多个渲染器具有相同的排序优先级时，将由仲裁程序决定优先级。"},{"title":"unity手册笔记（3）","date":"2023-12-31T11:54:11.000Z","updated":"2024-02-27T03:22:02.698Z","comments":true,"path":"unity/unity-note-3.html","permalink":"https://sunjinkang.github.io/unity/unity-note-3.html","excerpt":"","text":"组件 UI组件Text用于在UI界面中显示文本。它可以用于在UI界面中显示标题、说明、按钮标签等文本信息。在Unity中，UI界面是一个非常重要的元素，用于展示游戏的各种信息。为了在UI界面中显示文本信息，需要使用Text组件。Text组件可以设置文本的字体、大小、颜色、对齐方式等属性，用于调整文本的显示效果。Text组件还支持多种不同的文本排版方式，例如水平排版、垂直排版等，以满足不同的UI设计需求。它还支持自动换行、富文本等功能，以实现更加丰富和自然的文本显示效果。使用Text组件可以在UI界面中显示各种文本信息，以实现游戏的交互性和信息传递效果。它可以用于各种UI界面，例如主菜单、设置界面、商店界面等，让游戏更加友好和易用。 TextMeshPro-Text（UI）高级UI元素组件，用于在UI界面中显示高质量的文本。它是Unity Text组件的升级版，具有更高的分辨率、更好的字体渲染效果和更多的文本控制功能。TextMeshPro-Text（UI）可以使用TrueType字体文件，支持丰富的字体特效和文本排版样式。它可以调整文本的字体、大小、颜色、对齐方式等属性，支持自动换行、富文本等功能，以实现更加丰富和自然的文本显示效果。TextMeshPro-Text（UI）还支持不同的文本渲染模式，例如Distance Field模式、Bitmap模式等，以满足不同的UI设计需求。它还支持文本动画、曲线文本、3D文本等高级文本控制功能，以实现更加生动和多样化的文本效果。 Input Field用于在UI界面中显示可编辑的文本框。它可以用于让用户在UI界面中输入文本信息，例如用户名、密码、搜索关键字等。在Unity中，UI界面是一个非常重要的元素，用于展示游戏的各种信息。为了让用户在UI界面中输入文本信息，需要使用Input Field组件。Input Field组件可以设置文本框的大小、字体、颜色、对齐方式等属性，用于调整文本框的显示效果。Input Field组件还支持多种不同的输入方式，例如键盘输入、触摸输入等，以实现不同平台的输入控制。它还支持输入验证、密码遮罩、自动补全等功能，以提高输入的准确性和效率。使用Input Field组件可以在UI界面中实现文本输入功能，以实现游戏的交互性和信息传递效果。它可以用于各种UI界面，例如登录界面、注册界面、搜索界面等，让游戏更加友好和易用。 Dropdown用于在UI界面中显示下拉列表框。它可以用于让用户在UI界面中选择一个特定的选项，例如选择游戏难度、选择语言等。Dropdown组件可以设置下拉列表框的大小、字体、颜色、对齐方式等属性，用于调整下拉列表框的显示效果。它还可以设置列表中的选项，通过代码或Inspector面板添加、删除、修改选项。Dropdown组件还支持多种不同的选择方式，例如鼠标点击、键盘选择等，以实现不同平台的选择控制。它还支持选择事件、滚动条、下拉列表框的展开和收缩等功能，以提高选择的准确性和效率。 Slider用于在UI界面中显示滑动条。它可以用于让用户在UI界面中选择一个特定的数值范围，例如调整音量、调整游戏难度等。Slider组件可以设置滑动条的大小、颜色、对齐方式等属性，用于调整滑动条的显示效果。它还可以设置滑动条的最小值、最大值、当前值等参数，通过代码或Inspector面板修改数值范围和当前值。Slider组件还支持多种不同的滑动方式，例如鼠标拖动、键盘控制等，以实现不同平台的操作控制。它还支持数值变化事件、滑块的拖动范围、滑动方向等功能，以提高操作的准确性和效率。 Scrollbar用于在UI界面中显示滚动条。它可以用于让用户在UI界面中滚动内容，例如滚动文本、滚动图片等。Scrollbar组件可以设置滚动条的大小、颜色、对齐方式等属性，用于调整滚动条的显示效果。它还可以设置滚动条的当前值、最大值等参数，通过代码或Inspector面板修改数值范围和当前值。Scrollbar组件还支持多种不同的滚动方式，例如鼠标滚轮、拖动等，以实现不同平台的操作控制。它还支持数值变化事件、滑块的拖动范围、滚动方向等功能，以提高操作的准确性和效率。 Button用于在UI界面中显示可点击的按钮。它可以用于让用户在UI界面中进行各种操作，例如打开菜单、选择关卡等。 Selectable用于在UI界面中显示可选中的元素。它可以用于让用户在UI界面中选择和操作各种元素，例如选择角色、选中物品等。 Image用于在UI界面中显示图片。它可以用于在UI界面中显示2D图像、背景、按钮等。 Shadow用于在UI界面中为其他UI元素添加阴影效果。它可以用于为文本、图像、按钮等UI元素添加阴影效果，以提高视觉效果和可读性。Shadow组件可以设置阴影的颜色、偏移、模糊半径等属性，用于调整阴影效果的强度和样式。它还可以设置阴影的形状、角度、距离等属性，以实现不同的阴影效果。Shadow组件还支持多种不同的阴影类型，例如内阴影、外阴影、双向阴影等，以满足不同的视觉需求。它还可以设置阴影的交互状态、禁用状态等功能，以提高操作的准确性和效率。使用Shadow组件可以为UI界面中的其他UI元素添加阴影效果，以提高视觉效果和可读性。它可以用于各种UI界面，例如按钮、文本、图像等，让游戏更加美观和易用。 MaskRect Mask 2D和Mask都是Unity中用于实现UI遮罩效果的组件，它们的作用相似但是有一些区别。Rect Mask 2D是一种特殊的Mask，在UI界面中可用于实现矩形遮罩效果。它可以用于隐藏UI元素的一部分内容，以实现滚动列表、面板、弹出菜单等功能。与普通的Mask相比，Rect Mask 2D更加灵活，可以实现更多类型的遮罩效果。而Mask组件是一种通用的遮罩组件，可以用于实现各种形状的遮罩效果，包括矩形、圆形、自定义形状等。Mask组件可以将遮罩应用到UI元素的子元素中，以实现只遮罩该子元素的效果。它的灵活性较高，但是相比于Rect Mask 2D，其实现方式更加复杂。因此，如果需要实现矩形遮罩效果，建议使用Rect Mask 2D组件；如果需要实现其他形状的遮罩效果，建议使用Mask组件。 LAYOUT组件Rect Transform用于控制UI元素的位置、大小和旋转。它是基于屏幕坐标系而不是世界坐标系来控制UI元素的位置和大小的。RectTransform组件可以让UI元素相对于父级容器进行缩放、旋转和平移，这使得UI设计师可以更方便地创建自适应的UI布局。 Canvas用于呈现2D的UI元素。它是一个容器，可以包含其他UI元素，如文本、按钮、图像、滚动视图等。Canvas可以在场景中放置，并且可以在屏幕上显示出来。Canvas有两种渲染模式：Screen Space和World Space。Screen Space模式下，Canvas的大小和位置是基于屏幕的，UI元素的位置和大小也是相对于屏幕的。World Space模式下，Canvas的大小和位置基于游戏世界的坐标系，UI元素的位置和大小也是相对于游戏世界的。 Vertical Layout Group用于在Canvas中垂直排列子元素，方便开发者快速创建垂直布局的UI界面。Vertical Layout Group可以设置子元素之间的间距、子元素的大小、子元素的对齐方式等参数，还可以自动调整子元素的位置和大小，以适应不同的屏幕尺寸和分辨率。使用Vertical Layout Group可以快速创建垂直滚动列表、垂直菜单等UI界面，节省开发时间和精力。 Layout Element用于控制UI元素的最小、首选和最大尺寸。它可以帮助开发人员在Canvas中创建灵活的UI布局，以适应不同的屏幕尺寸和分辨率。Layout Element可以设置最小、首选和最大尺寸的宽度和高度，还可以设置UI元素的最小和最大宽高比。它也可以设置是否强制将UI元素的尺寸限制在最小和最大值之间。使用Layout Element可以控制UI元素的大小和比例，使其在不同的屏幕尺寸和分辨率下具有一致的外观和布局。它可以与其他UI组件如Layout Group和Content Size Fitter结合使用，创建更加复杂和灵活的UI布局。 Content Size Fitter用于根据UI元素的内容自动调整UI元素的大小。它可以帮助开发人员在Canvas中创建自适应的UI布局，以适应不同的屏幕尺寸和分辨率。Content Size Fitter可以设置UI元素的最小和最大尺寸，还可以设置UI元素的宽度和高度是否应该根据其内容自动调整。它可以根据UI元素的内容自动调整UI元素的大小，使其适应不同的屏幕尺寸和分辨率。使用Content Size Fitter可以创建自适应的UI布局，使UI元素的大小根据其内容自动调整，以避免内容被裁剪或空白区域过多。它可以与其他UI组件如Layout Group和Layout Element结合使用，创建更加灵活和自适应的UI布局。 Aspect Ratio Fitter用于根据UI元素的纵横比例自动调整UI元素的大小。它可以帮助开发人员在Canvas中创建具有一致纵横比例的UI布局，以适应不同的屏幕尺寸和分辨率。Aspect Ratio Fitter可以设置UI元素的纵横比例，还可以设置UI元素是否应该根据其父级容器的大小自动调整大小。它可以根据UI元素的纵横比例自动调整UI元素的大小，保持其与其他UI元素的纵横比例一致。使用Aspect Ratio Fitter可以创建具有一致纵横比例的UI布局，使UI元素的纵横比例始终保持一致，无论屏幕尺寸和分辨率如何变化。它可以与其他UI组件如Layout Group和Layout Element结合使用，创建更加灵活和自适应的UI布局。 动画组件Playable Director用于控制Unity中的时间线（Timeline）。它可以帮助开发人员创建复杂的场景、剧情、动画和游戏流程，并在运行时播放和控制它们。Playable Director可以设置时间线的播放速度、循环方式、暂停和播放状态等，并可以在运行时通过代码控制时间线的播放。它还可以与其他Unity组件如Animator、Audio Source、Particle System等结合使用，创建更加复杂和有趣的游戏场景和剧情。使用Playable Director可以在Unity中创建复杂的时间线动画、剧情和流程，并在运行时进行控制和调整。它可以帮助开发人员节省时间和精力，快速创建具有高度互动性和可玩性的游戏。 Animator用于控制游戏对象的动画。它可以帮助开发人员创建复杂的动画并控制游戏对象的运动和行为。Animator可以设置游戏对象的动画状态机，并通过状态机控制游戏对象的动画行为。它可以将多个动画片段组合成动画状态，并设置动画状态之间的转换条件和权重。它还可以通过代码控制动画状态的触发和转换，控制游戏对象的动画行为。使用Animator可以创建各种动画效果，如行走、跑步、跳跃、攻击等，增强游戏的视觉效果和互动性。它可以帮助开发人员创建更加复杂和有趣的游戏，让玩家更加享受游戏。 Animation遗留系统用于控制游戏对象的动画。它可以帮助开发人员创建简单的动画，并控制游戏对象的运动和行为。Animation可以将多个动画片段组合成动画剪辑，并控制动画剪辑的播放速度、循环方式和动画帧率。它还可以通过代码控制动画剪辑的播放和停止，控制游戏对象的动画行为。 视频组件Video Player用于在Unity中播放视频。它可以帮助开发人员在游戏中添加视频作为背景、剧情、介绍、广告等，增强游戏的视觉效果和交互性。Video Player可以播放本地视频和网络视频，并支持各种视频格式，如MP4、AVI、MOV等。它可以设置视频的播放速度、音量、循环方式、全屏模式等，并可以通过代码控制视频的播放和暂停。使用Video Player可以在Unity中添加各种视频素材，如游戏介绍、剧情、广告等，增加游戏的视觉效果和互动性。它可以帮助开发人员提高游戏的质量和吸引力，让玩家更加享受游戏。"},{"title":"unity手册笔记（4）","date":"2023-12-31T11:54:11.000Z","updated":"2024-02-27T03:22:02.698Z","comments":true,"path":"unity/unity-note-4.html","permalink":"https://sunjinkang.github.io/unity/unity-note-4.html","excerpt":"","text":"其他组件 Transform用于控制游戏对象的位置、旋转和缩放等变换操作。它是所有游戏对象的基础组件之一，可以实现游戏对象的移动、旋转和缩放等操作。Transform 可以控制游戏对象的位置、旋转和缩放等变换操作。它是游戏对象的基础组件之一，可以通过修改其属性来实现游戏对象的移动、旋转和缩放等操作。其中，位置属性控制游戏对象的世界坐标，旋转属性控制游戏对象的旋转角度，缩放属性控制游戏对象的缩放比例。Transform 还支持父子关系，即一个游戏对象可以成为另一个游戏对象的子对象，这样当父对象移动、旋转或缩放时，其子对象也会相应地进行变换操作。此外，Transform 还提供了一些方法，例如 LookAt()、Rotate()、Translate() 等，可以实现更加灵活的变换操作。总之，Transform 是 Unity 中控制游戏对象变换的基础组件之一，可以实现游戏对象的移动、旋转和缩放等操作。它是游戏开发中不可或缺的工具，可以提高游戏的可玩性和视觉效果。 Mesh Filter用于将网格数据应用到 3D 模型上。它是实现 3D 模型的重要组成部分之一，可以定义模型的形状和结构。 Mesh Renderer用于将 3D 模型渲染到屏幕上。它是游戏中 3D 模型的重要组成部分之一，可以让游戏中的角色、场景和物品等立体化呈现。 碰撞器组件 Capsule Collider用于将游戏对象转换为一个胶囊形状的物理碰撞体。Capsule Collider 可以与刚体组件一起使用，以便让游戏对象能够受到外力的作用，并且可以与其他类型的碰撞体进行碰撞检测。Capsule Collider 可以被用于表示一些通常比较难以用简单几何体表示的物体，例如人物角色、动物等。Capsule Collider 的形状类似于一个胶囊，即上下两个半球面之间连接着一根圆柱体。这种形状能够很好地适应许多物体的形状，同时也能够提供更加准确的碰撞检测。Capsule Collider 组件提供了许多属性，例如半径、高度、方向等，可以用来调整碰撞体的形状和大小，以便更好地适应不同类型的物体。通过调整这些属性，可以实现更加准确的碰撞检测，从而提高游戏的真实感和可玩性。 Mesh Collider用于将游戏对象的 Mesh 网格转换为物理碰撞体，以便在游戏中进行物理交互。Mesh Collider 可以与刚体组件一起使用，以便让游戏对象能够受到外力的作用，并且可以与其他 Mesh Collider 或其他类型的碰撞体进行碰撞检测。 Terrain Collider用于在场景中的地形（Terrain）上添加碰撞检测功能。当一个物体与Terrain Collider发生接触时，就会触发碰撞事件，从而可以实现各种游戏场景的交互效果。Terrain Collider可以在Unity中的地形编辑器中自动生成，也可以手动添加到地形游戏对象上。它基于地形的高度图和纹理信息，自动生成一个准确的碰撞器，从而实现真实的碰撞检测效果。 Wheel Collider用于模拟车辆的轮胎碰撞效果。它可以将车辆的轮胎与地面进行真实的碰撞检测，从而实现车辆的运动效果。当一个车辆游戏对象上添加了Wheel Collider组件后，该组件会自动根据车轮的位置和半径生成一个碰撞器。车辆在运动过程中，Wheel Collider会根据车轮的旋转情况和与地面的接触情况，计算出车轮的运动状态，包括速度、加速度、阻力等，并将这些信息反馈给车辆游戏对象，从而实现真实的车辆运动效果。 物理组件Fixed Joint用于将两个游戏对象固定在一起，从而实现刚体之间的约束。它可以模拟物理学中的刚体连接效果，使得两个游戏对象的运动状态相互影响。Fixed Joint通常用于模拟各种机械装置、建筑物结构等，例如门、桥梁、吊车等。当两个游戏对象之间添加了Fixed Joint组件后，它们就会被连接在一起，从而形成一个整体。在运动过程中，它们的位置和旋转状态会相互影响，从而实现真实的物理效果。除了基本的连接功能外，Fixed Joint还支持多种参数设置，例如连接的刚体、连接的点、最大力矩等。开发者可以根据游戏需求调整这些参数，以实现更加精确的连接效果。总的来说，Fixed Joint是实现游戏物理效果的一个非常有用的组件，可以让开发者轻松地模拟刚体之间的连接效果，从而实现各种有趣的游戏场景。 Spring Joint 2D用于模拟弹簧的力学效应，使得两个游戏对象之间产生弹簧效果。它可以模拟物理学中的弹簧连接效果，使得两个游戏对象之间产生拉扯的力量。Spring Joint 2D通常用于模拟各种弹簧装置、弹性物体等，例如弹簧床、绳索、弹性球等。当两个游戏对象之间添加了Spring Joint 2D组件后，它们就会被连接在一起，从而形成一个弹簧。在运动过程中，它们之间的距离和速度会相互影响，从而产生弹簧效果。 Friction Joint 2D用于模拟两个游戏对象之间的摩擦力效果，使得它们之间的运动产生摩擦力。它可以模拟物理学中的摩擦效应，使得两个游戏对象之间的运动更加真实。Friction Joint 2D通常用于模拟各种摩擦装置、滑动物体等，例如滑动门、滑动箱子等。当两个游戏对象之间添加了Friction Joint 2D组件后，它们就会产生摩擦力，从而影响它们之间的运动。在运动过程中，它们之间的摩擦力会随着运动速度的变化而改变，从而实现真实的摩擦效应。 Distance Joint 2D用于模拟两个游戏对象之间的距离约束，使得它们之间的距离保持不变。它可以模拟物理学中的距离效应，使得两个游戏对象之间的运动产生约束。Distance Joint 2D通常用于模拟各种物体的连接、绳索等，例如吊车、绳索桥等。当两个游戏对象之间添加了Distance Joint 2D组件后，它们就会被连接在一起，从而形成一个约束。在运动过程中，它们之间的距离会保持不变，从而实现真实的距离效应。 Target Joint 2D用于模拟物体的跟踪效果，使得一个游戏对象能够跟随另一个游戏对象的运动轨迹。它可以模拟物理学中的跟踪效应，使得游戏对象之间的运动更加真实。Target Joint 2D通常用于模拟各种追踪效果、跟踪导弹等，例如追踪摄像机、跟踪器等。当一个游戏对象添加了Target Joint 2D组件后，它就会跟随另一个游戏对象，从而实现跟踪效果。在运动过程中，它们之间的距离和速度会相互影响，从而产生真实的跟踪效果。 Hinge Joint 2D用于模拟物体的旋转效果，使得两个游戏对象之间产生旋转约束。它可以模拟物理学中的旋转效应，使得两个游戏对象之间的运动更加真实。Hinge Joint 2D通常用于模拟各种旋转装置、旋转门等，例如旋转门、旋转关节等。当两个游戏对象之间添加了Hinge Joint 2D组件后，它们就会被连接在一起，从而形成一个旋转约束。在运动过程中，它们之间的旋转约束会随着运动角度的变化而改变，从而实现真实的旋转效应。 导航组件 Nav Mehs Agent用于实现游戏对象的导航功能。Nav Mesh Agent通常用于模拟各种导航效果，例如角色移动、AI行为等。Nav Mesh Agent可以将一个游戏对象移动到指定位置，并且可以自动避免障碍物。例如，当玩家指定一个位置时，Nav Mesh Agent会自动计算最短路径，并且在移动时避免障碍物，从而实现自动导航的效果。Nav Mesh Agent还支持多种参数设置，例如移动速度、加速度、角色半径等。开发者可以根据需求调整这些参数，以实现更加精确的导航效果。总的来说，Nav Mesh Agent是Unity中实现导航功能的一个非常有用的组件，可以让开发者轻松地实现各种导航效果，从而实现各种有趣的游戏场景。 Nav Mesh Obstacle用于在场景中创建动态障碍物，以影响Nav Mesh Agent的自动导航行为。Nav Mesh Obstacle可以让开发者在运行时添加或移除障碍物，从而实现更加灵活的导航功能。Nav Mesh Obstacle可以被添加到任何游戏对象上，它会在导航网格中创建一个障碍物区域，阻止Nav Mesh Agent在该区域内移动。在设置Nav Mesh Obstacle时，开发者需要指定障碍物的形状、大小、旋转等属性，以及障碍物的类型（例如，墙壁、栅栏、桌子等）。 Off Mesh Link用于在导航网格上创建离散的连接点，以实现Nav Mesh Agent之间跨越障碍物或空隙的导航。通常，在场景中出现的一些特殊情况，例如悬崖、吊桥、绳索等，需要Nav Mesh Agent能够跨越障碍物进行导航，这时就需要用到Off Mesh Link。 音频组件 Audio Source用于在场景中播放音频。开发者可以将Audio Source组件添加到游戏对象上，并将音频文件添加到Audio Source组件中进行播放。在设置Audio Source时，开发者可以指定音频文件、音量、音调、循环播放等属性。Audio Source还支持3D音效，可以让音效在空间中产生方向和距离的变化，从而增强游戏的真实感和沉浸感。除了播放音频，Audio Source还可以用于检测碰撞事件。开发者可以在Audio Source组件中设置碰撞器，当其他游戏对象与碰撞器发生碰撞时，Audio Source会自动播放指定的音频文件，从而实现碰撞音效的效果。Audio Source还支持动态更新，可以在运行时更改音频文件、音量、音调等属性。这使得开发者可以根据游戏的需求实时调整音效，以增强游戏的体验效果。总的来说，Audio Source是实现游戏音效的一个非常有用的组件，可以让开发者轻松地实现各种类型的音频播放和碰撞音效效果。 Audio Listener用于监听场景中的音频，并将其转换为可听的声音。每个场景中只能有一个Audio Listener，它通常被添加到主摄像机上，以便根据摄像机位置和方向来监听音频。当Audio Listener接收到音频时，它会根据音频源的位置、方向和距离等信息，将音频转换为可听的声音，并将其输出到扬声器或耳机中。Audio Listener还支持3D音效，可以根据音频源的位置和距离等信息，产生方向和距离的变化，从而增强游戏的真实感和沉浸感。 Audio Reverb Zone用于模拟音频的混响效果。它可以将场景中的音频信号经过处理，产生类似于在一个封闭空间中听到声音的效果。在游戏中，Audio Reverb Zone通常被用于模拟不同环境下的声音效果，例如室内、室外、山洞等。当Audio Reverb Zone被添加到游戏对象上时，它会创建一个虚拟的混响空间，在这个空间中播放的音频会受到混响效果的影响。开发者可以在Audio Reverb Zone组件中设置混响的属性，例如混响时间、混响强度、混响预设等。这些属性可以影响混响效果的强度和表现形式。 Audio Low Pass Filter用于控制音频的低频信号。它可以通过降低音频的低频信号来模拟不同的音效，使得音频更加真实。Audio Low Pass Filter通常用于模拟各种音效，例如低沉的嗓音、远处的声音等。当一个音频源添加了Audio Low Pass Filter组件后，它就会对音频进行低频信号过滤，从而模拟不同的音效。 Audio Hight Pass Filter用于控制音频的高频信号。它可以通过降低音频的高频信号来模拟不同的音效，使得音频更加真实。Audio High Pass Filter通常用于模拟各种音效，例如尖锐的声音、近处的声音等。当一个音频源添加了Audio High Pass Filter组件后，它就会对音频进行高频信号过滤，从而模拟不同的音效。 Audio Echo Filter用于在音频中加入回声效果。它可以模拟不同的回声效果，使得音频更加真实。Audio Echo Filter通常用于模拟各种音效，例如在山洞或大厅中的声音回声。当一个音频源添加了Audio Echo Filter组件后，它就会对音频进行回声处理，从而模拟不同的回声效果。 Audio Distortion Filter用于在音频中加入失真效果。它可以模拟各种失真效果，使得音频更加独特。Audio Distortion Filter通常用于模拟各种音效，例如吉他失真效果、电子音乐等。当一个音频源添加了Audio Distortion Filter组件后，它就会对音频进行失真处理，从而模拟不同的失真效果。 Audio Chorus Filter用于在音频中添加合唱效果。合唱效果是指将多个声音混合在一起，产生更加丰富、立体的音效。Audio Chorus Filter通过改变音频的时间和频率，来模拟多个声音同时发生的效果。它包含多个参数，例如混响、延迟、振幅等，可以用来调整合唱效果的强度、深度和速度等。"},{"title":"tags","date":"2023-07-26T07:14:06.000Z","updated":"2023-07-26T07:14:30.896Z","comments":true,"path":"tags/index.html","permalink":"https://sunjinkang.github.io/tags/index.html","excerpt":"","text":""},{"title":"unity手册笔记（5）","date":"2024-01-25T13:05:19.000Z","updated":"2024-02-27T03:22:02.698Z","comments":true,"path":"unity/unity-note-5.html","permalink":"https://sunjinkang.github.io/unity/unity-note-5.html","excerpt":"","text":"特效组件 Particle System用于创建和控制粒子效果。例如火花、烟雾、水滴等，可以用来增强游戏的视觉效果和氛围。Particle System包含多个参数，例如粒子的形状、大小、速度、颜色等，可以用来调整粒子效果的外观和行为。同时，还支持多种粒子发射方式，例如喷射、爆炸、旋转等，可以让粒子效果更加生动、多样。使用Particle System可以在游戏中创建各种粒子效果，例如火焰、烟雾、雨、雪等。这些效果可以用来增加游戏的视觉效果，增强游戏的氛围。同时，还可以用来表示游戏中的事件，例如爆炸、冲击等，让玩家更加直观地感受游戏的动态变化。 Visual Effect用于创建和控制各种视觉效果。Visual Effect使用基于节点的图形编辑器，可以用来创建复杂的视觉效果，例如火焰、水、云等。Visual Effect包含多个节点，每个节点代表一个图形特效。节点可以用来控制特效的外观、行为和运动方式。Visual Effect还支持多种渲染技术，例如体积渲染、屏幕空间反射等，可以用来增强特效的真实感和逼真度。使用Visual Effect可以创建各种高级的视觉效果，例如火焰、水、云、电等。这些效果可以用来增加游戏的视觉效果和氛围，提高游戏的品质和体验。同时，还可以用来表示游戏中的事件，例如魔法攻击、技能释放等，让玩家更加直观地感受游戏的动态变化。 Trail Renderer用于创建和控制轨迹效果。轨迹效果是指物体在移动过程中留下的痕迹，例如火箭尾迹、手指滑动的轨迹等。Trail Renderer可以将物体的移动轨迹以一定的精度绘制出来，并用材质渲染出来。它包含多个参数，例如宽度、颜色、持续时间等，可以用来调整轨迹效果的外观和行为。 Line Renderer用于创建和控制线条效果。线条效果是指一些简单的、连续的、直线或曲线形状的图形元素，例如绘画、图表、游戏中的路径等。Line Renderer可以将一组点连接起来，以一定的精度绘制出线条，可以用材质渲染出来。它包含多个参数，例如宽度、颜色、连接方式等，可以用来调整线条效果的外观和行为。 Projector用于在场景中投影纹理。它可以将一个纹理投影到场景中的任何一个物体上，以模拟阴影、反射、环境光、景深等效果。Projector可以设置投影的纹理、角度、位置、大小、透明度等参数。它也可以用于动态投影，例如在游戏中实时投射玩家的角色影像。 Lens Flare用于在游戏中模拟相机镜头中的Lens Flare效果。Lens Flare可以设置光晕的类型、大小、亮度、色彩、位置等参数。它可以用来模拟太阳、月亮、灯光等光源的光晕效果。 Particle System Force Field它可以在场景中创建一个力场，通过吸引或排斥粒子来实现各种效果。使用Particle System Force Field可以创建各种复杂的粒子效果，如火焰、水流、爆炸等。Particle System Force Field提供了许多属性和方法，如力场类型、力度、半径、形状等，使开发人员可以轻松地创建和管理粒子效果。它还可以与其他Unity组件配合使用，如Particle System、Collider、Rigidbody等。使用Particle System Force Field可以创建各种复杂的粒子效果，如火焰的向上喷射、水流的流动和旋转、爆炸的冲击波和碎片等。它可以帮助开发人员提高游戏的视觉效果和玩家的体验，使游戏更加有趣和吸引人。 Wind Zone它可以在场景中创建一个风区域，通过改变风的方向、速度和扰动等参数，来模拟各种不同的风效果。Wind Zone提供了许多属性和方法，如风的方向、风的速度、风的扰动、风的最大距离等，使开发人员可以轻松地创建和管理风效果。它还可以与其他Unity组件配合使用，如Rigidbody、Cloth、Particle System等。 渲染组件 Camera用于控制场景中相机的视角和投影方式。它可以设置相机的位置、旋转、视野、投影方式等参数。在游戏中，相机是非常重要的，因为它可以控制玩家的视角，让玩家可以观察和控制游戏中的场景和角色。相机可以设置为透视投影或正交投影，透视投影可以模拟真实的视野效果，而正交投影则可以保证物体的大小比例不变。相机还可以设置多个，用于创建多个视角或场景切换时的过渡效果。相机也可以设置跟随物体移动，以实现玩家的跟随视角。使用相机可以控制游戏中的视角和投影方式，让玩家可以更加方便地观察和控制游戏中的场景和角色。相机还可以用于实现各种过渡效果，例如场景切换、动画过渡等，增强游戏的视觉效果和体验。 Light用于在场景中创建光源。它可以设置光源的颜色、强度、类型、范围等参数。在游戏中，光源是非常重要的，因为它可以控制场景中的光照效果和阴影效果，增强游戏的真实感和逼真度。常用的光源类型有点光源、聚光灯和方向光源。点光源可以模拟灯泡等局部光源，聚光灯可以模拟手电筒等局部聚焦光源，方向光源可以模拟太阳等全局光源。 Occlusion Area用于创建遮挡区域。它可以用于优化游戏的性能，减少不必要的渲染工作量。在游戏中，一些物体可能处于不可见的区域，例如在角落里、在墙后面等。如果这些物体被渲染，会浪费大量的计算资源。为了解决这个问题，可以使用遮挡区域来剔除这些不可见的物体。Occlusion Area可以在场景中创建一个遮挡区域，用于剔除不可见的物体。它可以设置遮挡区域的大小、形状、位置等参数。在运行时，遮挡区域会根据玩家的视角来判断哪些物体处于不可见的区域，然后将这些物体从渲染列表中剔除，从而减少不必要的渲染工作量。使用Occlusion Area可以优化游戏的性能，减少不必要的渲染工作量。它可以用于各种游戏场景，例如室内场景、战斗场景等，让游戏更加流畅和稳定。 Occlusion Portal用于创建遮挡门。一些区域可能会有多个出入口或者门，开门时渲染，关门时剔除。 Canvas Renderer用于将UI元素渲染到屏幕上。它可以用于创建各种UI元素，例如按钮、文本框、图片等。在游戏中，UI元素通常不是3D对象，而是2D平面。为了将这些UI元素渲染到屏幕上，需要使用Canvas Renderer组件。Canvas Renderer可以将UI元素转换成屏幕上的像素，然后将其显示出来。 Sprite Renderer用于将2D精灵渲染到屏幕上。它可以用于创建2D游戏中的角色、背景、道具等元素。在游戏中，2D精灵通常是由一张或多张纹理组成的。为了将这些2D精灵渲染到屏幕上，需要使用Sprite Renderer组件。Sprite Renderer可以将2D精灵转换成屏幕上的像素，然后将其显示出来。 Sorting Group用于控制2D精灵的渲染顺序。它可以用于解决2D精灵渲染顺序冲突的问题，使得2D精灵可以按照指定的顺序渲染，不会出现遮挡或者错位的情况。在游戏中，如果多个2D精灵处于同一位置或者有交叉的部分，它们的渲染顺序会发生冲突，导致某些2D精灵被遮挡或者错位。为了解决这个问题，可以使用Sorting Group组件来控制2D精灵的渲染顺序。 Skybox用于创建游戏场景的天空盒。它可以用于创建各种不同的天空效果，例如蓝天白云、夜晚星空、日落黄昏等。在游戏中，天空盒是一个用于渲染天空的立方体纹理。天空盒通常包括六个面，分别代表天空的前后左右上下六个方向。为了将天空盒渲染到游戏场景中，需要使用Skybox组件。 Streaming Controller用于控制游戏资源的动态加载和卸载。它可以用于优化游戏的性能，减少游戏的加载时间和内存占用。在游戏中，资源的加载和卸载是一个非常重要的问题。如果所有的资源都一次性加载到内存中，会导致游戏的加载时间和内存占用非常高，影响游戏的性能。为了解决这个问题，可以使用Streaming Controller组件。 Tilemap组件Tilemap用于创建2D游戏场景中的地图。它可以用于创建各种不同的地图，例如平面地图、迷宫地图、战斗地图等。在2D游戏中，地图是一个非常重要的元素。为了创建地图，需要使用Tilemap组件。Tilemap可以将大量的小块（Tile）组合在一起，形成复杂的地图。Tilemap可以设置Tile的材质、颜色、碰撞等属性。它还可以设置Tile的位置、旋转、缩放等变换，用于调整Tile的效果。在运行时，Tilemap会将所有的Tile渲染到游戏场景中，让玩家可以感受到真实的地图效果。使用Tilemap可以创建各种不同的地图，并将其渲染到游戏场景中。它可以用于各种2D游戏场景，例如平面地图、迷宫地图、战斗地图等，让游戏更加丰富和有趣。 Tilemap Renderer用于渲染2D游戏场景中的Tilemap。它可以用于将Tilemap渲染到游戏场景中，让玩家可以看到真实的地图效果。 事件组件 Event System用于处理用户交互事件。它可以用于捕捉用户的输入、点击、拖拽等事件，并将其发送给合适的游戏对象进行处理。在Unity中，用户交互事件是一个非常重要的元素。为了处理用户交互事件，需要使用Event System组件。Event System组件会捕捉所有的用户交互事件，并将它们发送给游戏对象进行处理。Event System组件可以设置事件的优先级、事件的触发方式、事件的响应对象等属性，用于调整事件的处理方式。它还支持多个Event System的层叠使用，以处理游戏中多种不同的用户交互事件。使用Event System可以处理用户交互事件，例如鼠标点击、键盘输入、触摸屏幕等，以实现游戏的交互性。它可以用于各种游戏场景，例如角色扮演游戏、平台游戏、策略游戏等，让游戏更加丰富和有趣。 Event Trigger用于响应用户在UI元素上的交互事件。它可以用于捕捉用户的点击、拖拽、鼠标悬停等事件，并执行相应的操作。在Unity中，UI元素的交互事件是一个非常重要的元素。为了响应UI元素的交互事件，需要使用Event Trigger组件。Event Trigger组件可以向UI元素添加多个事件处理程序，用于响应用户的不同交互事件。 Standalone Input Module用于处理鼠标、键盘等输入设备的输入事件。它可以用于捕捉用户在游戏中的输入事件，并将其转换成Unity中的事件系统。在Unity中，用户输入是一个非常重要的元素，用于控制游戏中的角色、物体等。为了处理用户的输入事件，需要使用Standalone Input Module模块。Standalone Input Module模块可以捕捉鼠标、键盘等输入设备的输入事件，并将其转换成Unity中的事件系统。"},{"title":"unity手册笔记（6）","date":"2023-01-29T12:48:20.000Z","updated":"2024-02-27T03:22:02.698Z","comments":true,"path":"unity/unity-note-6.html","permalink":"https://sunjinkang.github.io/unity/unity-note-6.html","excerpt":"","text":"Unity 代码仓库建议参与 Unity 开源项目时使用 Bitbucket，这是unity内部使用的工具，能让工作变得简单。Unity 有许多开源代码仓库可帮助开发人员使用 Unity 软件：http://bitbucket.org/Unity-Technologies/ unity 最新的代码仓库，主要由 Unity UI 团队和研发内容团队使用。一些核心研发项目最终会进驻到这里（主要是由于开发人员的偏好），例如 5.3 版内存性能分析器。https://github.com/Unity-Technologies unity 最早的代码仓库，一些核心研发项目的开源工作保存在这里。主要项目包括 Unity 的 Mono 分叉（C# 运行时）和 Katana 分叉（构建/CI 系统）。用于 WebGL 的大部分技术（例如 Emscripten）也在这里托管。https://github.com/unity3d-jp 此代码仓库由 Unity 日本研发团队和传播团队使用。此代码仓库包含该办事处员工的演示项目、原型和编外项目。有趣的项目包括即将推出的用于构建 AssetBundle 的 Asset Graph 系统、一个演示如何在 Unity 中有效使用线程的演示项目，以及一个演示如何使用 Unity Ads 的示例项目。 如何参与 Unity 的开源项目Unity 使用分布式版本控制来控制开源组件的版本。可通过以下步骤参与Unity的开源项目。步骤 1：获取 Bitbucket 帐户步骤 2：将您想要参与的代码仓库进行分叉步骤 3：克隆您的分叉步骤 4：对分叉应用修改步骤 5：在 Bitbucket 上提出拉取请求步骤 6：等待反馈 以上具体步骤信息可查看官网文档：https://docs.unity.cn/cn/current/Manual/ContributingBitbucket.html Unity Asset StoreUnity资产商店包含Unity Technologies和社区成员创建的免费和商业资产库。提供了多种资源，包括纹理、模型、动画、整个项目示例、教程和编辑器扩展。 从Unity 2020.1开始，专用的资产存储窗口不再位于Unity编辑器中。但是，您仍然可以访问资产商店网站https://assetstore.unity.com/ 您仍然可以搜索您购买和下载的资产商店软件包，并直接在软件包管理器窗口中导入和下载它们。 Asset Store 资源包在 Unity Package Manager 中，选择 My Assets 筛选条件以查看您可用 Asset Store 资源包的列表。可按名称搜索 Asset Store 资源包。找到要使用的 Asset Store 资源包后，可将资源包下载并导入到 Package Manager 中。如果 Asset Store 资源包具有可用的较新版本，也可以直接在 Package Manager 窗口中对其进行更新。 Unity 用户可以成为 Asset Store 上的发布者，并出售自己创建的内容。按照发布到 Asset Store 中的说明进行操作，创建资源包草案并从 Unity 上传您的资源，将其发布到 Unity Asset Store。 下载的资源文件的位置您可以使用“软件包管理器”窗口来管理项目中的资产存储软件包。但是，如果需要直接访问资产文件，可以在资产存储包缓存中找到这些文件。该缓存与全局缓存分离，使包的重用和共享更加高效。您可以在以下路径中找到资产存储包缓存（根据您的计算机设置，这些路径可能位于隐藏文件夹中）: macOS: ~/Library/Unity/Asset Store-5.xWindows: C:\\Users\\accountName\\AppData\\Roaming\\Unity\\Asset Store-5.xLinux: ~/.local/share/unity3d/Asset Store-5.x 发布到 Asset Store 将资源发布到 Asset Store 的基本工作流程如下： 创建发布者帐户。创建新的资源包草案。还可以随时删除草案，然后新建草案。将资源上传到资源包。填写资源包详情。提交资源包以供批准。查看您的资源的 Asset Store 提交状态。在等待 Unity 是否已接受将资源包发布到 Asset Store 的通知时，可以设置付款资料，以便可以获取资源包带来的收入。如果尚未如此操作，还可以为您的发布者帐户设置客户支持信息。 将资源包发布到 Asset Store 后，可以执行以下操作来提高资源包被发现的可能性并鼓励客户购买您的资源包： 向资源包添加标签，便于客户找到资源包。将帐户关联到 Google Analytics 以跟踪您在 Asset Store 上的资源包页面的网站流量。Unity 可能会为您提供机会将资源包加入到 Asset Store 促销中。您可以参与 Unity 的促销或者创建自己的促销。授权 Unity 就您的资源包向您的客户退款。如果要更新或增强现有资源包，可以创建主要升级版本。将升级发布到 Asset Store 后，可以弃用旧资源包，以便新用户只能找到最新版本。还可以创建一个“精简”升级版本，该版本可用于让客户试用资源包，而无需付全款。 在 Publisher Account 页面上的选项卡中可以执行以下操作： 阅读关于资源包的评论 (Reviews)。检查销量 (Sales) 和收入 (Revenue)。查看资源包的下载量 (Downloads) 以及您发放给客户的任何兑换券 (Vouchers) 的相关统计信息。管理您团队中的用户 (Users)。管理您的帐户信息 (Info)。如需上述任何过程的其他帮助信息，请参阅在线的 Asset Store 常见问题解答和 Asset Store 论坛。资源已被 Asset Store 接受的发布者还可以申请加入发布者论坛。 平台开发在开始使用Unity Editor之前，您可能需要熟悉可以在其中创建项目的平台。Unity支持大多数领先的桌面、web和移动平台，如下所示：独立平台：macOS、Windows和LinuxtvOSIOSAndroidWebGL注意：如果您是一名可以访问Closed平台的开发人员，在下载和注册首选平台设置时，您可能会看到更多平台选项。 具体平台可查看官方文档：https://docs.unity.cn/cn/current/Manual/PlatformSpecific.html，开发人员可根据自身开发需要选择平台，修改配置进行开发。"},{"title":"","date":"2023-07-24T09:24:46.479Z","updated":"2023-07-24T09:24:46.479Z","comments":true,"path":"nodejs/file/test.js","permalink":"https://sunjinkang.github.io/nodejs/file/test.js","excerpt":"","text":"// console(控制台) // const fs = require('fs'); // const { Console } = require('console'); // const output = fs.createWriteStream('./stdout.log'); // const errorOutput = fs.createWriteStream('./stderr.log'); // // 自定义的简单记录器 // const logger = new Console(output, errorOutput); // // 像 console 一样使用 // // const count = 5; // // logger.log('count: %d', count); // // // stdout.log 中打印: count 5 // // logger.error(new Error(`error: ${count}`)); // // logger.warn('test warn'); // console.assert(true, 'does nothing'); // // 通过 // console.assert(false, 'Whoops %s', \"didn't work\"); // Assertion failed: Whoops didn't work // const crypto = require('crypto'); // const secret = 'abcdefg'; // const hash = crypto // .createHmac('sha256', secret) // .update('I love cupcakes') // .digest('hex'); // console.log(hash); // c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e // const cert = require('crypto').Certificate(); // const spkac = getSpkacSomehow(); // const challenge = cert.exportChallenge(spkac); // console.log(challenge.toString('utf8')); // const crypto = require('crypto'); // const cipher = crypto.createCipher('aes192', 'a password'); // let encrypted = ''; // cipher.on('readable', () => { // const data = cipher.read(); // if (data) encrypted += data.toString('hex'); // }); // cipher.on('end', () => { // console.log(encrypted); // // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504 // }); // cipher.write('some clear text data'); // cipher.end(); // const crypto = require('crypto'); // const fs = require('fs'); // const cipher = crypto.createCipher('aes192', 'a password'); // const input = fs.createReadStream('test.js'); // const output = fs.createWriteStream('test.enc'); // input.pipe(cipher).pipe(output); // const crypto = require('crypto'); // const cipher = crypto.createCipher('aes192', 'a password'); // let encrypted = cipher.update('some clear text data', 'utf8', 'hex'); // encrypted += cipher.final('hex'); // console.log(encrypted); // Prints: ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504 // Decipher // 使用Decipher对象作为流 // const crypto = require('crypto'); // const decipher = crypto.createDecipher('aes192', 'a password'); // let decrypted = ''; // decipher.on('readable', () => { // const data = decipher.read(); // if (data) decrypted += data.toString('utf8'); // }); // decipher.on('end', () => { // console.log(decrypted); // // Prints: some clear text data // }); // const encrypted = // 'ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504'; // decipher.write(encrypted, 'hex'); // decipher.end(); // 使用Decipher和管道流 // const crypto = require('crypto'); // const fs = require('fs'); // const decipher = crypto.createDecipher('aes192', 'a password'); // const input = fs.createReadStream('test.enc'); // const output = fs.createWriteStream('test.js'); // input.pipe(decipher).pipe(output); // 使用decipher.update()和decipher.final()方法 // const crypto = require('crypto'); // const decipher = crypto.createDecipher('aes192', 'a password'); // const encrypted = // 'ca981be48e90867604588e75d04feabb63cc007a8f8ad89b10616ed84d815504'; // let decrypted = decipher.update(encrypted, 'hex', 'utf8'); // decrypted += decipher.final('utf8'); // console.log(decrypted); // Prints: some clear text data // DiffieHellman // const crypto = require('crypto'); // const assert = require('assert'); // // Generate Alice's keys... // const alice = crypto.createDiffieHellman(2048); // const aliceKey = alice.generateKeys(); // // Generate Bob's keys... // const bob = crypto.createDiffieHellman(alice.getPrime(), alice.getGenerator()); // const bobKey = bob.generateKeys(); // // Exchange and generate the secret... // const aliceSecret = alice.computeSecret(bobKey); // const bobSecret = bob.computeSecret(aliceKey); // // OK // assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex')); // ECDH // const crypto = require('crypto'); // const assert = require('assert'); // // Generate Alice's keys... // const alice = crypto.createECDH('secp521r1'); // const aliceKey = alice.generateKeys(); // // Generate Bob's keys... // const bob = crypto.createECDH('secp521r1'); // const bobKey = bob.generateKeys(); // // Exchange and generate the secret... // const aliceSecret = alice.computeSecret(bobKey); // const bobSecret = bob.computeSecret(aliceKey); // assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex')); // // OK // 使用hash对象作为流 // const crypto = require('crypto'); // const hash = crypto.createHash('sha256'); // hash.on('readable', () => { // const data = hash.read(); // if (data) { // console.log(data.toString('hex')); // // Prints: // // 6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50 // } // }); // hash.write('some data to hash'); // hash.end(); // 使用 Hash 和管道流 // const crypto = require('crypto'); // const fs = require('fs'); // const hash = crypto.createHash('sha256'); // const input = fs.createReadStream('test.js'); // input.pipe(hash).pipe(process.stdout); // 使用hash.update()和hash.digest() // const crypto = require('crypto'); // const hash = crypto.createHash('sha256'); // hash.update('some data to hash'); // console.log(hash.digest('hex')); // Prints: // 6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50 // 使用Hmac对象作为流: // const crypto = require('crypto'); // const hmac = crypto.createHmac('sha256', 'a secret'); // hmac.on('readable', () => { // const data = hmac.read(); // if (data) { // console.log(data.toString('hex')); // // Prints: // // 7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e // } // }); // hmac.write('some data to hash'); // hmac.end(); // 使用hmac.update()和hmac.digest()方法 // const crypto = require('crypto'); // const hmac = crypto.createHmac('sha256', 'a secret'); // hmac.update('some data to hash'); // console.log(hmac.digest('hex')); // 使用“符号”对象作为流: // const crypto = require('crypto'); // const sign = crypto.createSign('SHA256'); // sign.write('some data to sign'); // sign.end(); // const privateKey = getPrivateKeySomehow(); // console.log(sign.sign(privateKey, 'hex')); // console.log(crypto.getHashes()); // [ // 'RSA-MD5', // 'RSA-RIPEMD160', // 'RSA-SHA1', // 'RSA-SHA1-2', // 'RSA-SHA224', // 'RSA-SHA256', // 'RSA-SHA3-224', // 'RSA-SHA3-256', // 'RSA-SHA3-384', // 'RSA-SHA3-512', // 'RSA-SHA384', // 'RSA-SHA512', // 'RSA-SHA512/224', // 'RSA-SHA512/256', // 'RSA-SM3', // 'blake2b512', // 'blake2s256', // 'id-rsassa-pkcs1-v1_5-with-sha3-224', // 'id-rsassa-pkcs1-v1_5-with-sha3-256', // 'id-rsassa-pkcs1-v1_5-with-sha3-384', // 'id-rsassa-pkcs1-v1_5-with-sha3-512', // 'md5', // 'md5-sha1', // 'md5WithRSAEncryption', // 'ripemd', // 'ripemd160', // 'ripemd160WithRSA', // 'rmd160', // 'sha1', // 'sha1WithRSAEncryption', // 'sha224', // 'sha224WithRSAEncryption', // 'sha256', // 'sha256WithRSAEncryption', // 'sha3-224', // 'sha3-256', // 'sha3-384', // 'sha3-512', // 'sha384', // 'sha384WithRSAEncryption', // 'sha512', // 'sha512-224', // 'sha512-224WithRSAEncryption', // 'sha512-256', // 'sha512-256WithRSAEncryption', // 'sha512WithRSAEncryption', // 'shake128', // 'shake256', // 'sm3', // 'sm3WithRSAEncryption', // 'ssl3-md5', // 'ssl3-sha1' // ] // crypto.pbkdf2 // const crypto = require('crypto'); // crypto.pbkdf2('secret', 'salt', 100000, 64, 'sha512', (err, derivedKey) => { // if (err) throw err; // console.log(derivedKey.toString('hex')); // // 3745e482c6e0ade35da10139e797157f4a5da669dad7d5da88ef87e47471cc47ed941c7ad618e827304f083f8707f12b7cfdd5f489b782f10cc269e3c08d59ae // }); // randomBytes Asynchronous // const crypto = require('crypto'); // crypto.randomBytes(256, (err, buf) => { // if (err) throw err; // console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`); // // 256 bytes of random data: 25f6d5add831f01b3ede1995de62dcdaf30a282a1b3a4b9e4a40ab // // 3ae25d68565f7f2c233c5fea5e59eaaf45e42213fa97913070b1bc79f2530b49b7396ad0e3b91e44 // // 7ebe833b9bee2239a5b099e87c3584384ebe695083765504362a64de09eb65db12c5afd997781c83 // // de41ab2bbe37a6a7188e495c09cd47acbaf1e30ce156a0dbae1a4bb8c6dda4edf993dd896c9ac76d // // e08784833c0afaa8e89f509d149e82427af478a867d0a96c68c193b9c98323b0fa96bb61b0205b19 // // 9b6df148e92df066d06e0f8691950054c55e0788c3feb69d6c976e3ebe3c6cdc474732c4017504fc // // aef9b740b786d5eb9834f5e5dadc7e00c5cf8b865a6087610bfdc8aeb6 // }); // Synchronous // const buf = crypto.randomBytes(256); // console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`); // randomFillSync // const crypto = require('crypto'); // const buf = Buffer.alloc(10); // console.log(crypto.randomFillSync(buf).toString('hex')); // // 44c968af68492ff63978 // crypto.randomFillSync(buf, 5); // console.log(buf.toString('hex')); // // 44c968af68fd74439eb2 // // The above is equivalent to the following: // crypto.randomFillSync(buf, 5, 5); // console.log(buf.toString('hex')); // // 44c968af685a9c630117 // randomFill // const crypto = require('crypto'); // const buf = Buffer.alloc(10); // crypto.randomFill(buf, (err, buf) => { // if (err) throw err; // console.log(buf.toString('hex')); // // 83a3fce8f37ea24bd7e8 // }); // crypto.randomFill(buf, 5, (err, buf) => { // if (err) throw err; // console.log(buf.toString('hex')); // // 83a3fce8f37ea24bd7e8 // }); // // The above is equivalent to the following: // crypto.randomFill(buf, 5, 5, (err, buf) => { // if (err) throw err; // console.log(buf.toString('hex')); // // 83a3fce8f37ea24bd7e8 // }); // DNS // const dns = require('dns'); // dns.lookup('nodejs.org', (err, address, family) => { // console.log('IP 地址: %j 地址族: IPv%s', address, family); // }); // const dns = require('dns'); // dns.resolve4('iana.org', (err, addresses) => { // if (err) throw err; // console.log(`IP 地址: ${JSON.stringify(addresses)}`); // addresses.forEach((a) => { // dns.reverse(a, (err, hostnames) => { // if (err) { // throw err; // } // console.log(`IP 地址 ${a} 逆向解析到域名: ${JSON.stringify(hostnames)}`); // }); // }); // }); // const dns = require('dns'); // const resolver = new dns.Resolver(); // resolver.setServers(['4.4.4.4']); // // This request will use the server at 4.4.4.4, independent of global settings. // resolver.resolve4('iana.org', (err, addresses) => { // // ... // }); // resolver.cancel(); // console.log(dns.CANCELLED); // // ECANCELLED // console.log(dns.getServers()); // // [ '192.168.238.1' ] // const dns = require('dns'); // const options = { // family: 6, // hints: dns.ADDRCONFIG | dns.V4MAPPED, // }; // dns.lookup('example.com', options, (err, address, family) => // console.log('address: %j family: IPv%s', address, family) // ); // // address: \"::ffff:93.184.216.34\" family: IPv6 // // When options.all is true, the result will be an Array. // options.all = true; // dns.lookup('example.com', options, (err, addresses) => // console.log('addresses: %j', addresses) // ); // // addresses: [{\"address\":\"::ffff:93.184.216.34\",\"family\":6}] // lookupService // const dns = require('dns'); // dns.lookupService('127.0.0.1', 22, (err, hostname, service) => { // console.log(hostname, service); // // DESKTOP-894BKU0 ssh // }); // dns.resolveCname('www.baidu.com', (err, hostname) => { // console.log(hostname); // // [ 'www.a.shifen.com' ] // }); // dns.resolveMx('google.com', (err, hostname) => { // console.log(hostname); // // [ { exchange: 'smtp.google.com', priority: 10 } ] // }); // dns.resolveNaptr('google.com', (err, hostname) => { // console.log(hostname); // // undefined // }); // dns.resolveSoa('google.com', (err, hostname) => { // console.log(hostname); // // { // // nsname: 'ns1.google.com', // // hostmaster: 'dns-admin.google.com', // // serial: 500503917, // // refresh: 900, // // retry: 900, // // expire: 1800, // // minttl: 60 // // } // }); // dns.resolveSrv('google.com', (err, hostname) => { // console.log(err); // // code: 'ENODATA', // console.log(hostname); // // undefined // }); // dns.resolveTxt('google.com', (err, hostname) => { // console.log(hostname); // [ // [ 'v=spf1 include:_spf.google.com ~all' ], // [ // 'google-site-verification=wD8N7i1JTNTkezJ49swvWW48f8_9xveREV4oB-0Hf5o' // ], // [ 'docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e' ], // [ 'facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95' ], // [ 'onetrust-domain-verification=de01ed21f2fa4d8781cbc3ffb89cf4ef' ], // [ // 'webexdomainverification.8YX6G=6e6922db-e3e6-4a36-904e-a805c28087fa' // ], // [ // 'atlassian-domain-verification=5YjTmWmjI92ewqkx2oXmBaD60Td9zWon9r6eakvHX6B77zzkFQto8PQ9QsKnbf4I' // ], // [ 'apple-domain-verification=30afIBcvSuDV2PLX' ], // [ 'MS=E4A68B9AB2BB9670BCE15412F62916164C0B20BB' ], // [ // 'globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=' // ], // [ // 'google-site-verification=TV9-DBe4R80X4v0M4U_bd_J9cpOJM0nikft0jAgjmsQ' // ], // [ 'docusign=1b0a6754-49b1-4db5-8540-d2c12664b289' ] // ] // }); // dns.resolveAny('google.com', (err, hostname) => { // console.log(hostname); // // [ // // { address: '142.251.43.14', ttl: 526, type: 'A' }, // // { value: 'ns2.google.com', type: 'NS' }, // // { value: 'ns1.google.com', type: 'NS' }, // // { value: 'ns4.google.com', type: 'NS' }, // // { value: 'ns3.google.com', type: 'NS' }, // // { // // entries: [ // // 'google-site-verification=wD8N7i1JTNTkezJ49swvWW48f8_9xveREV4oB-0Hf5o' // // ], // // type: 'TXT' // // }, // // { // // entries: [ 'docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e' ], // // type: 'TXT' // // }, // // { // // entries: [ 'facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95' ], // // type: 'TXT' // // }, // // { // // entries: [ 'onetrust-domain-verification=de01ed21f2fa4d8781cbc3ffb89cf4ef' ] // // , // // type: 'TXT' // // }, // // { // // entries: [ // // 'webexdomainverification.8YX6G=6e6922db-e3e6-4a36-904e-a805c28087fa' // // ], // // type: 'TXT' // // }, // // { // // entries: [ // // 'atlassian-domain-verification=5YjTmWmjI92ewqkx2oXmBaD60Td9zWon9r6eakvHX6B77zzkFQto8PQ9QsKnbf4I' // // ], // // type: 'TXT' // // }, // // { // // entries: [ 'apple-domain-verification=30afIBcvSuDV2PLX' ], // // type: 'TXT' // // }, // // { // // entries: [ 'MS=E4A68B9AB2BB9670BCE15412F62916164C0B20BB' ], // // type: 'TXT' // // }, // // { // // entries: [ // // 'globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=' // // ], // // type: 'TXT' // // }, // // { // // entries: [ // // 'google-site-verification=TV9-DBe4R80X4v0M4U_bd_J9cpOJM0nikft0jAgjmsQ' // // ], // // type: 'TXT' // // }, // // { // // entries: [ 'docusign=1b0a6754-49b1-4db5-8540-d2c12664b289' ], // // type: 'TXT' // // }, // // { entries: [ 'v=spf1 include:_spf.google.com ~all' ], type: 'TXT' } // // ] // }); // dns.reverse('58.221.60.236', (err, hostname) => { // console.log(err); // // code: 'ENOTFOUND' // console.log(hostname); // // undefined // }); // function MyError() { // Error.stackTraceLimit = 2; // // Error.captureStackTrace(this); // Error.captureStackTrace(this, MyError); // } // console.log(new MyError().stack); // const process = require('process'); // var EventEmitter = require('events').EventEmitter; // var life = new EventEmitter(); // function water(who) { // console.log('给 ' + who + ' 倒水'); // } // life.on('Miss', water); // life.on('Miss', function (who) { // // setImmediate(() => { // // console.log('给 ' + who + ' 按摩'); // // }); // process.nextTick(() => { // console.log('给 ' + who + ' 按摩'); // }); // }); // life.on('Miss', function (who) { // console.log('给 ' + who + ' 聊天'); // }); // life.removeListener('Miss', water); // life.emit('Miss', '汉子'); // console.log(life.listeners('Miss').length); // var EventEmitter = require('events').EventEmitter; // var myEmitter = new EventEmitter(); // // let m = 0; // // myEmitter.on('event', () => { // // console.log(++m); // // }); // // myEmitter.emit('event'); // // // 打印: 1 // // myEmitter.emit('event'); // // // 打印: 2 // let m = 0; // myEmitter.once('event', () => { // console.log(++m); // }); // myEmitter.emit('event'); // // 打印: 1 // myEmitter.emit('event'); // // 忽略 // var EventEmitter = require('events').EventEmitter; // var myEmitter = new EventEmitter(); // // 只处理一次，所以不会无限循环 // myEmitter.once('newListener', (event, listener) => { // if (event === 'event') { // // 在开头插入一个新的监听器 // myEmitter.on('event', () => { // console.log('B'); // }); // } // }); // myEmitter.on('event', () => { // console.log('A'); // }); // myEmitter.emit('event'); // // 打印: // // B // // A // const EventEmitter = require('events'); // const myEE = new EventEmitter(); // myEE.on('foo', () => {}); // myEE.on('bar', () => {}); // const sym = Symbol('symbol'); // myEE.on(sym, () => {}); // console.log(myEE.eventNames()); // // [ 'foo', 'bar', Symbol(symbol) ] // const myEE = new EventEmitter(); // myEE.on('foo', () => console.log('a')); // myEE.prependListener('foo', () => console.log('b')); // myEE.emit('foo'); // b // a // const myEE = new EventEmitter(); // myEE.once('foo', () => console.log('a')); // myEE.prependOnceListener('foo', () => console.log('b')); // myEE.emit('foo'); // myEE.emit('foo'); // b // a // const fs = require('fs'); // // fs.appendFile('message.txt', 'data to append', 'utf8', (err) => { // // if (err) throw err; // // console.log('The \"data to append\" was appended to file!'); // // }); // try { // fs.appendFileSync( // 'message.txt', // '/n data to append wfqefqfqfwqefwqf', // 'utf8' // ); // console.log('The \"data to append\" was appended to file!'); // } catch (err) { // /* Handle the error */ // } // const http = require('http'); // const options = { // host: 'nodejs.cn', // }; // const req = http.get(options); // req.end(); // req.once('response', (res) => { // const ip = req.socket.localAddress; // const port = req.socket.localPort; // console.log(`你的IP地址是 ${ip}，你的源端口是 ${port}。`); // // consume response object // }); // console.log(http.METHODS); // [ // 'ACL', 'BIND', 'CHECKOUT', // 'CONNECT', 'COPY', 'DELETE', // 'GET', 'HEAD', 'LINK', // 'LOCK', 'M-SEARCH', 'MERGE', // 'MKACTIVITY', 'MKCALENDAR', 'MKCOL', // 'MOVE', 'NOTIFY', 'OPTIONS', // 'PATCH', 'POST', 'PROPFIND', // 'PROPPATCH', 'PURGE', 'PUT', // 'REBIND', 'REPORT', 'SEARCH', // 'SOURCE', 'SUBSCRIBE', 'TRACE', // 'UNBIND', 'UNLINK', 'UNLOCK', // 'UNSUBSCRIBE' // ] // console.log(http.STATUS_CODES); // { // '100': 'Continue', // '101': 'Switching Protocols', // '102': 'Processing', // '103': 'Early Hints', // '200': 'OK', // '201': 'Created', // '202': 'Accepted', // '203': 'Non-Authoritative Information', // '204': 'No Content', // '205': 'Reset Content', // '206': 'Partial Content', // '207': 'Multi-Status', // '208': 'Already Reported', // '226': 'IM Used', // '300': 'Multiple Choices', // '301': 'Moved Permanently', // '302': 'Found', // '303': 'See Other', // '304': 'Not Modified', // '305': 'Use Proxy', // '307': 'Temporary Redirect', // '308': 'Permanent Redirect', // '400': 'Bad Request', // '401': 'Unauthorized', // '402': 'Payment Required', // '403': 'Forbidden', // '404': 'Not Found', // '405': 'Method Not Allowed', // '406': 'Not Acceptable', // '407': 'Proxy Authentication Required', // '408': 'Request Timeout', // '409': 'Conflict', // '410': 'Gone', // '411': 'Length Required', // '412': 'Precondition Failed', // '413': 'Payload Too Large', // '414': 'URI Too Long', // '415': 'Unsupported Media Type', // '416': 'Range Not Satisfiable', // '417': 'Expectation Failed', // '418': \"I'm a Teapot\", // '421': 'Misdirected Request', // '422': 'Unprocessable Entity', // '423': 'Locked', // '424': 'Failed Dependency', // '425': 'Too Early', // '426': 'Upgrade Required', // '428': 'Precondition Required', // '429': 'Too Many Requests', // '431': 'Request Header Fields Too Large', // '451': 'Unavailable For Legal Reasons', // '500': 'Internal Server Error', // '501': 'Not Implemented', // '502': 'Bad Gateway', // '503': 'Service Unavailable', // '504': 'Gateway Timeout', // '505': 'HTTP Version Not Supported', // '506': 'Variant Also Negotiates', // '507': 'Insufficient Storage', // '508': 'Loop Detected', // '509': 'Bandwidth Limit Exceeded', // '510': 'Not Extended', // '511': 'Network Authentication Required' // } // console.log(__filename); // // C:\\Users\\xxx\\source\\nodejs\\file\\test.js // console.log(__dirname); // // C:\\Users\\xxx\\source\\nodejs\\file // import fs, { readFileSync } from 'node:fs'; // import { syncBuiltinESMExports } from 'node:module'; // import { Buffer } from 'node:buffer'; // fs.readFileSync = () => Buffer.from('Hello, ESM'); // syncBuiltinESMExports(); // console.log(fs.readFileSync === readFileSync); // // true // import os from 'node:os'; // console.log(os.platform()); // // win32 // console.log(os.release()); // // 10.0.19044 // console.log(os.EOL); // // \\r\\n // console.log(os.arch()); // // x64 // console.log(os.tmpdir()); // // C:\\Users\\sunji\\AppData\\Local\\Temp // console.log(os.totalmem()); // // 8424386560 // console.log(os.type()); // // Windows_NT // console.log(os.uptime()); // 334498 // console.log(os.userInfo()); // console.log(os.version()); // import { report } from 'process'; // console.log(report); // console.log(report.writeReport('../testReport.json')); // console.log(report.resourceUsage()); // import process from 'node:process'; // if (process.getegid && process.setegid) { // console.log(`Current gid: ${process.getegid()}`); // try { // process.setegid(501); // console.log(`New gid: ${process.getegid()}`); // } catch (err) { // console.log(`Failed to set gid: ${err}`); // } // } // console.log(process.title); // C:\\Windows\\System32\\cmd.exe - node test.js // process.title = 'qwer'; // console.log(process.title); // qwer // console.log(process.uptime()); // // 0.0754413 // console.log(process.version); // // v18.12.1 // console.log(process.versions.node); // // 18.12.1 // console.log(process.versions); // { // node: '18.12.1', // v8: '10.2.154.15-node.12', // uv: '1.43.0', // zlib: '1.2.11', // brotli: '1.0.9', // ares: '1.18.1', // modules: '108', // nghttp2: '1.47.0', // napi: '8', // llhttp: '6.0.10', // openssl: '3.0.7+quic', // cldr: '41.0', // icu: '71.1', // tz: '2022b', // unicode: '14.0', // ngtcp2: '0.8.1', // nghttp3: '0.7.0' // } // import readline from 'node:readline'; // import process from 'node:process'; // var rl = readline.createInterface(process.stdin, process.stdout); // // rl.setPrompt('Test'); // // rl.prompt(); // // rl.question('What is your favorite food? ', (answer) => { // // console.log(`Oh, so your favorite food is ${answer}`); // // process.exit(0); // // }); // const ac = new AbortController(); // const signal = ac.signal; // rl.question('What is your favorite food? ', { signal }, (answer) => { // console.log(`Oh, so your favorite food is ${answer}`); // }); // signal.addEventListener( // 'abort', // () => { // console.log('The food question timed out'); // }, // { once: true } // ); // setTimeout(() => ac.abort(), 10000); // import test from 'node:test'; // import assert from 'assert'; // test('top level test', async (t) => { // await t.test('subtest 1', (t) => { // assert.strictEqual(1, 1); // }); // await t.test('subtest 2', (t) => { // assert.strictEqual(2, 2); // }); // }); // test('top level test', { skip: true }, (t) => { // assert.strictEqual(1, 1); // }); // test('top level test', { skip: 'skip message' }, (t) => { // assert.strictEqual(1, 1); // }); // test('top level test', (t) => { // assert.strictEqual(1, 1); // t.skip(); // assert.strictEqual(2, 2); // }); // test('top level test', (t) => { // assert.strictEqual(1, 1); // t.skip('skip message'); // assert.strictEqual(2, 2); // }); // import test from 'node:test'; // import assert from 'node:assert'; // describe('test parent', () => { // it('first test', () => { // assert.strictEqual(1, 1); // }); // it('second test', () => { // assert.strictEqual(2, 2); // }); // describe('child test', () => { // it('grand test', () => { // assert.strictEqual(3, 3); // }); // }); // }); // describe('test parent', { only: true }, () => { // it('first test', () => { // assert.strictEqual(1, 1); // }); // it('second test', async (t) => { // assert.strictEqual(2, 2); // }); // describe('child test', () => { // it('grand test', () => { // assert.strictEqual(3, 3); // }); // }); // }); // describe('qwe123', () => { // it('first test', () => { // assert.strictEqual(1, 1); // }); // it('second test', () => { // assert.strictEqual(2, 2); // }); // describe('child test', () => { // it('grand test', () => { // assert.strictEqual(3, 3); // }); // }); // }); // test('this test is run', { only: true }, async (t) => { // // 在此测试中，默认运行所有子测试。 // await t.test('running subtest'); // // 可以使用 'only' 选项更新测试上下文以运行子测试。 // t.runOnly(true); // await t.test('this subtest is now skipped'); // await t.test('this subtest is run', { only: true }); // // 切换上下文以执行所有测试。 // t.runOnly(false); // await t.test('this subtest is now run'); // // 显式地不要运行这些测试。 // await t.test('skipped subtest 3', { only: false }); // await t.test('skipped subtest 4', { skip: true }); // }); // // 未设置 'only' 选项，因此跳过此测试。 // test('this test is not run', () => { // // 此代码未运行。 // throw new Error('fail'); // }); // test('a test that creates asynchronous activity', (t) => { // setImmediate(() => { // t.test('subtest that is created too late', (t) => { // throw new Error('error1'); // }); // }); // setImmediate(() => { // throw new Error('error2'); // }); // // 此行之后测试结束。 // }); // import url from 'node:url'; // console.log(url.URL === globalThis.URL); // const myURL = new URL('https://example.org:8888'); // console.log(myURL.port); // // 打印 8888 // // 默认端口自动转换为空字符串 // //（HTTPS 协议的默认端口是 443） // myURL.port = '443'; // console.log(myURL.port); // // 打印空字符串 // console.log(myURL.href); // // 打印 https://example.org/ // myURL.port = 1234; // console.log(myURL.port); // // 打印 1234 // console.log(myURL.href); // // 打印 https://example.org:1234/ // // 完全无效的端口字符串被忽略 // myURL.port = 'abcd'; // console.log(myURL.port); // // 打印 1234 // // 前导数字被视为端口号 // myURL.port = '5678abcd'; // console.log(myURL.port); // // 打印 5678 // // 非整数被截断 // myURL.port = 1234.5678; // console.log(myURL.port); // // 打印 1234 // // 未用科学计数法表示的超出范围的数字将被忽略。 // myURL.port = 1e10; // 10000000000，将按如下所述进行范围检查 // console.log(myURL.port); // // 打印 1234 // myURL.port = 4.567e21; // console.log(myURL.port); // // 打印 4（因为它是字符串 '4.567e21' 中的前导数字） // const u = new URL('http://example.org'); // u.protocol = 'https'; // console.log(u.href); // https://example.org // const u = new URL('http://example.org'); // u.protocol = 'fish'; // console.log(u.href); // http://example.org // const u = new URL('fish://example.org'); // u.protocol = 'http'; // console.log(u.href); // fish://example.org // const myURLs = [ // new URL('https://www.example.com'), // new URL('https://test.example.org'), // ]; // console.log(JSON.stringify(myURLs)); // console.log(new URL('https://www.example.com').toJSON()); // let params; // // 使用数组 // params = new URLSearchParams([ // ['user', 'abc'], // ['query', 'first'], // ['query', 'second'], // ]); // console.log(params.toString()); // // 打印 'user=abc&query=first&query=second' // // 使用 Map 对象 // const map = new Map(); // map.set('user', 'abc'); // map.set('query', 'xyz'); // params = new URLSearchParams(map); // console.log(params.toString()); // // 打印 'user=abc&query=xyz' // // 使用生成器函数 // function* getQueryPairs() { // yield ['user', 'abc']; // yield ['query', 'first']; // yield ['query', 'second']; // } // params = new URLSearchParams(getQueryPairs()); // console.log(params.toString()); // // 打印 'user=abc&query=first&query=second' // // 每个键值对必须恰好有两个元素 // param = new URLSearchParams([['user', 'abc', 'error']]); // console.log(params.toString()); // // 抛出 TypeError [ERR_INVALID_TUPLE]: // // Each query pair must be an iterable [name, value] tuple import { urlToHttpOptions } from 'node:url'; const myURL = new URL('https://a:b@測試?abc#foo'); console.log(urlToHttpOptions(myURL));"}],"posts":[{"title":"关于github个人博客使用giscus作为评论系统的操作说明","slug":"62-about-giscus","date":"2024-03-28T06:05:44.000Z","updated":"2024-03-28T07:35:50.263Z","comments":true,"path":"2024/03/28/62-about-giscus/","link":"","permalink":"https://sunjinkang.github.io/2024/03/28/62-about-giscus/","excerpt":"说明本人使用github搭建个人博客，博客框架为Hexo(5.4.2)，博客主题为Volantis(5.8.0)。为了便于使用，接入了Giscus作为评论系统。本篇文章主要说明接入Giscus的具体操作。 步骤一 建一个公共库由于Giscus使用github的discussion作为评论数据存放地，所以使用Giscus需要先建一个github的公共仓库，仓库名称可根据自己的需要进行设置。本文中评论的仓库名为comments。 除了要求是个公共库之外，是否需要README、gitignore无具体要求","text":"说明本人使用github搭建个人博客，博客框架为Hexo(5.4.2)，博客主题为Volantis(5.8.0)。为了便于使用，接入了Giscus作为评论系统。本篇文章主要说明接入Giscus的具体操作。 步骤一 建一个公共库由于Giscus使用github的discussion作为评论数据存放地，所以使用Giscus需要先建一个github的公共仓库，仓库名称可根据自己的需要进行设置。本文中评论的仓库名为comments。 除了要求是个公共库之外，是否需要README、gitignore无具体要求 开启公共库的discussion功能 公共库 -&gt; Settings -&gt; General -&gt; Features -&gt; 勾选discussion 步骤二 公共库安装Giscus前往这里，点击 Install 安装Giscus 选择创建的公共库，将公共库与Giscus关联起来 步骤三 Giscus官网配置前往 Giscus官网，进行配置。仓库名有三个前置条件，如果按照本文顺序进行安装，这里的检查会通过，否则会报错。如果报错了，请检查一下之前的配置是不是有哪里配置错了。 可以根据自己的需要选择，本文默认选了第一个。 选择 Announcements 类型即可，官方也是这样推荐的，因为这样便于管理。 其他的配置使用默认配置就好。 在你想出现评论的位置添加上面的 &lt;/script/&gt; 标签。但如果已经存在带有giscus类的元素，则评论会被放在那里。将上面标签中的数据填入项目中giscus配置的对应位置。 12345678910giscus: # 以下配置按照 yml 格式增删填写即可 repo: #data-repo repo-id: #data-repo-id category: #data-category category-id: #data-category-id mapping: &quot;pathname&quot; reactions-enabled: &quot;1&quot; emit-metadata: &quot;0&quot; lang: &quot;zh-CN&quot; 以上配置完成后，理论上项目中就可以使用评论系统了。 登录后，输入评论，可以查看公共库的discussion中是否有对应的评论可以看到，博客中的评论在github的公共仓库中也存在，配置Giscus的评论系统成功！","categories":[],"tags":[{"name":"blog, giscus","slug":"blog-giscus","permalink":"https://sunjinkang.github.io/tags/blog-giscus/"}]},{"title":"关于docker的使用问题","slug":"61-about-docker-command","date":"2024-01-29T08:10:54.000Z","updated":"2024-03-28T09:18:33.258Z","comments":true,"path":"2024/01/29/61-about-docker-command/","link":"","permalink":"https://sunjinkang.github.io/2024/01/29/61-about-docker-command/","excerpt":"问题：删除docker网络，报错存在active endpoints例如： while removing network: network docker_dms_net id ec0611ba3525 has active endpoints 解决方法：第一种：重启docker 1sudo service docker restart 第二种： 查看docker的网络 1docker network ls 查看网络的endpoint, 停止使用网络的container 123456789101112131415docker network inspect &lt;network-id&gt;// container-id 是Containers下对应的数据// 例如：// &quot;Containers&quot;: &#123;// &quot;6bcc2418b08f9e1446053ab2e95bda066ec79bcbb0bd200c5e5110dc9bc637a3&quot;: &#123;// &quot;Name&quot;: &quot;dms-mysql-2&quot;,// &quot;EndpointID&quot;: &quot;75b980a5ad52734eccf237b9bcef0b5c1b2b1426274326eb317d006aceac3eff&quot;,// &quot;MacAddress&quot;: &quot;02:42:ac:1f:86:03&quot;,// &quot;IPv4Address&quot;: &quot;172.31.134.3/24&quot;,// &quot;IPv6Address&quot;: &quot;&quot;// &#125;// &#125;// container-id为：6bcc2418b08f9e1446053ab2e95bda066ec79bcbb0bd200c5e5110dc9bc637a3docker container stop &lt;container-id&gt;","text":"问题：删除docker网络，报错存在active endpoints例如： while removing network: network docker_dms_net id ec0611ba3525 has active endpoints 解决方法：第一种：重启docker 1sudo service docker restart 第二种： 查看docker的网络 1docker network ls 查看网络的endpoint, 停止使用网络的container 123456789101112131415docker network inspect &lt;network-id&gt;// container-id 是Containers下对应的数据// 例如：// &quot;Containers&quot;: &#123;// &quot;6bcc2418b08f9e1446053ab2e95bda066ec79bcbb0bd200c5e5110dc9bc637a3&quot;: &#123;// &quot;Name&quot;: &quot;dms-mysql-2&quot;,// &quot;EndpointID&quot;: &quot;75b980a5ad52734eccf237b9bcef0b5c1b2b1426274326eb317d006aceac3eff&quot;,// &quot;MacAddress&quot;: &quot;02:42:ac:1f:86:03&quot;,// &quot;IPv4Address&quot;: &quot;172.31.134.3/24&quot;,// &quot;IPv6Address&quot;: &quot;&quot;// &#125;// &#125;// container-id为：6bcc2418b08f9e1446053ab2e95bda066ec79bcbb0bd200c5e5110dc9bc637a3docker container stop &lt;container-id&gt; 停止所有使用network的container之后，删除network即可。如果存在其他报错，建议google一下","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://sunjinkang.github.io/tags/docker/"}]},{"title":"关于shadow dom及如何创建一个shadow dom","slug":"60-about-shadow-dom","date":"2024-01-06T03:20:34.000Z","updated":"2024-01-26T01:42:14.058Z","comments":true,"path":"2024/01/06/60-about-shadow-dom/","link":"","permalink":"https://sunjinkang.github.io/2024/01/06/60-about-shadow-dom/","excerpt":"什么是Shadow Dom？ 一种连接节点的树状结构，代表标记文档（通常是在 web 文档中的 HTML 文档）中出现的不同元素和文本字符串。 浏览器渲染文档的时候会给指定的DOM结构插入编写好的DOM元素，但是插入的Shadow DOM 会与主文档的DOM保持分离，也就是说Shadow DOM不存在于主DOM树上。并且Shadow DOM封装出来的DOM元素是独立的，外部的配置不会影响到内部，内部的配置也不会影响外部。 Chrome中查看Shadow Dom1.打开浏览器控制台的设置选项2.找到Preference -&gt; Elements，把show user anent shadow dom勾上 Shadow Dom的结构","text":"什么是Shadow Dom？ 一种连接节点的树状结构，代表标记文档（通常是在 web 文档中的 HTML 文档）中出现的不同元素和文本字符串。 浏览器渲染文档的时候会给指定的DOM结构插入编写好的DOM元素，但是插入的Shadow DOM 会与主文档的DOM保持分离，也就是说Shadow DOM不存在于主DOM树上。并且Shadow DOM封装出来的DOM元素是独立的，外部的配置不会影响到内部，内部的配置也不会影响外部。 Chrome中查看Shadow Dom1.打开浏览器控制台的设置选项2.找到Preference -&gt; Elements，把show user anent shadow dom勾上 Shadow Dom的结构 Shadow DOM术语Shadow host: Shadow DOM 附加到的常规 DOM 节点。Shadow tree: Shadow DOM 内部的 DOM 树。Shadow boundary: Shadow DOM 终止，常规 DOM 开始的地方。Shadow root: Shadow tree的根节点。 Shadow DOM的作用及如何创建Shadow DOM？作用Shadow DOM是独立于DOM树的，外部的样式不会影响到Shadow DOM的内部，并且使用一般的javascript操作dom的方式去操作Shadow DOM，都是不生效的。这种良好的密封性，使得Shadow DOM可以用于创建类似video这类的标签，方便开发。 如何创建Shadow DOM？ 使用attachShadow给指定元素挂载一个shadow dom，并且返回对shadow root的引用。 12345678910// html&lt;div id=&quot;first&quot;&gt;&lt;/div&gt;&lt;span&gt;第一个例子&lt;/span&gt;&lt;div id=&quot;total&quot;&gt;&lt;/div&gt;// jsconst firstParent = document.getElementById(&#x27;first&#x27;);const shadow = firstParent.attachShadow(&#123; mode: &#x27;open&#x27; &#125;);const span = document.createElement(&#x27;span&#x27;);span.textContent = &#x27;Shadow DOM&#x27;;shadow.appendChild(span); Shadow DOM mode使用attachShadow()方法，必须传递一个对象作为参数来指定shadow DOM树的封装模式，否则将会抛出一个TypeError。该对象必须具有mode属性，值为 open 或 closed。 openshadow root 元素可以从 js 外部访问根节点，例如使用 shadowRoot: 12const shadowSpan = firstParent.shadowRoot?.querySelectorAll(&#x27;span&#x27;);// shadowRoot 返回一个 ShadowRoot 对象 closed拒绝从 js 外部访问关闭的 shadow root 节点, shadowRoot 返回 null 可以挂载Shadow DOM的标签 注意：如果将Shadow DOM挂载到不可挂载标签上，挂载会失败，控制台会报错。 Shadow DOM特点 外部的样式不影响Shadow DOM内部Shadow DOM是游离在 DOM 树之外的节点树，所以文档上的CSS不会作用在他身上 在MDN上提到了两种方式可以修改Shadow DOM的样式，感兴趣的可以自己去看看：https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components/Using_shadow_DOM#%E5%9C%A8%E5%BD%B1%E5%AD%90_dom_%E5%86%85%E5%BA%94%E7%94%A8%E6%A0%B7%E5%BC%8F 这里给Shadow DOM添加样式使用的是第二种： 12345678910111213141516171819202122232425262728293031// html&lt;div id=&quot;third&quot;&gt;&lt;/div&gt;&lt;span&gt;第三个例子&lt;/span&gt;// jsconst thirdParent = document.getElementById(&#x27;third&#x27;);const shadow3 = thirdParent.attachShadow(&#123; mode: &#x27;open&#x27; &#125;);const span3 = document.createElement(&#x27;span&#x27;);// 使用class的方式设置样式span3.innerHTML = ` &lt;div class=&quot;text&quot;&gt;Shadow DOM3&lt;/div&gt; &lt;style&gt; .text &#123; border: 1px solid #ccc; color: pink; &#125; &lt;/style&gt;`;// 使用伪类host设置样式span3.innerHTML = ` &lt;div&gt;Shadow DOM3&lt;/div&gt; &lt;style&gt; :host &#123; border: 1px solid #ccc; color: pink; &#125; &lt;/style&gt;`;shadow3.appendChild(span3); 样式钩子shadow dom还有一个非常重要的一个特点就是可以使用CSS自定义属性来创建样式占位符，并允许用户填充。 1234567891011121314151617181920212223// html&lt;div id=&quot;third&quot;&gt;&lt;/div&gt;&lt;span&gt;第三个例子&lt;/span&gt;// style#third &#123; --color: red;&#125;// jsconst thirdParent = document.getElementById(&#x27;third&#x27;);const shadow3 = thirdParent.attachShadow(&#123; mode: &#x27;open&#x27; &#125;);const span3 = document.createElement(&#x27;span&#x27;);span3.innerHTML = ` &lt;div class=&quot;text&quot;&gt;Shadow DOM3&lt;/div&gt; &lt;style&gt; .text &#123; border: 1px solid #ccc; color: var(--color); &#125; &lt;/style&gt;`; 使用伪类修改Shadow DOM的内部样式 1234567891011121314// styleinput[placeholder=&#x27;user&#x27;]::-webkit-input-placeholder &#123; color: red; font-size: 18px;&#125;// html&lt;input placeholder=&quot;user&quot; class=&quot;user&quot; name=&quot;user&quot; type=&quot;text&quot; /&gt;&lt;input placeholder=&quot;password&quot; class=&quot;password&quot; name=&quot;password&quot; type=&quot;text&quot;/&gt;","categories":[],"tags":[]},{"title":"关于原子CSS引擎 -- unocss","slug":"59-about-unocss","date":"2024-01-06T02:23:11.000Z","updated":"2024-01-19T06:51:05.910Z","comments":true,"path":"2024/01/06/59-about-unocss/","link":"","permalink":"https://sunjinkang.github.io/2024/01/06/59-about-unocss/","excerpt":"前言unocss是一个即时的原子CSS引擎，它可以让你用简短的类名来控制元素的样式，而不需要写复杂的CSS代码。之前有分享提到过Tailwind，不知道大家是否还记得，Tailwind就是一种原子化的CSS框架。 原子化CSS是一种CSS架构方式，其支持小型、单一用途的类，其名称基于视觉功能。更加通俗的来讲，原子化CSS是一种新的CSS编程思路，它倾向于创建小巧且单一用途的class，并且以视觉效果进行命名。 优点它可以让你快速地开发和原型设计，而不需要考虑CSS的细节。它可以让你的CSS文件更小，因为它只生成你用到的工具类。它可以让你的CSS更一致，因为它遵循一套预设的规则和变量。它可以让你的CSS更灵活，因为它支持自定义工具类，变体，指令和图标。它可以让你的CSS更易于维护，因为它避免了样式冲突和重复代码。","text":"前言unocss是一个即时的原子CSS引擎，它可以让你用简短的类名来控制元素的样式，而不需要写复杂的CSS代码。之前有分享提到过Tailwind，不知道大家是否还记得，Tailwind就是一种原子化的CSS框架。 原子化CSS是一种CSS架构方式，其支持小型、单一用途的类，其名称基于视觉功能。更加通俗的来讲，原子化CSS是一种新的CSS编程思路，它倾向于创建小巧且单一用途的class，并且以视觉效果进行命名。 优点它可以让你快速地开发和原型设计，而不需要考虑CSS的细节。它可以让你的CSS文件更小，因为它只生成你用到的工具类。它可以让你的CSS更一致，因为它遵循一套预设的规则和变量。它可以让你的CSS更灵活，因为它支持自定义工具类，变体，指令和图标。它可以让你的CSS更易于维护，因为它避免了样式冲突和重复代码。 unocss的安装和使用unocss官网：https://unocss.dev/ unocss的安装(支持pnpm/yarn/npm)： pnpm add -D unocss 在Vite中使用unocssunocss支持多种打包工具，这里仅以vite进行介绍，其他的方式可以查看官方文档。 1234567891011121314151617181920// 在vite配置文件中引入unocss// vite.config.tsimport UnoCSS from &#x27;unocss/vite&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;export default defineConfig(&#123; plugins: [ UnoCSS(), ],&#125;)// 新建 uno.config.ts 文件import &#123; defineConfig &#125; from &#x27;unocss&#x27;export default defineConfig(&#123; // ...UnoCSS options&#125;)// 全局引入import &#x27;virtual:uno.css&#x27; 在Vite中使用unocss时，支持设置不同的mode： global(默认)在这种模式下，需要在项目入口文件中添加 uno.css 的引入，同时这种模式支持热更新，生成的css样式会注入到index.html文件中。 vue-scoped将生成的css注入 svelte-scopedg该模式已移入对应的svelte-scoped包中 shadow-dom per-module (实验性的)为每个模块生成对应的css样式 dist-chunk (实验性的)为每个build的chunk文件生成css，对多页面应用更友好 react+unocss 12345678910// vite.config.jsimport UnoCSS from &#x27;unocss/vite&#x27;import React from &#x27;@vitejs/plugin-react&#x27;export default &#123; plugins: [ React(), UnoCSS(), ],&#125; 注意： 如果项目中使用了 @unocss/preset-attributify，需要把 tsc 从build命令中去除 如果项目中同时使用了 @vitejs/plugin-react 和 @unocss/preset-attributify，引入unocss插件的位置要放在 @vitejs/plugin-react 前面12345678910// vite.config.jsimport UnoCSS from &#x27;unocss/vite&#x27;import React from &#x27;@vitejs/plugin-react&#x27;export default &#123; plugins: [ UnoCSS(), React(), ],&#125; preset Presets是UnoCSS的核心功能，能够让开发更便利 12345678910// uno.config.tsimport &#123; defineConfig, presetAttributify, presetUno &#125; from &#x27;unocss&#x27;export default defineConfig(&#123; presets: [ presetAttributify(&#123; /* preset options */&#125;), presetUno(), // ...custom presets ],&#125;) 注意：如果presets的选项设置了具体值，默认preset会自动忽略。同时可以通过空数组的方式禁用默认preset。 123456789// uno.config.tsimport &#123; defineConfig &#125; from &#x27;unocss&#x27;export default defineConfig(&#123; presets: [], // disable default preset rules: [ // your custom rules ],&#125;) 官方提供的preset包：https://unocss.dev/presets/设置提供的preset包：https://unocss.dev/presets/community 定义自己的preset 1234567891011121314151617181920212223import &#123; Preset, definePreset &#125; from &#x27;unocss&#x27;export default definePreset((options?: MyPresetOptions) =&gt; &#123; return &#123; name: &#x27;my-preset&#x27;, rules: [ // ... ], variants: [ // ... ], &#125;&#125;)// uno.config.tsimport &#123; defineConfig &#125; from &#x27;unocss&#x27;import myPreset from &#x27;./my-preset&#x27;export default defineConfig(&#123; presets: [ myPreset(&#123; /* preset options */ &#125;), ],&#125;) 注意：规则名相同时，后面的会覆盖前面的规则。 具体使用刚入手 unocss 不知道怎么写规则，可以参考官方（大佬 antfu）给出的 交互式文档，输入你想要的css样式，就可以获得对应的class名称 https://unocss.dev/interactive/ 用法基础使用：可以依据自身需要，添加对应的class 自定义规则： 自定义类123456789import &#123; defineConfig &#125; from &#x27;unocss&#x27;;export default defineConfig(&#123; rules: [ [&#x27;w-10&#x27;, &#123; width: &#x27;10px&#x27; &#125;] [/^h-(\\d)$/, ([, d]) =&gt; (&#123; height: `$&#123;d&#125;px` &#125;)], ],&#125;); 静态快捷方式12345678import &#123; defineConfig &#125; from &#x27;unocss&#x27;;export default defineConfig(&#123; shortcuts: [ &#123; &#x27;flex-center&#x27;: &#x27;flex items-center justify-center&#x27; &#125;, ],&#125;); 动态快捷方式1234567891011import &#123; defineConfig &#125; from &#x27;unocss&#x27;;export default defineConfig(&#123; shortcuts: [ [ /^base-border-(.*)$/, (match) =&gt; `border-1 border-style-dashed border-$&#123;match[1]&#125;`, ], ],&#125;); vscode插件unocss有自己的vscode插件：UnoCSS unocss插件支持提示 页面上使用 unocss 提供的 class 带有虚线，并且能显示类名对应的样式内容","categories":[],"tags":[]},{"title":"diff算法 -- 快速对比","slug":"58-quick-contrast","date":"2023-11-14T11:51:24.000Z","updated":"2023-12-25T03:01:08.678Z","comments":true,"path":"2023/11/14/58-quick-contrast/","link":"","permalink":"https://sunjinkang.github.io/2023/11/14/58-quick-contrast/","excerpt":"前言 前面我们说了diff算法里面的双端对比，主要是在vue2中使用。但在vue3中，使用了另一种比双端diff更快的算法 – 快速diff，今天我们来看一下快速diff的使用方式。 快速diff的使用场景 预处理前置节点 预处理后置节点 仅有新增节点 仅有卸载节点 新增、卸载、移动节点 仅从上面这五种场景的字面意思上面我们大概能看出它们对应的处理情况，下面我们来看一下，每种场景具体的处理逻辑是怎么样的。（PS：为了便于理解，本文中的节点仅用数字表示）","text":"前言 前面我们说了diff算法里面的双端对比，主要是在vue2中使用。但在vue3中，使用了另一种比双端diff更快的算法 – 快速diff，今天我们来看一下快速diff的使用方式。 快速diff的使用场景 预处理前置节点 预处理后置节点 仅有新增节点 仅有卸载节点 新增、卸载、移动节点 仅从上面这五种场景的字面意思上面我们大概能看出它们对应的处理情况，下面我们来看一下，每种场景具体的处理逻辑是怎么样的。（PS：为了便于理解，本文中的节点仅用数字表示） 预处理前置节点与预处理后置节点 从上图我们可以看到，分别有一个新子节点的组和一个旧子节点的组，我们指定一个变量j来代表当前的索引值。 预处理前置节点就是表示j从0开始处理当前的两个子节点组，从索引0开始分别对比新旧子节点组，相同的时候不做处理（本文中由于节点元素均为数字所以不做处理，实际使用算法时，根据情况做处理，比如更新旧节点）。索引加1，对比下一索引的节点，从上图里面看，下一索引位置的节点不同，所以前置节点的预处理结束。 预处理前置节点对比完之后进行预处理后置节点的对比，我们设置newEndIdx和oldEndIdx分别对应新旧子节点组的末尾索引，获取对应位置的子节点进行对比，如果相同，newEndIdx和oldEndIdx就减1，指向前一位继续对比，直到对应位置的子节点不相同。 从上面这个图可以看出来，当我们经过预处理前置节点和预处理后置节点这两步之后，明显新节点组还剩余一个4，旧节点组已经对比完了，所以我们引入下一种场景：仅有新增节点. vue3源码 仅有新增节点仅有新增的节点，我们实际上只需要把节点添加到对应位置去即可，从上一步来看，就是新节点组最后对比的不相同的节点的位置，也就是说放在newEndIdx的位置。对应到真实场景中，比如dom的处理时，是需要把新的节点挂载到newEndIdx+1上去，即newEndIdx+1的位置作为锚点。 上图中就是新节点组中的4，把它加到旧节点组的对应位置之后，对比就完成了，新旧两个节点组就一样了。 仅有卸载节点仅有卸载节点，就是指，新节点组对比结束了，没有剩余未对比的元素，而旧节点组还有为对比的节点，即剩余的节点在新节点组中不存在，所以直接删除即可，即卸载dom节点。 新增、卸载、移动节点这种场景较为复杂，我们先从容易的动手，先删除后续不会用到的旧虚拟节点，比如上图的6，下面我们看一下怎么找到6这个位置的节点。 做法是构建一个新虚拟节点的key与其下标的映射，然后遍历未处理的旧虚拟节点数组，使其每一项访问前面映射的key得出其value，如果value是undefined就证明该虚拟节点在新虚拟节点数组中没有出现，需要删除。 删除用不到的节点之后，剩下可能的就是“移动”和“创建”两种操作。 vue3是利用“最长递增算法”求出最长递增序列，不满足最长递增子序列的节点就是需要移动的节点。下面我们来看一下什么是最长递增子序列以及应该怎么使用达到我们的目的。 最长递增子序列什么是最长递增子序列?以数组每一项为开头，在数组中从前往后对比，前一项要比后一项小（即呈递增趋势），相等也不行，把找到的数拿出来构建的数组叫递增子序列，而“最长递增子序列”则是这些子序列中最长的那个。我们假定有数组【5,1,6,8,10】，那么它的最长递增子序列就是【5,6,8,10】和【1,6,8,10】 查找最长递增子序列查找最长递增子序列的方法有很多种，比如从后往前查找，前一项比当前项小时，子序列长度加1，如果前一项比当前项大或等于当前项时，再将前一项与当前项之后的每一项进行比较，直到数组比较结束。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const seq = [5, 1, 6, 8, 10]function lis(seq) &#123; const valueToMax = &#123;&#125; let len = seq.length // 先构建格子，1填充 for (let i = 0; i &lt; len; i++) &#123; valueToMax[seq[i]] = 1 &#125; let i = len - 1 //最后 let last = seq[i] let prev = seq[i - 1] // prev才是当前比较基值。 跳过最后一个，直接从倒数第二个开始比较，因为最后一个一定是1 while (typeof prev !== &#x27;undefined&#x27;) &#123; // 从后往前，两两比较 let j = i // 后值的下标 while (j &lt; len) &#123; last = seq[j] if (prev &lt; last) &#123; // 当前值比后面的值小 const currentMax = valueToMax[last] + 1 // 记录此时比较下的最大值，即后面值的最长子序列长度+1 if (currentMax &gt; valueToMax[prev]) &#123; /* 比较两个值的最长子序列长度， 如果 “后面值的子序列长度+1” 后比 当前值的子序列 长， 那么当前子序列长度重新赋值，取大的。 */ valueToMax[prev] = currentMax &#125; // valueToMax[prev] =valueToMax[prev] !== 1 ? valueToMax[prev] &gt; currentMax ? valueToMax[prev] : currentMax : currentMax &#125; j++ &#125; i-- last = seq[i] prev = seq[i - 1] &#125; const lis = [] i = 1 while (--len &gt;= 0) &#123; // 从后往前找，1 -&gt; 2 -&gt; 3... const n = seq[len] if (valueToMax[n] === i) &#123; i++ lis.unshift(len) &#125; &#125; return lis&#125; console.log(lis(seq)) //得到的序列中的位置索引 最长递增子序列的使用我们为了便于说明，拿上面的第二张图来举例，上述四种场景的比较之后，我们得到了一个新旧节点之间的映射关系，目前新节点的元素是【6,4,5,8】,我们可以得到映射关系是【6,4,5,0】这个新数组的最长递增子序列是【1,2】,接下来，我们只需要从后往前一次做对比即可。 我们定义变量 i 记录位置，定义变量 j，记录最长递增子序列的位置，初始化为 1， 当 i = 3 时，位置值为 0，对应节点为 8，说明 8 是新增节点，直接挂载； 当 i = 2 时，位置值为 5，对应节点为 5，i = 2 处于最长递增子序列 j = 1 处， 因此无需移动直接跳过。一旦找到最长递增子序列元素，i 和 j 需同时往上移动； 当 i = 1 时，位置值为 4，对应节点为 5，i = 1 处于最长递增子序列当中 j = 0 处，因此无需移动直接跳过。i 和 j 同时再往上移动； 当 i = 0 时，位置值为 6，对应节点为 6，i = 0 不处于最长递增子序列中，因此该节点需要移动。 上述步骤执行结束后，可以看到旧节点已变更为新节点，变更结束。","categories":[],"tags":[]},{"title":"diff算法 -- 双端对比","slug":"57-double-end-contrast","date":"2023-11-09T05:27:17.000Z","updated":"2023-12-25T03:01:08.678Z","comments":true,"path":"2023/11/09/57-double-end-contrast/","link":"","permalink":"https://sunjinkang.github.io/2023/11/09/57-double-end-contrast/","excerpt":"前言 diff算法，全称为difference算法，是一种用于比较和查找文本、源代码或任何字符串之间差异的算法。前端中在react、vue等中使用diff算法对比虚拟DOM树，进行虚拟DOM树的更新，进而完成真实DOM的更新，达到更新页面的效果。在vue2中使用的就是双端diff算法。 什么是双端对比？ 双端对比，即双端diff算法，一种同时对新旧两组子节点的两个端点进行比较的算法。但就从上面这句话来看，可能有点抽象，可参考下面这张图片 双端对比的简单实现","text":"前言 diff算法，全称为difference算法，是一种用于比较和查找文本、源代码或任何字符串之间差异的算法。前端中在react、vue等中使用diff算法对比虚拟DOM树，进行虚拟DOM树的更新，进而完成真实DOM的更新，达到更新页面的效果。在vue2中使用的就是双端diff算法。 什么是双端对比？ 双端对比，即双端diff算法，一种同时对新旧两组子节点的两个端点进行比较的算法。但就从上面这句话来看，可能有点抽象，可参考下面这张图片 双端对比的简单实现理想情况下的实现为了便于理解，我们先从理想情况下看怎么实现双端对比。上面提到了，双端对比需要从新旧两组子节点进行对比，所以需要四个索引值来分别指向新旧两组子节点的端点。本文中将其分别命名为newStartIdx, newEndIdx, oldStartIdx, oldEndIdx，由于本文仅是为了说明双端算法，为了便于理解说明，假定所有的节点均为数字数组中的元素，并进行比较，从代码层实现如下： 1234567891011121314// newStartIdx 新数组的起始索引// newEndIdx 新数组的结束索引// newArray 新数组// oldStartIdx 旧数组的起始索引// oldEndIdx 旧数组的结束索引// oldArray 旧数组let oldStartIdx = 0, newStartIdx = 0let oldEndIdx = oldArray.length - 1, newEndIdx = newArray.length - 1let oldStart = oldArray[oldStartIdx], newStart = newArray[newStartIdx]let oldEnd = oldArray[oldEndIdx], newEnd = newArray[newEndIdx]if (oldStart === newStart) &#123;&#125; else if (oldEnd === newEnd) &#123;&#125; else if (oldStart === newEnd) &#123;&#125;else if (oldEnd === newStart) &#123;&#125; 那么下面我们来看一下双端算法的具体实现，根据上面的图片，我们将对应数组元素转化为数字： [1, 2, 3, 4][4, 2, 1, 3]按照图片中标识的先后顺序，我们可以得出下面的步骤： 比较oldStartIdx和newStartIdx指向的元素，元素不同，不可复用，什么都不用做 比较oldEndIdx和newEndIdx指向的元素，元素不同，不可复用，什么都不用做 比较oldStartIdx和newEndIdx指向的元素，元素不同，不可复用，什么都不用做 比较oldEndIdx和newStartIdx指向的元素，元素相同，可复用，需要移动元素 代码层面变动如下： 12345678910111213let oldStartIdx = 0, newStartIdx = 0let oldEndIdx = oldArray.length - 1, newEndIdx = newArray.length - 1let oldStart = oldArray[oldStartIdx], newStart = newArray[newStartIdx]let oldEnd = oldArray[oldEndIdx], newEnd = newArray[newEndIdx]if (oldStart === newStart) &#123;&#125; else if (oldEnd === newEnd) &#123;&#125; else if (oldStart === newEnd) &#123;&#125;else if (oldEnd === newStart) &#123; // 省略移动元素的代码。。。 // 更新索引值，指向下一个位置 oldEnd = oldArray[--oldEndIdx]; newStart = newArray[++newStartIdx];&#125; 进行上面的操作之后，数组变更为： [4, 1, 2, 3][4, 2, 1, 3]这时，oldArray的起始指向1，结束指向3；newArray的起始指向2，结束指向3。接下来重复进行上面的比对过程即可，由于是重复进行的逻辑，所以把对比的过程封装到一个while循环中：这里需要注意，while循环的判断条件是起始索引小于结束索引，表明数组还没对比完，但这里会引申出其他问题，具体什么问题等一下再说，先往下看 123456789101112131415let oldStartIdx = 0, newStartIdx = 0let oldEndIdx = oldArray.length - 1, newEndIdx = newArray.length - 1let oldStart = oldArray[oldStartIdx], newStart = newArray[newStartIdx]let oldEnd = oldArray[oldEndIdx], newEnd = newArray[newEndIdx]while(oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStart === newStart) &#123;&#125; else if (oldEnd === newEnd) &#123;&#125; else if (oldStart === newEnd) &#123;&#125; else if (oldEnd === newStart) &#123; // 省略移动元素的代码。。。 // 更新索引值，指向下一个位置 oldEnd = oldArray[--oldEndIdx]; newStart = newArray[++newStartIdx]; &#125;&#125; 上面的数组经过一轮对比之后，重复双端对比的顺序： 比较oldStartIdx和newStartIdx指向的元素，元素不同，不可复用，什么都不用做 比较oldEndIdxx和newEndIdx指向的元素，元素相同，但由于都处于数组尾部，不需要移动，所以仅更新索引值即可（PS：在具体的代码处理中根据需要自己添加处理，本文仅作双端对比的说明） 所以，代码变更如下： 12345678910111213141516171819let oldStartIdx = 0, newStartIdx = 0let oldEndIdx = oldArray.length - 1, newEndIdx = newArray.length - 1let oldStart = oldArray[oldStartIdx], newStart = newArray[newStartIdx]let oldEnd = oldArray[oldEndIdx], newEnd = newArray[newEndIdx]while(oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStart === newStart) &#123;&#125; else if (oldEnd === newEnd) &#123; // 省略需要添加的处理代码 oldEnd = oldArray[--oldEndIdx]; newEnd = newArray[--newEndIdx]; &#125; else if (oldStart === newEnd) &#123;&#125; else if (oldEnd === newStart) &#123; // 省略移动元素的代码。。。 // 更新索引值，指向下一个位置 oldEnd = oldArray[--oldEndIdx]; newStart = newArray[++newStartIdx]; &#125;&#125; 这时，oldArray的起始指向1，结束指向2；newArray的起始指向2，结束指向1。接下来，进行剩余部分的对比： 比较oldStartIdx和newStartIdx指向的元素，元素不同，不可复用，什么都不用做 比较oldEndIdxx和newEndIdx指向的元素，元素不同，不可复用，什么都不用做 比较oldStartIdx和newEndIdx指向的元素，元素相同，可复用，需要更新索引和移动元素 代码变更如下： 12345678910111213141516171819202122// ....while(oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStart === newStart) &#123;&#125; else if (oldEnd === newEnd) &#123; // 省略需要添加的处理代码 // 更新索引值，指向下一个位置 oldEnd = oldArray[--oldEndIdx]; newEnd = newArray[--newEndIdx]; &#125; else if (oldStart === newEnd) &#123; // 省略移动元素的代码。。。 // 更新索引值，指向下一个位置 oldStart = oldArray[++oldStartIdx]; newEnd = newArray[--newEndIdx]; &#125; else if (oldEnd === newStart) &#123; // 省略移动元素的代码。。。 // 更新索引值，指向下一个位置 oldEnd = oldArray[--oldEndIdx]; newStart = newArray[++newStartIdx]; &#125;&#125; 上面对比结束之后，仅剩余一个位置需要对比，由于该位置的元素相同，所以仅需要更新索引即可 12345678910111213141516171819202122// ....while(oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStart === newStart) &#123; oldStart = oldArray[++oldStartIdx]; newStart = newArray[++newStartIdx]; &#125; else if (oldEnd === newEnd) &#123; // 省略需要添加的处理代码 // 更新索引值，指向下一个位置 oldEnd = oldArray[--oldEndIdx]; newEnd = newArray[--newEndIdx]; &#125; else if (oldStart === newEnd) &#123; // 省略移动元素的代码。。。 // 更新索引值，指向下一个位置 oldStart = oldArray[++oldStartIdx]; newEnd = newArray[--newEndIdx]; &#125; else if (oldEnd === newStart) &#123; // 省略移动元素的代码。。。 // 更新索引值，指向下一个位置 oldEnd = oldArray[--oldEndIdx]; newStart = newArray[++newStartIdx]; &#125;&#125; 经过上面的对比之后，新旧两组数组已经变为拥有相同元素的数组。同时相信大家经过上面这个对比的过程之后，已经对双端对比的过程有了一个基本的了解，但是上面的例子中使用的数组实际上是有一定特殊性的，新旧两个数组拥有相同的元素，只是顺序不一样而已，而且数组的四个索引位置的数据刚好能满足将这个对比进行下去的条件，这只是一种理想情况，但在实际使用中，这种情况可能很少见，比如四个索引位置的元素各不相同怎么办？下面我们来看一下非理想情况下时，双端对比的处理 和上面类似，我们也用例子进行说明：现有两个较多元素的新旧数组： [6, 8, 1, 2, 3, 4, 5, 7][4, 2, 7, 1, 4, 3, 5, 8]从上面的例子可以看出初始时的四个索引位置对应的元素都不相同，针对这种情况，双端对比的处理方式是：查找新元素的首位在旧数组中的对应位置 能够找到新元素的首位在旧数组中的对应位置 找不到新元素的首位在旧数组中的对应位置123456789101112const index = oldArray.findIndex(item =&gt; item === newStart);// 能够找到新元素的首位在旧数组中的对应位置if (index &gt; -1) &#123; // ...... // 为了保证后续不在对该元素进行对比，将其设置为null oldArray[index] = null; newStart = newArray[++newStartIdx];&#125; else &#123; // 找不到新元素的首位在旧数组中的对应位置 // 因为oldArray中没有newStart对应的元素，因此需要自己创建一个新的元素然后将元素添加到数组中，具体代码不在添加，可根据实际需要添加 newStart = newArray[++newStartIdx];&#125; 根据上面针对元素的查找，代码变更为：1234567891011121314151617181920212223242526272829while(oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStart === null) &#123; oldStart = oldQueue[++oldStartIdx]; &#125; else if (oldEnd === null) &#123; oldEnd = oldQueue[--oldEndIdx]; &#125; else if (oldStart === newStart) &#123; oldStart = oldArray[++oldStartIdx]; newStart = newArray[++newStartIdx]; &#125; else if (oldEnd === newEnd) &#123; oldEnd = oldArray[--oldEndIdx]; newEnd = newArray[--newEndIdx]; &#125; else if (oldStart === newEnd) &#123; oldStart = oldArray[++oldStartIdx]; newEnd = newArray[--newEndIdx]; &#125; else if (oldEnd === newStart) &#123; oldEnd = oldArray[--oldEndIdx]; newStart = newArray[++newStartIdx]; &#125; else &#123; const index = oldArray.findIndex(item =&gt; item === newStart); if (index &gt; -1) &#123; // ...... oldArray[index] = null; newStart = newArray[++newStartIdx]; &#125; else &#123; // ...... newStart = newArray[++newStartIdx]; &#125; &#125;&#125; 上面的代码保证了非理想情况下的双端对比能够进行对比处理，但是我们在实际应用双端对比进行处理时，上面的while条件往往会产生问题，如果新旧数组的长度不一致，比如下面这种，那么当短数组对比结束时，长数组还没对比完成，但上面的代码根据while条件实际上已经不能再继续执行，这时候就需要做针对处理，保证对比的正确性 [6, 13, 8, 1, 2, 10, 9, 11, 12, 3, 4, 5, 7][4, 2, 7, 1, 4, 3, 5, 8] 从while的条件中可以看出，实际上可以分为两种情况进行处理： 旧数组对比结束，新数组未结束将新数组中剩余未对比的元素移动到新数组的最新结束元素后 新数组对比结束，旧数组未结束将旧数组中剩余元素删除 使用双端对比的前提是需要双端连续可持续跳跃，所以双向链表可用","categories":[],"tags":[]},{"title":"微信小游戏制作","slug":"56-weixin-mini-game","date":"2023-09-04T06:21:41.000Z","updated":"2023-12-25T03:01:08.671Z","comments":true,"path":"2023/09/04/56-weixin-mini-game/","link":"","permalink":"https://sunjinkang.github.io/2023/09/04/56-weixin-mini-game/","excerpt":"概览工具微信小游戏使用《小游戏可视化制作工具》进行制作开发。《小游戏可视化制作工具》是一款web应用，可用于开发微信小游戏。以可视化的操作方式编辑游戏场景，使用积木作为脚本设计精灵的行为逻辑。 《小游戏可视化制作工具》推荐使用Chrome浏览器或者最新的QQ浏览器打开。 《小游戏可视化制作工具》支持微信扫码登录，创建的小游戏项目为开发者私人所有，无法跟他人共享或共同编辑。《小游戏可视化制作工具》的账号密码登录为团队开发登录使用，暂未开放注册。","text":"概览工具微信小游戏使用《小游戏可视化制作工具》进行制作开发。《小游戏可视化制作工具》是一款web应用，可用于开发微信小游戏。以可视化的操作方式编辑游戏场景，使用积木作为脚本设计精灵的行为逻辑。 《小游戏可视化制作工具》推荐使用Chrome浏览器或者最新的QQ浏览器打开。 《小游戏可视化制作工具》支持微信扫码登录，创建的小游戏项目为开发者私人所有，无法跟他人共享或共同编辑。《小游戏可视化制作工具》的账号密码登录为团队开发登录使用，暂未开放注册。 小游戏编辑器介绍 概览编辑器，可分为8个区域，分别是： 工具栏：添加素材，运行游戏，预览发布，搜索，保存退出等功能入口； 场景面板：添加/切换不同场景，如果游戏复杂可能存在多个场景，比如：不同关卡、开始界面、结束界面等等； 资源面板：管理当前项目的所有资源（包括精灵/声音/函数），资源管理器中的精灵可拖拽进入编辑区域生成一个新的图层精灵实例； 积木面板：用于控制精灵实例的积木脚本，积木是与资源一一对应的，一个资源的多个实例图层都会公用一套积木； 图层面板：管理当前场景中的精灵实例，已经在编辑区域有实例的精灵都是一个图层，在图层面板可以拖拽调整图层顺序，也可以打组成为容器（Ctrl+G）； 编辑区域：这里就是所见即所得的游戏界面！编辑区域与图层是一一对应的，我们可以选中区域中的精灵实例进行拖拽位置，调整大小等； 属性面板：由两块组成，当我们选择资源时，只显示资源属性，当我们选择图层时，同时显示图层属性和资源属性。每个图层都有自己的属性互不影响； 数据面板：对（全局/精灵私有）的变量/列表/表格/通知等数据进行管理 制作流程 在浏览器中打开制作工具 通过 [新建小游戏/复制示例/改编他人作品] 等方式创建一个游戏项目 导入素材，编辑场景，拖入积木，完善游戏 在电脑上运行调试 在移动端预览调试，也可以分享给他人体验 发布到MP平台，完成小游戏 游戏世界精灵在计算机图形学中，当一张二维图像集成进场景中，成为整个游戏的一部分时，这张图就被称为精灵（英：Sprite） 数字数字也是一类特殊的精灵，它是由 “0-9” 十个数字及“-”和“.”组合形成的一个整体。使用也非常方便，可以通过以下这组积木进行实时动态修改。 外观-「修改[?]的值为(n)」外观-「将[?]的值增加(1)」 文字文字也是一类特殊的精灵，添加之后可以在图层属性面板修改：对齐方式、字体大小、行高、文字颜色。只能通过以下积木修改内容。 外观-「修改[?]的内容为(你好)」 编辑器 工具栏 作品设置[适配模式] 我们可以调整在移动端的适配模式，推荐竖屏游戏使用宽度适配，横屏游戏使用高度适配[使用默认资源进度条] 是否显示默认资源加载中的提示[资源加载方式] 如果项目非常大并且多个场景，建议选择切换场景时加载，并且搭配[资源管理]插件一起使用，建议默认选择全部加载后启动[分享标题] 设置一个好的分享标题可以吸引别人玩你的游戏，出现在小游戏分享给好友的卡片中，如不设置默认显示项目名[分享缩略图] 分享图非常关键，无论是在预览时分享给好友，还是在社区，还是发布成独立小游戏，分享作品时该图片是给人的第一印象[游戏说明] 游戏说明会出现在社区的项目页中，只有需要分享时才有必要设置该项 游戏适配1、设计尺寸目前通过可视化工具制作的游戏只能运行在微信小游戏端。官方设定的设计尺寸是：7501334，也就是iPhone 7的尺寸。因此在iPhone 7的手机中，可以完美的展示制作工具中看到界面，不会有任何裁剪或者黑边。也会依照此比例，在其他设备上进行等比缩放。循环滚动逻辑会改造为插件模式。*2、适配方案 设置背景图片的高度设计更高一点，为iPhone X的高度。或者将背景精灵纹理进行拉伸处理，这样能把黑边填充满。设置适配模式为适配高度，将游戏等比缩放，假如iPhone X的高度是iPhone 7 的1.2倍，结果是将游戏等比放大1.2倍。但这种方法带来的问题是水平方向会裁剪，左右会失去一部分细节。通过开启相对于场景布局来调整精灵在不同屏幕尺寸中的适配情况，无需过多的操作，只需要在场景中摆放完后选择开启想要的布局模式即可 资源管理游戏素材是游戏的“原材料”，通常包含图片、文本、音频。图片又可分为：单图、帧动画等。 在《小游戏可视化制作工具》中，游戏资源有以下几类 [精灵] 最常用的资源，用途广泛甚至可以替代背景[文字] 特殊的精灵，有两种文字类型，基础文字和带气泡背景的文字，常用于标题，按钮和提示等展示[数字] 特殊的精灵，由0-9和.-两个符号组成，相当于特殊字体，常用于展示得分和其他数值变化[背景] 特殊的精灵，每个场景只有一个且自动生成，并且不会超出屏幕区域，只适用于快速搭建小场景游戏[容器] 多个精灵的组合层，本身也是独立的空精灵[UI插件] 特殊的资源，自带一些行为属性，较为独立，部分积木无法影响到UI插件[声音] 可以被积木引用并播放[函数] 多个积木的合集，适用于需要在不同精灵多次使用相同积木组合的场合游戏资源 = 素材 + 积木。换句话说可视化制作工具中的资源是具有积木逻辑的素材 系统素材素材库包含：系统素材/我的素材/UI插件三个部分，官方提供了多个拥有自主版权的主题素材，如：《积木小Y》、《彩色飞机大战》等。 素材库中的积木小Y是主要 文本/数字 等素材的导入入口，其中 [基础文字] 最为常用 上传素材使用上传素材需要切换到[我的素材]Tab页，同时针对上传的素材有特殊要求： 单图和音频：将素材拖拽扔进我的素材或者上传素材的上传区域即可 帧动画组：打开上传素材界面，并将帧动画组的素材名称规范命名为：xx1.png、xx2.png、xx3.png、xx4.png、xx5.png…，然后选中整个帧动画组整体拖拽扔进上传区域，即可自动生成帧动画组素材 数字：打开上传素材界面，将数字以规范命名为：xx1.png、xx2.png、xx3.png等，即可自动填充到对应的位置，也可以手动点击单个窗口上传对应的数字和字符，只有上传了负号和小数点的数字精灵，才支持负数和显示小数，否则只能显示正整数 文本框：打开上传素材界面，上传一张图片作为文本框的背景，还可以调整文本有效区域和真实图片之间的间距 绘图：开发者可以自行对素材进行编辑修改或者创作一些简单的素材 录音：开发者可以创作个性的录音素材，并对素材进行剪辑等操作 绑定积木脚本：资源是和积木逻辑绑定的，每一个素材资源对应一套积木，关于积木脚本的详细信息可参考后续文章 资源的复用除了从素材库添加资源时默认创建在当前场景中的图层实例，还可以从资源管理器直接拖拽“精灵素材”至当前的编辑区域，即可在当前“场景”添加一个精灵实例，并同时会生成一个对应的“图层”。该实例是“精灵素材”资源的引用，将完全继承“精灵素材”的所有积木脚本。其属性会复制原始的“精灵素材”，可以在图层属性面板修改这些属性。 声音和音效声音资源也是从素材库添加，声音分为 [音效] 和 [背景音乐] 两类，在资源库中他们名并没有实际的区别，上传声音素材时，时间过长的会被分类为背景音乐，较短的被分类为音效，可以通过选择全部主题，点击音效来播放预览系统提供的一些音效 声音是咖啡色的积木，总共只有5个相关的积木，我们推荐音效使用播放，背景音乐使用循环播放，在一些手机系统导致的声音暂停的情况下，我们会在重新进入小游戏时把背景音乐自动重启在编辑游戏的过程中往往会反复调试音效，记得多使用资源面板中的替换音效功能而不是直接删除再添加，会省力的多 场景管理可以添加多个场景，并设置某一个场景为主场景，主场景并不一定是第一个场景，场景之间是通过积木「切换场景到XX」来互相跳转的，目前暂不支持场景的排序和场景相关的积木： 「事件-当场景启动时」 「控制-切换场景到XX」 「控制-销毁XX」 「控制-重启当前场景」 主场景游戏首次加载的场景我们称为主场景(左上角有房子标识)。在主场景中我们可以使用「当游戏开始时」积木作为启动事件，此事件只会触发一次。其他场景可通过「当场景启动时」作为启动事件。这里推荐所有入口都用「当场景启动时」作为启动场景的入口事件，「当游戏开始时」这个积木使用限制较多，只推荐在做简单的demo时使用 图层管理 层级图层的顺序影响精灵实例渲染的顺序，以及影响该实例对应的资源积木逻辑执行的顺序，所以管理好图层顺序也很重要，可以通过拖拽来调整图层层级顺序（不能拖动到背景层下方） 隐藏和锁定图层面板选中图层后右键或者点右侧的菜单按钮会出现 [隐藏/锁定/删除] 三个操作：[锁定] 图层的层级在编辑区域也会影响到下一层精灵的选中，我们可以暂时锁定上层的精灵，方便我们选中下一层，这里的锁定只会影响编辑，并不会对游戏运行过程产生影响[隐藏] 我们也可以直接在图层面板隐藏对应的图层，也可以影响编辑区域中的选中关系，注意这里的隐藏会影响到游戏逻辑，隐藏是一个非常重的操作，如果该精灵是隐藏的，那么他将无法参与碰撞和被用户点击到[删除] 删除图层操作只是将当前图层实例从当前场景中删除，并不会删除代码和对应的资源 摄像机[设置XX为摄像机的世界区域] 摄像机的边界，摄像机不会移出超出该区域的部分，一般使用方法为在场景中放置一个大正方形作为区域并添加该积木，流程较为麻烦后续会优化该积木[将XX移出摄像机镜头] 一般用于UI设置，需要成为UI的资源才有必要添加该积木[设置摄像机的跟随对象为XX] 使用摄像机的主要目的，我们在制作RPG类型的游戏时有时候会需要把摄像机对准主角，主角始终会在游戏的中间[设置摄像机的缩放比例] 设置摄像机缩放的比例，用于特写[设置摄像机的缩放比例增加] 设置摄像机缩放的比例增减，常用于镜头抖动[设置摄像机的偏移] 设置摄像机缩放的偏移，根据具体场景例如其他角色对话时使用[设置摄像机的偏移增加] 设置摄像机缩放的偏移增减，常用于镜头抖动和来回移动对话 属性属性是精灵在画布上表现的数据体现，属性是和编辑区域看到的是一一对应的，在可视化制作工具里，属性分为图层属性和资源属性 资源属性当我们选中资源面板的资源时，我们就会显示资源属性，工具弱化了资源属性的功能和展示大部分情况下，资源能设置的只有宽高和造型 通用属性 精灵特有属性 数字特有属性 文本特有属性纯文本不支持部分属性如宽高或翻转，对话框文本由两个部分组成，修改宽高会修改对话框部分 容器特有属性 插件特有属性每个插件都有自己定义的属性，各不同用 数据管理数据面板总共有4种类型，变量/列表/表格/通知，其中 [变量/列表/表格] 是一类，都分别有全局的和私有的两种类型，对应积木列表中的积木标签，而通知相关的积木则在控制和事件标签中。[变量/列表/表格] 都有格子对应的取值积木，分别对应 [红色/橙色/黄色]新建时需要选择是私有变量还是全局变量，全部变量在整个游戏中是唯一的，一旦改变，任何读取全局变量的积木都会拿到最新的值。局部变量局部变量是属于某个精灵个体的，并且精灵的克隆体也拥有其自己的局部变量。 在大部分情况下我们都推荐使用全局变量，只有在当前精灵对象存在克隆体时，为了让每个克隆体单独拥有一份变量才需要设置 列表建议只使用全局列表，除非克隆体需要使用 表格表格通常是我们用来定义初始化参数用的，例如答题游戏的题目和选项，关卡的配置等 积木脚本 积木是可视化制作工具中承担非常重要的逻辑关联的一部分，我们采用事件头触发的模式竖向排列拼接积木，每个事件头被触发后才会执行内部的积木，如果是散落的积木则不会执行这里有几个通用概念，大部分积木都会有主语的选择，当我们选主语为其他精灵时，我们就可以在当前精灵控制其他精灵还有几个固定的选项:自己: 指精灵自己，常用主语，一般积木都默认操作自己，也可以用来在克隆体启动时指代克隆体本身创建者: 特指克隆体的创建者，在当克隆体被创建时使用，用于找到创建该克隆体的对象随机: 只会在屏幕内随机，而不是真正的无限随机手指: 指用户操作屏幕的触发坐标点被碰撞者: 在发生碰撞时使用，在监听碰撞的事件里找到被碰撞的对象X: 横坐标Y: 纵坐标边缘: 特指场景的边缘，通常就是屏幕看到的区域子精灵: 容器特有的选项，通常用于控制被克隆的容器阻塞动画: 部分动画积木具有等待的效果，必须等待动画完成才会往下执行 事件丰富的事件钩子积木能快速简单的控制游戏流程，监听状态和输入启动事件都是“头部积木”，只有启动事件被触发，其中包含的积木队列才会被依次执行。 逻辑 控制 运动 函数函数是一系列积木的组合，由开发者自己创建，在当前项目使用如果我们需要多次在不同的精灵里使用同一批积木时，例如敌人和主角的碰撞逻辑，敌人的销毁逻辑等，我们就需要自己创建一些函数来节省我们的积木，提高开发效率并且函数具有传递参数的功能，当我们给函数增加参数并命名后，我们在调用函数时就可以给函数传递对应的参数来达到不同的效果 碰撞系统 碰撞描边为了游戏性能，实际的计算不会去判断精灵的像素点是否相交，而是把它们简化为更简单的几个图形。这样做的目的是在碰撞性能与准确性之间保持一个平衡。另外值得注意的一个问题：是越复杂的图形碰撞计算越耗时，也意味着游戏可能会卡顿，所以在制作游戏的时候需要注意。为此编辑器提供了一个设置碰撞图形的功能。系统默认是采用多边形的轮廓，程序会自动计算出来。如果想改变它。往场景里面添加一个精灵，然后选中，在右侧的属性面板可以看到“调整碰撞轮廓”，可以手动去调整描边的类型与大小。轮廓是跟随图层实例的，它的描边数据是保存在实例上，而不是对象上。 碰撞积木在积木编辑区域，添加事件列表如下，在列表中选择“当精灵发生碰撞”事件碰到边缘碰到边缘比较简单，就是画布的边界。当这个条件满足的时候就会会触发这个事件的逻辑。碰到精灵当前精灵与其他精灵发生碰撞，也可以选择某一类精灵下拉列表，可以跨场景选择到其他场景的精灵，但实际是不生效的。 碰撞与相交相交：两个精灵的碰撞轮廓一直是有重叠区。碰撞：如果两个精灵，从相离到相交，则记录为一次碰撞事件。碰撞事件触发后，两个精灵一直处于相交状态，则不会再次触发碰撞事件。直到两个精灵相离后再次相交。 插件插件分为两种，全局的和非全局的。像轮盘组件，可以在游戏场景中实例化多次的。而数据缓存，只能有一个全局实例，更像是一个库，只要打开一个开关，就可以使用它提供的功能。不像轮盘还要拖入到画布中实例化才可以使用。插件有两个入口，系统全局的在顶部菜单栏。另一种是在资源库中 注意：不能给UI插件添加物理行为、碰撞事件监听等逻辑，会导致程序异常。 固体行为当给精灵添加固体行为的时候，就不能被穿透，可以当做地板或者墙壁使用。假如给A加上固体行为，B碰到A时会被挡住。但是这个行为使用是有场景限制的，必须配合其他行为一起使用。固体行为使其他行为对对象产生反应，就好像它是不可逾越的障碍一样。具有这种行为的对象称为固体。它影响以下行为：方向控制。被固体阻挡平台角色。平台角色无法从下方跳至固体上方 跳跃穿透行为当给精灵添加跳跃行为的时候，只能被单向穿透，可以当做特殊地板使用。假如给A加上跳跃穿透行为，B添加了平台角色行为，B跳跃或者横向跑动的时候可以穿过A，但B从高度下落碰到A时，则无法穿透A。这个行为使用有场景限制，必须配合平台角色行为一起使用。 单独使用这个行为是没有任何意义，必须配合其他行为使用。 平台角色行为当给精灵添加平台角色行为的时候，添加此行为后，精灵可以在平台上跳跃、跑动，配合”固体”和”跳跃穿透”一起使用。平台角色行为实现了侧视图“跳跃并运行”样式的移动。它支持斜坡，移动平台，“跳跃式”平台和任意重力角。平台角色行为将落在具有“固体”或“跳跃穿透”的任何对象上。不同之处在于，平台角色可以从“跳跃穿透”下面跳到上面去，而从固体下跳会使角色反弹，穿透不了。 物理行为物理从原来单纯的积木模式，切换行为插件模式。只有给精灵添加了物理行为才能使用物理相关的积木。 物理行为模拟现实的对象物理。它由Box2D驱动。物理行为是相对复杂的。建议使用以下教程，以基本了解如何使用物理行为以及在开始使用物理行为之前要了解的一些要点：物理：基础知识物理：力，脉冲，扭矩和关节 强烈建议完全通过物理行为（通过设置力，脉冲，转矩等）来控制物理对象，而不是尝试通过“设置位置”，“设置角度”等来操纵对象。 方向控制行为方向控制行为允许对象在默认情况下由箭头键控制的对角线上，下，左，右和对角线移动。在自顶向下视图游戏中控制玩家通常很有用。也可以将其设置为4个方向，或者简单地向上/向下或向左/向右移动，这对于拨片或滑块很有用。 方向控制行为被具有固体行为的任何对象阻止。 遮罩行为遮罩用于规定精灵可渲染的范围，带有遮罩行为的精灵会使用约束框（也就是属性中遮罩类型的Size规定的范围创建一个渲染遮罩，该精灵的所有子精灵（容器的子元素）都会依据这个遮罩进行裁剪，遮罩范围外的将不会渲染。简而言之，就是只绘制精灵的局部。 弹出行为利用缓动（允许你以平滑的方式更改对象的属性）做的一个弹出特效行为，模拟游戏常用的动画弹窗。 缓动动画行为“缓动动画”行为支持将精灵以特定缓动动画的方式移动到某个位置。它还支持以缓动动画的方式对精灵进行透明度修改、宽高调整以及比例缩放等功能。 发布流程 预览和体验：有50人上限的限制，但是最快速便捷，你可以选择下载二维码或者直接在微信右上角拉起分享给他人 发布到社区 发布到独立小游戏 优化建议https://gamemaker.weixin.qq.com/doc/minigame/optimize.html RPG类型的游戏：rpg游戏是角色扮演游戏类型，rpg是英文Role-Playing Game的缩写简称","categories":[],"tags":[]},{"title":"关于埋点","slug":"55-burying-point","date":"2023-08-09T08:39:45.000Z","updated":"2023-08-11T06:15:13.563Z","comments":true,"path":"2023/08/09/55-burying-point/","link":"","permalink":"https://sunjinkang.github.io/2023/08/09/55-burying-point/","excerpt":"前言假设你所在的公司有一个购物网站，想要分析不同用户的喜好偏向，预测商品销售情况等一些情况，这时就需要收集线上活动的用户行为的数据，并结合具体的指标进行分析。那么这些数据怎么收集？通常就可以通过埋点的方式解决类似的问题。 什么是埋点？埋点是一种常用的数据采集方法，是收集并记录用户行为数据的过程。 通过埋点收集用户行为的有效信息，用作统计页面加载和事件行为的数据支撑，比如访问量、点击率、跳出率等，同时埋点为数据运营提供基础，为未来的业务发展提供有力支持。","text":"前言假设你所在的公司有一个购物网站，想要分析不同用户的喜好偏向，预测商品销售情况等一些情况，这时就需要收集线上活动的用户行为的数据，并结合具体的指标进行分析。那么这些数据怎么收集？通常就可以通过埋点的方式解决类似的问题。 什么是埋点？埋点是一种常用的数据采集方法，是收集并记录用户行为数据的过程。 通过埋点收集用户行为的有效信息，用作统计页面加载和事件行为的数据支撑，比如访问量、点击率、跳出率等，同时埋点为数据运营提供基础，为未来的业务发展提供有力支持。 埋点原则：1、获取目标数据；2、获取当前版本情况； 1）新功能使用情况是否符合预期； 2）新功能对其他功能、整体是否有积极影响； 3）运营活动目标群体特征获取； 4）新增商业化目标监测。3、为后续版本做数据支持。 1）规划方向的用户行为分析； 2）画像特征分析；常见沟通过程以埋点文档为载体，以数据埋点评审为终结。 埋点方式埋点方式可以分为前端埋点和后端埋点，目前比较常见的前端埋点有：前端代码埋点、全埋点和可视化埋点。后端埋点通常指的就是后端代码埋点。 1、代码埋点：实施人员：代码开发人员优点：可以详细的设置某一个事件自定义属性，数据较为准确，比如：约定的id等属性；缺点：时间、人力成本大，需要确定上传的数据，需要开发人员对代码进行修改；数据传输的时效性较差，因为涉及网络，甚至可能出现因为断网等原因导致数据无法上报。 2、可视化埋点：在可视化界面，点击具体点位做埋点配置；实施人员：数据产品、数据分析师优点：埋点只需业务同学接入，无需开发支持；缺点：仅支持客户端行为。 可视化埋点的具体流程： 手机APP嵌入开启可视化功能的SDK，通过WebSocket的方式和服务器、前端进行相互通信，SDK会定时收到服务器下发的页面请求； 然后会上报页面快照和界面因子信息到服务器，服务器收到信息后会根据界面因子信息对页面的每个元素进行分析，根据控件的类型来标记哪些页面元素是可以被埋点的； 最后将可埋点信息交给前端渲染，此时，前端Web页面上展示就的就是可以埋点的页面。 埋点人员在渲染出来的前端Web页面上进行框选，标记事件属性等进行埋点。 前端Web页面会将对应的埋点信息传递给服务器保存，SDK则会通过策略定时从服务器获取埋点信息。 3、无埋点：又叫做全埋点，应用集成SDK，SDK自动监测用户所有行为。定义：开发集成SDK后，SDK直接开始捕捉和检测用户在应用中的所有行为。实施人员：数据产品、数据分析师优点： 1）无需开发，业务人员埋点即可； 2）支持先上报数据，后进行埋点。缺点： 1）数据量大； 2）多数有清空机制，超过n天，清空数据，无法追溯； 3）仅仅支持客户端。注：无埋点不是不埋点 注意：全埋点和可视化埋点很像。从实际的实现上看，二者的区别就是：可视化埋点先通过界面配置哪些控件的操作数据需要收集；“无埋点”则是先尽可能收集所有的控件的操作数据，然后再通过界面配置哪些数据需要在系统里面进行分析。 “无埋点”相比可视化埋点的优点：1、解决了数据“回溯”的问题，可视化埋点方案，只能从这一时刻向后收集数据，“无埋点”则从部署 SDK 的时候数据就一直都在收集了；2、“无埋点”方案也可以自动获取很多启发性的信息，例如，“无埋点”可以告诉使用者这个界面上每个控件分别被点击的概率是多大，哪些控件值得做更进一步的分析等等。 一些埋点工具 百度统计 神策数据 FireBase TalkingData 埋点数据采集遇到的问题：实时性：无网条件下产生的数据，无法实时上报；完整性：部分数据无法采集，根据《用户隐私协议》和《欧盟通用数据保护条例》异常：部分埋点，随版本升级变化，无法获取。","categories":[],"tags":[]},{"title":"进度条中同一文字颜色反差的实现","slug":"54-render-progress-text","date":"2023-08-03T07:19:59.000Z","updated":"2023-08-08T02:51:30.754Z","comments":true,"path":"2023/08/03/54-render-progress-text/","link":"","permalink":"https://sunjinkang.github.io/2023/08/03/54-render-progress-text/","excerpt":"前言生活中，大家应该都遇到过进度条，有时候进度条的文字在进度条内部，当进度覆盖到文字的时候，会有一种反差，比如：同一个文字被进度覆盖的部分是白色字体，未被进度覆盖的是黑色字体，本文即是针对这种效果的实现。","text":"前言生活中，大家应该都遇到过进度条，有时候进度条的文字在进度条内部，当进度覆盖到文字的时候，会有一种反差，比如：同一个文字被进度覆盖的部分是白色字体，未被进度覆盖的是黑色字体，本文即是针对这种效果的实现。 实现一：使用伪类预置说明content与attr（PS: 本文仅针对需要的使用方式进行说明，不做详细说明，感兴趣的可以前往mdn的attr进行查看） contentCSS 的 content CSS 属性用于在元素的 ::before 和 ::after 伪元素中插入内容。使用 content 属性插入的内容都是匿名的可替换元素。 12345678910&lt;a href=&quot;http://www.mozilla.org/en-US/&quot;&gt;Home Page&lt;/a&gt;a::before &#123; content: url(http://www.mozilla.org/favicon.ico) &quot; MOZILLA: &quot;; font: x-small Arial, freeSans, sans-serif; color: gray;&#125; 常见用法： content: attr(属性名); 示例： 12345678// html code&lt;p data-foo=&quot;hello&quot;&gt;world&lt;/p&gt;// css codep:before &#123; content: attr(data-foo) &quot; &quot;;&#125;// result// hello world 注意：attr理论上可以单独使用，但由于浏览器兼容性问题，目前最好不要使用，本文中attr是与content一起使用，限制较小。 方案：使用content和attr可以获取标签中的属性，将进度条的文字同时放在标签的属性里面，再通过伪类和content、attr搭配，根据进度显示不同宽度，将新的文字覆盖到原有的底层文字之上，实现进度条文字反差的效果。 1&lt;div class=&quot;progress-bar&quot; data-content=&quot;当前进度：18%&quot;&gt;当前进度：18%&lt;/div&gt; 1234567891011121314151617181920212223.progress-bar &#123; display: inline-block; font-size: 16px; line-height: 20px; color: lightblue; position: relative; overflow: hidden; white-space: pre; width: 300px; height: 20px; border: 1px solid #333;&#125;.progress-bar:before &#123; position: absolute; top: 0; color: #fff; display: block; width: 18%; content: attr(data-content); overflow: hidden; background-color: lightblue;&#125; 效果如下： 说明该方案中的文字好像只能处于默认的左侧位置，使用伪类获取的内容文字无法位于中间，暂未找到解决办法 方案二：使用双层元素层叠方案：本质与方案一类似，只不过方案二是把两个元素叠在一起，元素内容相同 1234&lt;div class=&quot;progress-wrapper&quot;&gt; &lt;div class=&quot;progress-bottom&quot;&gt;当前进度：18%&lt;/div&gt; &lt;div class=&quot;progress-top&quot;&gt;当前进度：18%&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829body &#123; margin: 0;&#125;.progress-wrapper &#123; overflow: hidden; white-space: pre; width: 300px; height: 20px; line-height: 20px; font-size: 16px; border: 1px solid #333; position: relative;&#125;.progress-bottom &#123; display: inline-block; color: lightblue; position: absolute; top: 0; left: 0; width: 100%;&#125;.progress-top &#123; background-color: lightblue; color: #fff; width: 18%; position: absolute; top: 0; overflow: hidden;&#125; 效果与方案一相同 说明方案二同样存在方案一的缺陷，文字只能位于左侧 上面两种方案都存在文字只能位于左侧的问题，但实际使用中往往文字是位于中间的，进而出现了方案三 方案三：使用三层元素层叠+js计算方案：实现方式与方案二类似，不过文字都位于进度条中间，并在两层元素之间又加了一层元素，新加的这层元素仅用于进度的渲染，同时通过js计算最上层的元素与进度区域的重合部分宽度，修改最上层元素的宽度，展示不同颜色的文字。ps: 本文中未实现具体的js计算逻辑，可根据进度条总长度，文字区域长度等进行计算。 12345&lt;div class=&quot;progress-wrapper&quot;&gt; &lt;div class=&quot;progress-bottom&quot;&gt;当前进度：18%&lt;/div&gt; &lt;div class=&quot;progress-bar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;progress-top&quot;&gt;当前进度：18%&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041body &#123; margin: 0;&#125;.progress-wrapper &#123; overflow: hidden; white-space: pre; width: 300px; height: 20px; line-height: 20px; font-size: 16px; border: 1px solid #333; position: relative; text-align: center;&#125;.progress-bottom &#123; display: inline-block; color: lightblue; position: absolute; top: 0; left: 0; width: 100%;&#125;.progress-top &#123; background-color: lightblue; color: #fff; width: 19%; position: absolute; top: 0; overflow: hidden; left: 50%; margin-left: -56px;&#125;.progress-bar &#123; background-color: lightblue; color: #fff; width: 50%; position: absolute; top: 0; overflow: hidden; height: 20px;&#125; 方案三通过js的计算，在实现文字颜色反差的基础上进一步实现了文字的居中 进度条插件的实现方案暂未发现。。。","categories":[],"tags":[]},{"title":"js中的void运算符","slug":"53-about-void","date":"2023-08-03T05:42:02.000Z","updated":"2023-08-04T01:54:01.852Z","comments":true,"path":"2023/08/03/53-about-void/","link":"","permalink":"https://sunjinkang.github.io/2023/08/03/53-about-void/","excerpt":"","text":"void运算符的作用 void 运算符对给定的表达式进行求值，然后返回 undefined。 1234// 语法void expression// orvoid(expression) 同时需要注意考虑 void 运算符的优先级（void优先级较高），以下加括号的表达式的例子可以帮助你清楚地理解 void 操作符的优先级：","categories":[],"tags":[]},{"title":"Hello World","slug":"1-hello-world","date":"2023-07-24T09:24:46.208Z","updated":"2023-08-03T02:54:29.832Z","comments":true,"path":"2023/07/24/1-hello-world/","link":"","permalink":"https://sunjinkang.github.io/2023/07/24/1-hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment deploy产生如下错误的解决方法(1)使用hexo部署报错Error: Spawn failed解决办法：删除.deploy_git文件夹 -&gt; 修改_config.yml文件中deploy的repository地址，修改为SSH方式 -&gt; 按顺序执行命令hexo clean、hexo generate、hexo deploy","categories":[],"tags":[]},{"title":"Vite 插件","slug":"52-vite-plugin","date":"2023-06-15T13:13:24.000Z","updated":"2023-08-04T01:54:01.850Z","comments":true,"path":"2023/06/15/52-vite-plugin/","link":"","permalink":"https://sunjinkang.github.io/2023/06/15/52-vite-plugin/","excerpt":"vite插件什么是vite插件vite 其实就是一个由原生 ES Module 驱动的新型 Web 开发前端构建工具。vite 插件 就可以很好的扩展 vite 自身不能做到的事情，比如一些打包的数据展示，开发中或者打包中的数据处理等等。 插件 APIVite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因此，你只需要编写一个 Vite 插件，就可以同时为开发环境和生产环境工作。","text":"vite插件什么是vite插件vite 其实就是一个由原生 ES Module 驱动的新型 Web 开发前端构建工具。vite 插件 就可以很好的扩展 vite 自身不能做到的事情，比如一些打包的数据展示，开发中或者打包中的数据处理等等。 插件 APIVite 插件扩展了设计出色的 Rollup 接口，带有一些 Vite 独有的配置项。因此，你只需要编写一个 Vite 插件，就可以同时为开发环境和生产环境工作。 注意：了解vite插件之前，建议先阅读 Rollup 插件文档。 注意事项对于 Vite 专属的插件： Vite 插件应该有一个带 vite-plugin- 前缀、语义清晰的名称。 在 package.json 中包含 vite-plugin 关键字。 在插件文档增加一部分关于为什么本插件是一个 Vite 专属插件的详细说明（如，本插件使用了 Vite 特有的插件钩子）。 如果你的插件只适用于特定的框架，它的名字应该遵循以下前缀格式： vite-plugin-vue- 前缀作为 Vue 插件 vite-plugin-react- 前缀作为 React 插件 vite-plugin-svelte- 前缀作为 Svelte 插件 通常的惯例是创建一个 Vite/Rollup 插件作为一个返回实际插件对象的工厂函数。该函数可以接受允许用户自定义插件行为的选项。 通用钩子以下钩子在构建阶段被调用： options(options) ：在服务器启动时被调用：获取、操纵Rollup选项，严格意义上来讲，它执行于属于构建阶段之前； buildStart(options)：在每次开始构建时调用； resolveId(source, importer, options)：在每个传入模块请求时被调用，创建自定义确认函数，可以用来定位第三方依赖； load(id)：在每个传入模块请求时被调用，可以自定义加载器，可用来返回自定义的内容； transform(code, id)：在每个传入模块请求时被调用，主要是用来转换单个模块； buildEnd(error?: Error)：在构建阶段结束后被调用，此处构建结束只是代表所有模块转义完成； 以下钩子在输出阶段被调用： outputOptions(options)：接受输出参数； renderStart(outputOptions, inputOptions)：每次 bundle.generate 和 bundle.write 调用时都会被触发； augmentChunkHash(chunkInfo)：用来给 chunk 增加 hash； renderChunk(code, chunk, options)：转译单个的chunk时触发。rollup 输出每一个chunk文件的时候都会调用； generateBundle(options, bundle, isWrite)：在调用 bundle.write 之前立即触发这个 hook； writeBundle(options, bundle)：在调用 bundle.write后，所有的chunk都写入文件后，最后会调用一次 writeBundle； closeBundle()：在服务器关闭时被调用 请注意 moduleParsed 钩子在开发中是 不会 被调用的，因为 Vite 为了性能会避免完整的 AST 解析。Output Generation Hooks(除了 closeBundle) 在开发中是 不会 被调用的。你可以认为 Vite 的开发服务器只调用了 rollup.rollup() 而没有调用 bundle.generate()。 vite 独有钩子 这些钩子会被rollup忽略 enforce值可以是pre 或 post ， pre 会较于 post 先执行 apply值可以是 build 或 serve 亦可以是一个函数，指明它们仅在 build 或 serve 模式时调用； config 在解析 Vite 配置前调用。钩子接收原始用户配置（命令行选项指定的会与配置文件合并）和一个描述配置环境的变量，包含正在使用的 mode 和 command。它可以返回一个将被深度合并到现有配置中的部分配置对象，或者直接改变配置（如果默认的合并不能达到预期的结果） 例子： 12345678const mutateConfigPlugin = () =&gt; (&#123; name: &#x27;mutate-config&#x27;, config(config, &#123; command &#125;) &#123; if (command === &#x27;build&#x27;) &#123; config.root = __dirname &#125; &#125;&#125;); 用户插件在运行这个钩子之前会被解析，因此在 config 钩子中注入其他插件不会有任何效果。 configResolved 在解析 Vite 配置后调用。使用这个钩子读取和存储最终解析的配置。当插件需要根据运行的命令做一些不同的事情时，它也很有用。 例子： 123456789101112131415161718192021const exmaplePlugin = () =&gt; &#123; let config return &#123; name: &#x27;read-config&#x27;, configResolved(resolvedConfig) &#123; // 存储最终解析的配置 config = resolvedConfig &#125;, // 在其他钩子中使用存储的配置 transform(code, id) &#123; if (config.command === &#x27;serve&#x27;) &#123; // serve: 由开发服务器调用的插件 &#125; else &#123; // build: 由 Rollup 调用的插件 &#125; &#125; &#125;&#125; configureServer 是用于配置开发服务器的钩子。最常见的用例是在内部 connect 应用程序中添加自定义中间件: 12345678const myPlugin = () =&gt; (&#123; name: &#x27;configure-server&#x27;, configureServer(server) &#123; server.middlewares.use((req, res, next) =&gt; &#123; // 自定义请求处理... &#125;) &#125;&#125;) 注入后置中间件configureServer 钩子将在内部中间件被安装前调用，所以自定义的中间件将会默认会比内部中间件早运行。如果你想注入一个在内部中间件 之后 运行的中间件，你可以从 configureServer 返回一个函数，将会在内部中间件安装后被调用： 123456789101112const myPlugin = () =&gt; (&#123; name: &#x27;configure-server&#x27;, configureServer(server) &#123; // 返回一个在内部中间件安装后 // 被调用的后置钩子 return () =&gt; &#123; server.middlewares.use((req, res, next) =&gt; &#123; // 自定义请求处理... &#125;) &#125; &#125;&#125;) 存储服务器访问在某些情况下，其他插件钩子可能需要访问开发服务器实例（例如访问 websocket 服务器、文件系统监视程序或模块图）。这个钩子也可以用来存储服务器实例以供其他钩子访问: 1234567891011121314const myPlugin = () =&gt; &#123; let server return &#123; name: &#x27;configure-server&#x27;, configureServer(_server) &#123; server = _server &#125;, transform(code, id) &#123; if (server) &#123; // 使用 server... &#125; &#125; &#125;&#125; 注意 configureServer 在运行生产版本时不会被调用，所以其他钩子需要防范它缺失。 transformIndexHtml转换 index.html 的专用钩子。钩子接收当前的 HTML 字符串和转换上下文。上下文在开发期间暴露ViteDevServer实例，在构建期间暴露 Rollup 输出的包。这个钩子可以是异步的，并且可以返回以下其中之一: 经过转换的 HTML 字符串 注入到现有 HTML 中的标签描述符对象数组（{ tag, attrs, children }）。每个标签也可以指定它应该被注入到哪里（默认是在 之前） 一个包含 { html, tags } 的对象 handleHotUpdate执行自定义 HMR 更新处理。钩子接收一个带有以下签名的上下文对象： 1234567interface HmrContext &#123; file: string timestamp: number modules: Array&lt;ModuleNode&gt; read: () =&gt; string | Promise&lt;string&gt; server: ViteDevServer&#125; modules 是受更改文件影响的模块数组。它是一个数组，因为单个文件可能映射到多个服务模块（例如 Vue 单文件组件）。 read 这是一个异步读函数，它返回文件的内容。之所以这样做，是因为在某些系统上，文件更改的回调函数可能会在编辑器完成文件更新之前过快地触发，并 fs.readFile 直接会返回空内容。传入的 read 函数规范了这种行为。 钩子可以选择: 过滤和缩小受影响的模块列表，使 HMR 更准确。 返回一个空数组，并通过向客户端发送自定义事件来执行完整的自定义 HMR 处理:12345678handleHotUpdate(&#123; server &#125;) &#123; server.ws.send(&#123; type: &#x27;custom&#x27;, event: &#x27;special-update&#x27;, data: &#123;&#125; &#125;) return []&#125; 客户端代码应该使用 HMR API 注册相应的处理器（这应该被相同插件的 transform 钩子注入）：12345if (import.meta.hot) &#123; import.meta.hot.on(&#x27;special-update&#x27;, (data) =&gt; &#123; // 执行自定义更新 &#125;)&#125; 插件顺序一个 Vite 插件可以额外指定一个 enforce 属性（类似于 webpack 加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列： Alias 带有 enforce: ‘pre’ 的用户插件 Vite 核心插件 没有 enforce 值的用户插件 Vite 构建用的插件 带有 enforce: ‘post’ 的用户插件 Vite 后置构建插件（最小化，manifest，报告） 情景应用默认情况下插件在开发（serve）和构建（build）模式中都会调用。如果插件只需要在预览或构建期间有条件地应用，请使用 apply 属性指明它们仅在 ‘build’ 或 ‘serve’ 模式时调用： 123456789101112function myPlugin() &#123; return &#123; name: &#x27;build-only&#x27;, apply: &#x27;build&#x27; // 或 &#x27;serve&#x27; &#125;&#125;// 还可以使用函数来进行更精准的控制apply(config, &#123; command &#125;) &#123; // 非 SSR 情况下的 build return command === &#x27;build&#x27; &amp;&amp; !config.build.ssr&#125; Rollup 插件兼容性有一些rollup插件可以直接作为vite插件使用，但是有些不行，一般来说，需要满足以下条件： 没有使用 moduleParsed 钩子。 它在打包钩子和输出钩子之间没有很强的耦合。 如果一个 Rollup 插件只在构建阶段有意义，则在 build.rollupOptions.plugins 下指定即可。 你也可以用 Vite 独有的属性来扩展现有的 Rollup 插件: 12345678910111213// vite.config.jsimport example from &#x27;rollup-plugin-example&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;export default defineConfig(&#123; plugins: [ &#123; ...example(), enforce: &#x27;post&#x27;, apply: &#x27;build&#x27; &#125; ]&#125;) 查看 Vite Rollup 插件 获取兼容的官方 Rollup 插件列表及其使用指南。 路径规范化Vite 对路径进行了规范化处理，在解析路径时使用 POSIX 分隔符（ / ），同时保留了 Windows 中的卷名。而另一方面，Rollup 在默认情况下保持解析的路径不变，因此解析的路径在 Windows 中会使用 win32 分隔符（ \\ ）。然而，Rollup 插件会使用 @rollup/pluginutils 内部的 normalizePath 工具函数，它在执行比较之前将分隔符转换为 POSIX。所以意味着当这些插件在 Vite 中使用时，include 和 exclude 两个配置模式，以及与已解析路径比较相似的路径会正常工作。 所以对于 Vite 插件来说，在将路径与已解析的路径进行比较时，首先规范化路径以使用 POSIX 分隔符是很重要的。从 vite 模块中也导出了一个等效的 normalizePath 工具函数。 1234import &#123; normalizePath &#125; from &#x27;vite&#x27;normalizePath(&#x27;foo\\\\bar&#x27;) // &#x27;foo/bar&#x27;normalizePath(&#x27;foo/bar&#x27;) // &#x27;foo/bar&#x27; vite kooks的渲染顺序hooks vite插件顺序？？？？有些插件钩子在非构建式的开发服务器上下文中没有意义????","categories":[],"tags":[]},{"title":"Thunk函数","slug":"51-about-thunk-function","date":"2023-04-19T09:00:23.000Z","updated":"2023-08-08T02:53:12.775Z","comments":true,"path":"2023/04/19/51-about-thunk-function/","link":"","permalink":"https://sunjinkang.github.io/2023/04/19/51-about-thunk-function/","excerpt":"求值策略在介绍Thunk函数之前，需要先介绍一下什么叫做求值策略，即函数的参数应该什么时候求值。 1234function test(num) &#123; return num+1;&#125;test(2+3); 类似上面这样将一个表达式作为参数传入函数，表达式应该什么时候计算？实际上可以分为两种情况： 一种是**传值调用(call by value)**，即表达式在传入函数之前就已经进行了计算，test(2+3)就相当于test(5)，js、C语言、JAVA等语言使用的是这种策略。 一种是**传名调用(call by name)**，即直接将表达式传入函数，只在需要的时候进行表达式的运算，Haskell(哈斯克尔)使用的是这种策略。传值调用比较简单和便于理解，但是在没有用到的时候，先进行了计算，可能造成性能浪费。","text":"求值策略在介绍Thunk函数之前，需要先介绍一下什么叫做求值策略，即函数的参数应该什么时候求值。 1234function test(num) &#123; return num+1;&#125;test(2+3); 类似上面这样将一个表达式作为参数传入函数，表达式应该什么时候计算？实际上可以分为两种情况： 一种是**传值调用(call by value)**，即表达式在传入函数之前就已经进行了计算，test(2+3)就相当于test(5)，js、C语言、JAVA等语言使用的是这种策略。 一种是**传名调用(call by name)**，即直接将表达式传入函数，只在需要的时候进行表达式的运算，Haskell(哈斯克尔)使用的是这种策略。传值调用比较简单和便于理解，但是在没有用到的时候，先进行了计算，可能造成性能浪费。 什么是Thunk函数 将表达式参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。它是”传名调用”的一种实现策略，用来替换某个表达式。 12345678function test(num) &#123; return num+1;&#125;function testValue() &#123; return 2+3;&#125;test(testValue());// testValue 函数就是Thunk函数 JavaScript中的Thunk函数在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。 要点：多参数函数 函数接受多个参数 函数的最后一个参数是回调函数 12345678910function test(a, b, callback) &#123;...&#125;var testThunk = Thunk(a, b);testThunk(callback);var Thunk = function (a, b)&#123; return function (callback)&#123; return test(a, b, callback); &#125;;&#125;; 上面的函数经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做 Thunk 函数。任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。 123456789var toThunk = function(fn)&#123; return function ()&#123; var args = Array.prototype.slice.call(arguments); return function (callback)&#123; args.push(callback); return fn.apply(this, args); &#125; &#125;;&#125;; 使用上面的转换器之后，可将上述的例子修改为 12var testThunk = toThunk(test);testThunk(a, b)(callback) Thunkify模块下载地址：https://github.com/tj/node-thunkify使用举例 123456var thunkify = require(&#x27;thunkify&#x27;);var fs = require(&#x27;fs&#x27;);var read = thunkify(fs.readFile);read(&#x27;package.json&#x27;, &#x27;utf8&#x27;)(function(err, str)&#123; ...&#125;); 注意：thunkify中存在一个检查机制，回调函数只运行一次。 123456789101112import thunkify from &#x27;thunkify&#x27;;function test(a, b, callback) &#123; const result = a + b; callback(result); callback(result); callback(result);&#125;const thunkTest = thunkify(test);thunkTest(1, 2)(console.log);// 3 Thunk函数的用途Thunk函数可以和Generator结合使用，Thunk 函数作为在 Generator 中要迭代的值，通过 co 来对 Generator 进行流程控制。Generator函数中可以使用yield将程序的执行权移出，然后通过Thunk函数的回调函数，再将执行权还给Generator函数。 12345678910111213141516171819202122232425262728293031323334353637import thunkify from &#x27;thunkify&#x27;;function test(a, b, callback) &#123; const result = a + b; callback(result);&#125;const thunkTest = thunkify(test);function* gen() &#123; yield thunkTest(1, 2); yield thunkTest(3, 4);&#125;// 使用Thunk函数处理const genTest = gen();const genValue = genTest.next();genValue.value(function (data) &#123; console.log(data); const genValue1 = genTest.next(data); genValue1.value(function (data1) &#123; console.log(data1); &#125;);&#125;);// 修改为递归方式调用function genFn(fn) &#123; const gen = fn(); function next(data) &#123; console.log(data); const genValue = gen.next(data); if (genValue.done) return; genValue.value(next); &#125; next();&#125;genFn(gen); co+Generator+Thunk可以通过co控制Generator函数中的Thunk函数的执行流程co地址：https://github.com/tj/co 注意：co从4.0.0开始返回的是promise，之前返回的是thunk函数，4.0.0之前会把promise转成thunk函数 1234567891011121314151617181920212223var co = require(&#x27;co&#x27;);// 这里的thunk函数也可以自己实现var thunkify = require(&#x27;thunkify&#x27;);var request = require(&#x27;request&#x27;);var get = thunkify(request.get);function *results() &#123; var a = get(&#x27;http://google.com&#x27;) var b = get(&#x27;http://yahoo.com&#x27;) var c = get(&#x27;http://ign.com&#x27;) return yield [a, b, c]&#125;co(function *()&#123; // 3 concurrent requests at a time var a = yield results; var b = yield results; console.log(a, b); // 6 concurrent requests console.log(yield [results, results]);&#125;)() 123456789101112import co from &#x27;co&#x27;;co(function* () &#123; var result = yield Promise.resolve(true); // var result = yield Promise.reject(&#x27;errorInfo&#x27;); return result;&#125;) .then(function (value) &#123; console.log(`then: $&#123;value&#125;`); &#125;) .catch(function (err) &#123; console.error(err); &#125;); comment：一些简单的传值调用，会在编译阶段就被优化掉。如果将简单的表达式放到一个函数中return返回，将函数作为参数传入处理函数中，这个参数函数是否会被编译优化处理？？","categories":[],"tags":[]},{"title":"try...catch和return","slug":"50-try-catch-return","date":"2023-04-19T02:42:04.000Z","updated":"2023-08-03T03:05:54.178Z","comments":true,"path":"2023/04/19/50-try-catch-return/","link":"","permalink":"https://sunjinkang.github.io/2023/04/19/50-try-catch-return/","excerpt":"关于return return 语句终止函数的执行，并返回一个指定的值给函数调用者 1234567891011121314function test() &#123; for (let i = 0; i &lt; 4; i++) &#123; console.log(`before: $&#123;i&#125;`); if (i === 2) return; console.log(`after: $&#123;i&#125;`); &#125; console.log(`result`);&#125;test();// before: 0// after: 0// before: 1// after: 1// before: 2 注意：自动分号补全规则会影响 return 语句。在 return 关键字和被返回的表达式之间不允许使用换行符。","text":"关于return return 语句终止函数的执行，并返回一个指定的值给函数调用者 1234567891011121314function test() &#123; for (let i = 0; i &lt; 4; i++) &#123; console.log(`before: $&#123;i&#125;`); if (i === 2) return; console.log(`after: $&#123;i&#125;`); &#125; console.log(`result`);&#125;test();// before: 0// after: 0// before: 1// after: 1// before: 2 注意：自动分号补全规则会影响 return 语句。在 return 关键字和被返回的表达式之间不允许使用换行符。 自动分号补全(ASI)在JavaScript中，行尾的分号有一种自动插入机制，如果新起了一行，并且这新的一行不能追加到当前语句时，会自动追加一个分号 123return1;// return会因为自动分号补全自动添加一个分号 关于try…catch try…catch 语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。 123456try &#123; a + 3;&#125; catch (error) &#123; console.log(error);&#125;// ReferenceError: a is not defined try…catch语法12345678910111213try &#123; try_statements&#125;[catch (exception_var_1 if condition_1) &#123; // non-standard catch_statements_1&#125;]...[catch (exception_var_2) &#123; catch_statements_2&#125;][finally &#123; finally_statements&#125;] 使用方式 try…catch try…finally try…catch…finallycatch子句包含try块中抛出异常时要执行的语句。如果在try块中有任何一个语句（或者从try块中调用的函数）抛出异常，控制立即转向catch子句。如果在try块中没有异常抛出，会跳过catch子句。 finally子句在try块和catch块之后执行但是在下一个try声明之前执行。无论是否有异常抛出或捕获它总是执行。 你可以嵌套一个或者更多的try语句。如果内部的try语句没有catch子句，那么将会进入包裹它的try语句的catch子句。 12345678910111213141516171819try &#123; try &#123; a + 3; &#125; catch (err) &#123; console.log(`inner: $&#123;err&#125;`); &#125;&#125; catch (err) &#123; console.log(`outer: $&#123;err&#125;`);&#125;// inner: ReferenceError: a is not definedtry &#123; try &#123; a + 3; &#125; finally&#123;&#125;&#125; catch (err) &#123; console.log(`outer: $&#123;err&#125;`);&#125;// outer: ReferenceError: a is not defined 无条件的catch语句即catch捕获错误，进行处理，常用的一般是这种，不再赘述 有条件的catch语句12345678910try &#123; a + 3;&#125; catch (err) &#123; if (err.toString().includes(&#x27;not defined&#x27;)) &#123; console.log(`not defined error: $&#123;err&#125;`); &#125; else &#123; console.log(err); &#125;&#125;// not defined error: ReferenceError: a is not defined try…catch中使用return 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function test() &#123; try &#123; try &#123; a+3; &#125; catch (err) &#123; console.log(`inner error: $&#123;err&#125;`); return; &#125; &#125; finally &#123; console.log(`finally`) &#125;&#125;test();// inner error: ReferenceError: a is not defined// finallyfunction test() &#123; try &#123; try &#123; a + 3; &#125; catch (err) &#123; console.log(`inner error: $&#123;err&#125;`); return; &#125; finally &#123; console.log(`inner finally`); return; &#125; &#125; finally &#123; console.log(`finally`); &#125;&#125;test();// inner error: ReferenceError: a is not defined// inner finally// finallyfunction test() &#123; try &#123; try &#123; return 3; &#125; catch (err) &#123; console.log(`inner error: $&#123;err&#125;`); return; &#125; finally &#123; console.log(`inner finally`); // return &#x27;finally&#x27;; &#125; &#125; finally &#123; console.log(`outer finally`); &#125;&#125;const result = test();console.log(result);// inner finally// outer finally// if inner finally not return something, result is 3, else result is the inner finally return.function test() &#123; try &#123; try &#123; return 3; &#125; catch (err) &#123; console.log(`inner error: $&#123;err&#125;`); return; &#125; finally &#123; return &#x27;finally&#x27;; &#125; &#125; finally &#123; return &#x27;outer finally&#x27;; &#125;&#125;const result = test();console.log(result);// outer finally 如果从finally块中返回一个值，那么这个值将会成为整个try-catch-finally的返回值，无论是否有return语句在try和catch中。这包括在catch块里抛出的异常。","categories":[],"tags":[]},{"title":"js类型化数组","slug":"49-typed-array","date":"2023-04-18T10:17:14.000Z","updated":"2023-08-03T03:05:40.218Z","comments":true,"path":"2023/04/18/49-typed-array/","link":"","permalink":"https://sunjinkang.github.io/2023/04/18/49-typed-array/","excerpt":"什么是类型化数组（Typed Array）? JavaScript 类型化数组（typed array）是一种类似数组的对象，并提供了一种用于在内存缓冲区中访问原始二进制数据的机制。 JavaScript 类型化数组中的每一个元素都是原始二进制值，而二进制值采用多种支持的格式之一（从 8 位整数到 64 位浮点数）。","text":"什么是类型化数组（Typed Array）? JavaScript 类型化数组（typed array）是一种类似数组的对象，并提供了一种用于在内存缓冲区中访问原始二进制数据的机制。 JavaScript 类型化数组中的每一个元素都是原始二进制值，而二进制值采用多种支持的格式之一（从 8 位整数到 64 位浮点数）。 注意：类型数组和普通数组不一样，使用Array.isArray()判断类型数组返回false，此外，一些在普通数组上使用的方法，在类型数组上无法使用 1234567const bufferArray = new ArrayBuffer(16);console.log(Array.isArray(bufferArray));// falsebufferArray.push(1);// TypeError: bufferArray.push is not a functionbufferArray.pop(1);// TypeError: bufferArray.pop is not a function 类型化数组的语法类型化数组的特性、方法、使用场景类型化数组的局限性、限制","categories":[],"tags":[]},{"title":"import、import()、require的区别","slug":"48-difference-about-require-import","date":"2023-04-06T02:42:59.000Z","updated":"2023-07-24T09:24:46.457Z","comments":true,"path":"2023/04/06/48-difference-about-require-import/","link":"","permalink":"https://sunjinkang.github.io/2023/04/06/48-difference-about-require-import/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"生成器函数和yield关键字","slug":"47-about-generate-function","date":"2023-03-31T06:00:46.000Z","updated":"2023-08-03T03:05:03.177Z","comments":true,"path":"2023/03/31/47-about-generate-function/","link":"","permalink":"https://sunjinkang.github.io/2023/03/31/47-about-generate-function/","excerpt":"什么是生成器函数？ function* 这种声明方式 (function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个 Generator 对象。也可以使用构造函数 GeneratorFunction 或 function* expression 定义**生成器函数 ** 语法12345function* name([param[, param[, ... param]]]) &#123; statements &#125;// name: 函数名// param: 参数// statements: 执行语句// 声明方式可以为：function* name()&#123;&#125; 或者 function *name()&#123;&#125;","text":"什么是生成器函数？ function* 这种声明方式 (function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个 Generator 对象。也可以使用构造函数 GeneratorFunction 或 function* expression 定义**生成器函数 ** 语法12345function* name([param[, param[, ... param]]]) &#123; statements &#125;// name: 函数名// param: 参数// statements: 执行语句// 声明方式可以为：function* name()&#123;&#125; 或者 function *name()&#123;&#125; 简单举例123456function* generator(i) &#123; return i+1;&#125;const gen = generator(3);console.log(gen.next());// &#123;value: 4, done: true&#125; 生成器函数不能作为构造函数使用 1234function* Test() &#123; // some operation&#125;const newTest = new Test(); 生成器函数的特性1、调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （ iterator ）对象。通过next()方法获取返回值 2、next()方法返回一个对象，这个对象包含两个属性：value 和 done, done为true表示函数完成，为false函数未完成，可继续调用next方法 生成器函数的相关特性1、yieldyield 关键字用于暂停和恢复生成器函数。 1234567891011121314function* testYield() &#123; for (let num = 0; num &lt; 3; num++) &#123; yield num; &#125;&#125;const result = testYield();console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());// &#123; value: 0, done: false &#125;// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: undefined, done: true &#125; yield 关键字使生成器函数执行暂停，yield 关键字后面的表达式的值返回给生成器的调用者，即表达式的值为返回对象中的value。它可以被认为是一个基于生成器的版本的 return 关键字。 返回： IteratorResult 对象 value done 一旦遇到 yield 表达式，生成器的代码将被暂停运行，直到生成器的 next() 方法被调用。每次调用生成器的 next() 方法时，生成器都会恢复执行，直到达到以下某个值： yield：导致生成器再次暂停并返回生成器的新值。下一次调用 next() 时，在 yield 之后紧接着的语句继续执行。 throw：用于从生成器中抛出异常。这让生成器完全停止执行，并在调用者中继续执行，正如通常情况下抛出异常一样。 到达生成器函数的结尾.在这种情况下，生成器的执行结束，并且 IteratorResult 给调用者返回 value 的值是 undefined 并且 done 为 true。 到达 return 语句。在这种情况下，生成器的执行结束，并将 IteratorResult 返回给调用者，其 value 的值是由 return 语句指定的，并且 done 为 true。123456789101112131415161718192021222324252627282930// throwfunction* testYield() &#123; for (let num = 0; num &lt; 3; num++) &#123; yield num; &#125;&#125;const result = testYield();console.log(result.next());console.log(result.throw(new Error(&#x27;1&#x27;)));console.log(result.next());console.log(result.next());// &#123; value: 0, done: false &#125;// Error: 1// returnfunction* testYield() &#123; for (let num = 0; num &lt; 3; num++) &#123; yield num; return 45; &#125;&#125;const result = testYield();console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());// &#123; value: 0, done: false &#125;// &#123; value: 45, done: true &#125;// &#123; value: undefined, done: true &#125;// &#123; value: undefined, done: true &#125; 如果将参数传递给生成器的 next() 方法，则该值将成为生成器当前 yield 操作返回的值 注意：第一个next只是为了启动生成器，传递的参数不起作用 123456789101112function* testYield() &#123; let num = 0; while (true) &#123; const result = yield num; console.log(result); &#125;&#125;const result = testYield();console.log(result.next(2)); // no result returnconsole.log(result.next(3)); // result: 3console.log(result.next(6)); // result: 6console.log(result.next()); 2、yield*用于委托给另一个generator或可迭代对象 yield* 表达式迭代操作数，并产生它返回的每个值。 yield* 表达式本身的值是当迭代器关闭时返回的值（即done为true时）。 yield* 还可以 yield 其他任意的可迭代对象，比如说数组、字符串、arguments 对象等等。12345678910111213141516171819202122232425262728293031323334353637383940414243444546// eg:onefunction* testOne() &#123; yield 1; yield 4;&#125;function* testTwo() &#123; yield 2; yield* testOne(); yield 3;&#125;const result = testTwo();console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: 3, done: false &#125;// &#123; value: 4, done: false &#125;// &#123; value: undefined, done: true &#125;// eg:twofunction* test () &#123; yield* [1,2]; yield* &#x27;3,4&#x27;; yield* arguments;&#125;const result = test(5, 6);console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());console.log(result.next());// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: &#x27;3&#x27;, done: false &#125;// &#123; value: &#x27;,&#x27;, done: false &#125;// &#123; value: &#x27;4&#x27;, done: false &#125;// &#123; value: 5, done: false &#125;// &#123; value: 6, done: false &#125;// &#123; value: undefined, done: true &#125; 调用 next()方法时，如果传入了参数，那么这个参数会传给上一条执行的 yield 语句左边的变量 123456789101112131415function* test() &#123; yield 1; const x = yield &#x27;one&#x27;; yield x;&#125;var result = test();console.log(result.next());console.log(result.next());console.log(result.next(100));console.log(result.next());// &#123; value: 1, done: false &#125;// &#123; value: &#x27;one&#x27;, done: false &#125;// &#123; value: 100, done: false &#125;// &#123; value: undefined, done: true &#125; 生成器函数的作用生成器函数是ES6引入的新特性 延迟执行：生成器可以在需要时逐个生成值，而不是一次性生成所有值。这种延迟执行可以节省内存和提高性能。无限序列：生成器可以用来创建无限序列，如斐波那契数列或素数序列，这些序列通常很难使用常规方法来实现。异步编程：生成器可以用来实现异步编程，通过使用生成器来实现异步函数，可以更方便地处理异步调用和异步错误。迭代器：生成器可以用来创建迭代器，使得对集合的遍历变得更加方便和可读。生成器协程：生成器可以用作协程，在 JavaScript 中实现类似线程的功能，从而实现更高级的并发和并行编程。 举例 1234567891011121314function* iterArr(arr) &#123; if (Array.isArray(arr)) &#123; for(let i=0; i &lt; arr.length; i++) &#123; yield* iterArr(arr[i]); &#125; &#125; else &#123; yield arr; &#125;&#125;let arr = [ &#x27;a&#x27;, [&#x27;b&#x27;,[ &#x27;c&#x27;, [&#x27;d&#x27;, &#x27;e&#x27;]]]];const result = iterArr(arr);arr = [...result];console.log(arr);// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ] 参考文献MDN: 生成器函数 issue: co,执行生成器函数的库 生成器函数的回收机制 实现异步的操作，生成器函数比较鸡肋，使用async、await 生成器函数是目前js中唯一可以实现暂停执行的方法","categories":[],"tags":[]},{"title":"linux系统进程相关笔记","slug":"46-linux-process","date":"2023-01-17T02:45:24.000Z","updated":"2023-08-03T03:04:54.515Z","comments":true,"path":"2023/01/17/46-linux-process/","link":"","permalink":"https://sunjinkang.github.io/2023/01/17/46-linux-process/","excerpt":"查看进程ps","text":"查看进程ps ps aux ps -elf 字段说明： USER：启动该进程的用户账号名称 PID：该进程的ID号，在当前系统中是唯一的 %CPU：CPU占用的百分比 %MEM：内存占用的百分比 VSZ：占用虚拟内存（swap空间）的大小 RSS：占用常驻内存（物理内存）的大小 TTY：该进程在哪个终端上运行。“？”表未知或不需要终端 STAT：显示了进程当前的状态， S（休眠）: 进程在等待事件完成，如socket连接，等待信号量唤醒等等，也叫可中断睡眠。 R（运行）: 进程要么在运行，要么在运行队列中，等待被OS分配时间片（调度） Z（僵死）: 子程序已停止，父程序无法读取子程序结束信息, 对处于僵死状态的进程应予以手动终止。 D（休眠）: 不可中断的状态，又叫不可中断睡眠状态，通常等待I/O结束并告知其 T（停止）: 目前进程正在侦测或停止，可以通过发送 SIGSTOP 信号给进程来停止（T）进程。这个被暂停的进程可以通过发送 SIGCONT 信号让进程继续运行。 X（死亡）: 只是一个返回状态，你不会在任务列表里看到这个状态。当父进程读取子进程的返回结果时，子进程立刻释放资源。死亡状态是非常短暂的，几乎不可能通过ps命令捕捉到。 &lt;（高优先级） N（低优先级） L（进程有页面文件锁定在进程中） s（进程为控制进程，如systemd进程） +（前台进程，后台运行在命令之后加 &amp;） I（多线程） START：启动该进程的时间 TIME：该进程占用CPU时间 COMMAND：启动该进程的命令的名称 PPID为父进程的PID top Tasks（系统任务）信息： total，总进程数； running，正在运行的进程数； sleeping，休眠的进程数； stopped，中止的进程数； zombie，僵死无响应的进程数。 CPU信息： us，用户占用； sy，内核占用； ni，优先级调度占用； id，空闲CPU；了解空闲的CPU百分比，主要看%id部分 wa，I/O等待占用； hi，硬件中断占用； si，软件中断占用； st，虚拟化占用。 Mem（内存）信息： total，总内存空间； used，已用内存； free，空闲内存； buffers，缓存区域。 Swap（交换空间）信息： total，总交换空间； used，已用交换空间； free，空闲交换空间； cached，缓存空间。","categories":[],"tags":[]},{"title":"linux系统常见操作命令","slug":"45-linux-common-command","date":"2023-01-17T02:17:43.000Z","updated":"2023-08-03T03:04:45.288Z","comments":true,"path":"2023/01/17/45-linux-common-command/","link":"","permalink":"https://sunjinkang.github.io/2023/01/17/45-linux-common-command/","excerpt":"查看进程ps ps aux a：显示当前终端下的所有进程信息，包括其他用户的进程。 u：使用以用户为主的格式输出进程信息。 x：显示当前用户在所有终端下的进程。 ps -elf -e：显示系统内的所有进程信息。 -l：使用长（long）格式显示进程信息。 -f：使用完整的（full）格式显示进程信息。","text":"查看进程ps ps aux a：显示当前终端下的所有进程信息，包括其他用户的进程。 u：使用以用户为主的格式输出进程信息。 x：显示当前用户在所有终端下的进程。 ps -elf -e：显示系统内的所有进程信息。 -l：使用长（long）格式显示进程信息。 -f：使用完整的（full）格式显示进程信息。 top以全屏交互式的界面显示进程排名，及时跟踪包括CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次 pstreepstree -aup以树状图的方式展现进程之间的派生关系，显示效果比较直观。 -a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示； -c：不使用精简标示法； -G：使用VT100终端机的列绘图字符； -h：列出树状图时，特别标明现在执行的程序； -H&lt;程序识别码&gt;：此参数的效果和指定”-h”参数类似，但特别标明指定的程序； -l：采用长列格式显示树状图； -n：用程序识别码排序。预设是以程序名称来排序； -p：显示程序识别码； -u：显示用户名称； 带筛选条件查看进程ps aux | grep xxxxx","categories":[],"tags":[]},{"title":"关于grid布局的相关内容","slug":"44-about-grid","date":"2023-01-03T07:28:21.000Z","updated":"2023-08-03T03:04:36.225Z","comments":true,"path":"2023/01/03/44-about-grid/","link":"","permalink":"https://sunjinkang.github.io/2023/01/03/44-about-grid/","excerpt":"什么是grid布局？怎么实现grid布局？grid布局的好处grid布局中一些常用设置说明 grid-row: grid-row-start / grid-row-end; grid-row-start 指定在哪一行开始显示网格元素。 grid-row-end 指定停止显示网格元素的行，或要跨越多少行。","text":"什么是grid布局？怎么实现grid布局？grid布局的好处grid布局中一些常用设置说明 grid-row: grid-row-start / grid-row-end; grid-row-start 指定在哪一行开始显示网格元素。 grid-row-end 指定停止显示网格元素的行，或要跨越多少行。 123456789/* 设置 &quot;item1&quot; 在第 1 行开始，在第 4 行前结束 */.item1 &#123; grid-row: 1 / 4;&#125;/* 可以参考行号来设置网格元素，也可以使用关键字 &quot;span&quot; 来定义元素将跨越的行数。 *//* 设置 &quot;item1&quot; 跨越两行 */.item1 &#123; grid-row: 1 / span 2;&#125; grid-template-columns 规定网格布局中的列数（和宽度）12345678/* 设置三列，每列10px */.grid-container &#123; grid-template-columns: 10px 10px 10px;&#125;/* 设置四列，每列宽度自适应 */.grid-container &#123; grid-template-columns: auto auto auto auto;&#125; repeat() 函数表示轨道列表的重复片段，允许以更紧凑的形式写入大量显示重复模式的列或行。 该函数可以用于 CSS Grid 属性中 grid-template-columns 和 grid-template-rows。12345/* repeat(4, 1fr) *//* 设置四列，每列均分 */.grid-container &#123; grid-template-columns: repeat(4, 1fr);&#125; fr 一种新的长度单位 fr(fraction)。它表示 Grid 布局中中剩余空间(leftover space)的一部分(fraction)。 一般来说 1fr 的意思是“100%的剩余空间”, .25fr 意味着“25%的剩余空间”。当时当 fr 大于 1 的时候，则会重新计算比例来分配 一般都建议使用 fr&gt;=1 的情况, 比如说 1fr 2fr 就比 .33fr .67fr 可读性更强。","categories":[],"tags":[]},{"title":"前端压缩图片方法-canvas.toDataURL & canvas.toBlob","slug":"43-compress-picture","date":"2022-12-08T08:48:13.000Z","updated":"2023-08-03T03:04:25.342Z","comments":true,"path":"2022/12/08/43-compress-picture/","link":"","permalink":"https://sunjinkang.github.io/2022/12/08/43-compress-picture/","excerpt":"为什么压缩图片？浏览器在加载页面的时候，图片也是影响请求前端用户体验的一环：如果图片较大，请求耗时越长，那页面会长时间处于加载中或者白屏状态，导致用户体验较差。所以压缩图片就成了一种比较常用的优化前端性能的手段。 压缩图片方法 第一种：将图片传给后端，后端进行压缩 第二种：使用canvas压缩图片思路： 通过获取二进制图片 使用 FileReader 把二进制图片转换成base64格式，用于生成 Image 对象 把图片绘制成 Canvas（这一步可以对图片尺寸进行压缩，这一步压缩效率最高，图片尺寸是最影响图片大小的） 将Canvas 再转成 base64 图片（这一步可以对图片质量进行压缩）","text":"为什么压缩图片？浏览器在加载页面的时候，图片也是影响请求前端用户体验的一环：如果图片较大，请求耗时越长，那页面会长时间处于加载中或者白屏状态，导致用户体验较差。所以压缩图片就成了一种比较常用的优化前端性能的手段。 压缩图片方法 第一种：将图片传给后端，后端进行压缩 第二种：使用canvas压缩图片思路： 通过获取二进制图片 使用 FileReader 把二进制图片转换成base64格式，用于生成 Image 对象 把图片绘制成 Canvas（这一步可以对图片尺寸进行压缩，这一步压缩效率最高，图片尺寸是最影响图片大小的） 将Canvas 再转成 base64 图片（这一步可以对图片质量进行压缩） toDataURL canvas对象的一种方法，用于将canvas对象转换为base64位编码. 转化实现：将图片绘制到canvas中，然后将canvas对象转换为base64编码，从而实现图片转为base64编码； 转换为base64位编码的好处： 将图片转换为base64位编码后，图片会跟随代码（html、css、js）一起请求加载，不会再单独进行请求加载； 可以防止由于图片路径错误导致图片加载失败的问题； 注意事项： 如果画布的高度或宽度是 0，那么会返回字符串“data:,” 参数：toDataURL(type, encoderOptions) type指定转换为base64编码后图片的格式，如：image/png、image/jpeg、image/webp等等，默认为image/png格式； encoderOptions用于设置转换为base64编码后图片的质量，在指定图片格式为 image/jpeg 或 image/webp 的情况下，取值范围为0-1，超出取值范围用默认值0.92代替；MDN HTMLCanvasElement.toDataURL() toBlob 创造 Blob 对象，用以展示 canvas 上的图片 参数：toBlob(callback, type, quality) callback：回调函数，可获得一个单独的 Blob 对象参数。如果图像未被成功创建，可能会获得 null 值 type(可选): DOMString 类型，指定图片格式，默认格式（未指定或不支持）为 image/png quality(可选): Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略MDN HTMLCanvasElement.toBlob() toDataURL和toBlob的差异与共同点 差异 绘制处理图片的过程不同： toBlob是直接将canvas中绘制的图形转换成Blob实例对象，再将Blob实例对象转成File实例对象即可 toDataURL则是将canvas中绘制的图形转成base64编码的字符串，然后再将base64编码的字符串转成File的实例对象 结果不同： toBlob无返回值，通过传参中的回调函数，可获得一个单独的 Blob 对象参数 toDataURL返回一个包含 data URI 的DOMString 执行不同： toDataURL是同步执行的，执行操作的时候会阻止UI toBlob通过回调函数获取返回值，非阻塞方式进行图像格式转换 toDataURL结果比toBlob占用更多的内存，toDataURL包含在base64中压缩的完整二进制数据，base64编码本身意味着二进制数据比现在大37％ 共同点 canvas方法，在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92 1234567891011121314151617181920// toBlobcanvas.toBlob( function (b) &#123; let compressUrl = URL.createObjectURL(b); //压缩后的文件url let fileName = imgFile.name.substring(0, imgFile.name.lastIndexOf(&#x27;.&#x27;)) + &#x27;.&#x27; + imgType.split(&#x27;/&#x27;)[1]; //重构文件名 let file = blobToFile(b, fileName, imgType); //Blob实例转成File实例 resolve(&#123; url: compressUrl, file: file, &#125;); imgCanvas = null; //释放内存 &#125;, imgType, quality);// toDataURLcanvas.toDataURL(imgType, quality);","categories":[],"tags":[]},{"title":"scrollIntoView参数项说明","slug":"42-scrollInToView-params","date":"2022-11-10T02:39:52.000Z","updated":"2023-08-03T03:04:18.699Z","comments":true,"path":"2022/11/10/42-scrollInToView-params/","link":"","permalink":"https://sunjinkang.github.io/2022/11/10/42-scrollInToView-params/","excerpt":"scrollIntoView作用element.scrollIntoView滚动元素的父容器，使被调用scrollIntoView的元素对用户可见2，即滚动到可视区域 scrollIntoView用法element.scrollIntoView()等同于element.scrollIntoView(true)","text":"scrollIntoView作用element.scrollIntoView滚动元素的父容器，使被调用scrollIntoView的元素对用户可见2，即滚动到可视区域 scrollIntoView用法element.scrollIntoView()等同于element.scrollIntoView(true) element.scrollIntoView(boolean) boolean为true 元素的顶端将和其所在滚动区域的可视区域的顶端对齐 与element.scrollIntoView({ block: “start”, inline: ‘nearest’})等价 boolean为false 元素的底端将和其所在滚定区域的可视区域的底端对齐 与element.scrollIntoView({ block: “end”, inline: ‘nearest’})等价 element.scrollIntoView(options)options为一个对象，属性如下： behavior 定义动画过渡效果 值为： auto(默认值)，无平滑滚动效果 smooth，有平滑的滚动效果 block 定义垂直方向的对齐 值为： start: 默认值，顶端对齐 center：中间对齐 end：底端对齐 nearest：如果元素完全在可视区域内，则垂直方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，垂直方向滚动父级容器，使元素完全在可视区域内。 inline 定义水平方向的对齐 值为： start：左端对齐 center：中间对齐 end：右端对齐 nearest: 默认值，如果元素完全在可视区域内，则水平方向不发生滚动。如果元素未能完全在可视区域内，则根据最短滚动距离原则，水平方向滚动父级容器，使元素完全在可视区域内。 注意：取决于其他元素的布局情况，此元素可能不会完全滚动到顶端或底端","categories":[],"tags":[]},{"title":"42-js-equal-type","slug":"41-js-equal-type","date":"2022-10-26T06:24:02.000Z","updated":"2023-07-24T09:24:46.455Z","comments":true,"path":"2022/10/26/41-js-equal-type/","link":"","permalink":"https://sunjinkang.github.io/2022/10/26/41-js-equal-type/","excerpt":"","text":"javascript中的相等比较算法","categories":[],"tags":[]},{"title":"尾调用与尾递归","slug":"40-tail-call","date":"2022-10-17T02:26:13.000Z","updated":"2023-08-08T02:52:54.022Z","comments":true,"path":"2022/10/17/40-tail-call/","link":"","permalink":"https://sunjinkang.github.io/2022/10/17/40-tail-call/","excerpt":"什么是尾调用？某个函数的最后一步调用另一个函数 1234567891011121314151617181920212223242526function call1(a) &#123; return call2(a);&#125;// 以下三种情况不属于尾调用！！！// 函数调用后还有其他操作function call1(a) &#123; const x = call2(a); return x;&#125;function call1(a) &#123; return call2(a) + 1;&#125;function call1(a) &#123; call2(a);&#125;// 以下属于尾调用function call1(a) &#123; if (!!a) &#123; return call2(a); &#125; return call3(a);&#125;","text":"什么是尾调用？某个函数的最后一步调用另一个函数 1234567891011121314151617181920212223242526function call1(a) &#123; return call2(a);&#125;// 以下三种情况不属于尾调用！！！// 函数调用后还有其他操作function call1(a) &#123; const x = call2(a); return x;&#125;function call1(a) &#123; return call2(a) + 1;&#125;function call1(a) &#123; call2(a);&#125;// 以下属于尾调用function call1(a) &#123; if (!!a) &#123; return call2(a); &#125; return call3(a);&#125; 尾调用优化注意：尾调用优化是否方便可行取决于运行环境对此类优化的支持度 函数调用会在内存中形成一个‘调用记录’，又称为‘调用帧’。用来保存调用位置和内存变量等信息。如果A函数内部调用B函数，在A的调用记录上，会生成一个B的调用记录，等到B运行结束，将结果返回给A，B的调用记录才会消失。如果B的内部还调用C，那么在B上面会形成一个C的调用记录，以此类推。所有的调用记录，形成了一个‘调用栈’(call stack)。 但是，尾调用由于是函数调用的最后一步操作，所以不需要保存外部函数的调用记录，因为调用位置、内部变量等信息都不会再用到，只要直接用内层函数的调用记录，取代外层函数调用记录就可以了。所以，如果所有函数都是尾调用，那么每次执行的时候，只需要记录一项调用记录，从而节省大量内存，即‘尾调用优化’。 注意：只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行‘尾调用优化’ 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存许多调用记录，很容易发生‘栈溢出’错误(stack overflow)。但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生‘栈溢出’错误。 1234567891011121314151617181920// 阶乘计算// 复杂度 O(n)function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;// 复杂度O(1)function factorial(n, total) &#123; if (n === 1) return total; return factorial(n -1, n* total);&#125;factorial(5, 1);// factorial(5, 1);// factorial(4, 5);// factorial(3, 20);// factorial(2, 60);// factorial(1, 120);// 120 递归函数的改写优化尾递归的实现，需要将所有用到的内部参数变量改写成函数的参数，不过直接修改的函数往往不太直观，一般采用以下两种方法解决： (1) 除尾递归函数外，在提供一个正常形式的函数，通过正常表现的函数调用递归函数 12345678910function tailCall(n, total) &#123; if (n === 1) return total; return tailCall(n -1, n*total);&#125;function call(n) &#123; return tailCall(n, 1);&#125;call(5); (2) 使用柯理化，将多参数的函数转化为单参数形式 1234567891011121314151617181920function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;&#125;function tailCall(n, total) &#123; if (n === 1) return total; return tailCall(n -1, n*total);&#125;const factorial = currying(tailCall, 1);factorial(5);// 或者使用ES6函数默认值function factorial(n, total = 1) &#123; if (n === 1) return total; return tailCall(n -1, n*total);&#125;factorial(5); ES6的尾调用优化只在严格模式下开启，正常模式无效正常模式下，函数内部有两个变量，可以跟踪函数的调用栈 arguments 返回调用时函数的参数 func.caller 返回调用当前函数的那个函数尾调用优化发生时，函数调用栈会改写，上面两个变量会失真。严格模式禁用这两个变量，所以尾调用仅在严格模式下生效。 尾调用-维基百科","categories":[],"tags":[]},{"title":"数据结构与算法阅读笔记(7)","slug":"39-data-structure7","date":"2022-10-13T08:13:40.000Z","updated":"2023-08-03T03:03:56.605Z","comments":true,"path":"2022/10/13/39-data-structure7/","link":"","permalink":"https://sunjinkang.github.io/2022/10/13/39-data-structure7/","excerpt":"算法设计与技巧分而治之将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题 分而治之算法可以分成三个部分。(1) 分解原问题为多个子问题（原问题的多个小实例）。(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。(3) 组合这些子问题的解决方式，得到原问题的解。","text":"算法设计与技巧分而治之将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将解决方式合并以解决原来的问题 分而治之算法可以分成三个部分。(1) 分解原问题为多个子问题（原问题的多个小实例）。(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子问题。(3) 组合这些子问题的解决方式，得到原问题的解。 二分搜索分解：计算 mid 并搜索数组较小或较大的一半。解决：在较小或较大的一半中搜索值。合并：这步不需要，因为我们直接返回了索引值。 12345678910111213141516171819202122232425262728function binarySearchRecursive( array, value, low, high, compareFn = defaultCompare) &#123; if (low &lt;= high) &#123; const mid = Math.floor((low + high) / 2); const element = array[mid]; if (compareFn(element, value) === Compare.LESS_THAN) &#123; // &#123;1&#125; return binarySearchRecursive(array, value, mid + 1, high, compareFn); &#125; else if (compareFn(element, value) === Compare.BIGGER_THAN) &#123; // &#123;2&#125; return binarySearchRecursive(array, value, low, mid - 1, compareFn); &#125; else &#123; return mid; // &#123;3&#125; &#125; &#125; return DOES_NOT_EXIST; // &#123;4&#125;&#125;export function binarySearch(array, value, compareFn = defaultCompare) &#123; const sortedArray = quickSort(array); const low = 0; const high = sortedArray.length - 1; return binarySearchRecursive(array, value, low, high, compareFn);&#125; 动态规划动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优化技术。 注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子问题。 步骤：(1) 定义子问题；(2) 实现要反复执行来解决子问题的部分；(3) 识别并求解出基线条件。 能用动态规划解决的一些著名问题如下。(1)背包问题：给出一组项，各自有值和容量，目标是找出总值最大的项的集合。这个问题的限制是，总容量必须小于等于“背包”的容量。(2)最长公共子序列：找出一组序列的最长公共子序列（可由另一序列删除元素但不改变余下元素的顺序而得到）。(3)矩阵链相乘：给出一系列矩阵，目标是找到这些矩阵相乘的最高效办法（计算次数尽可能少）。相乘运算不会进行，解决方案是找到这些矩阵各自相乘的顺序。(4)硬币找零：给出面额为 d1, …, dn 的一定数量的硬币和要找零的钱数，找出有多少种找零的方法。(5)图的全源最短路径：对所有顶点对(u, v)，找出从顶点 u 到顶点 v 的最短路径。(Floyd-Warshall 算法) 最少硬币找零问题最少硬币找零问题是硬币找零问题的一个变种。硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找出有多少种找零方法。最少硬币找零问题是给出要找零的钱数，以及可用的硬币面额 d1, …, dn 及其数量，找到所需的最少的硬币个数。 123456789101112131415161718192021222324252627282930313233343536// coins 硬币面额的数组function minCoinChange(coins, amount) &#123; const cache = []; // &#123;1&#125; const makeChange = (value) =&gt; &#123; // &#123;2&#125; if (!value) &#123; // &#123;3&#125; return []; &#125; if (cache[value]) &#123; // &#123;4&#125; return cache[value]; &#125; let min = []; let newMin; let newAmount; for (let i = 0; i &lt; coins.length; i++) &#123; // &#123;5&#125; const coin = coins[i]; newAmount = value - coin; // &#123;6&#125; if (newAmount &gt;= 0) &#123; newMin = makeChange(newAmount); // &#123;7&#125; &#125; if ( newAmount &gt;= 0 &amp;&amp; // &#123;8&#125; (newMin.length &lt; min.length - 1 || !min.length) &amp;&amp; // &#123;9&#125; (newMin.length || !newAmount) // &#123;10&#125; ) &#123; min = [coin].concat(newMin); // &#123;11&#125; console.log(&#x27;new Min &#x27; + min + &#x27; for &#x27; + amount); &#125; &#125; return (cache[value] = min); // &#123;12&#125; &#125;; return makeChange(amount); // &#123;13&#125;&#125; 背包问题背包问题是一个组合优化问题。它可以描述如下：给定一个固定大小、能够携重量 W 的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过 W，且总价值最大。 123456789101112131415161718192021222324252627282930313233343536373839404142function knapSack(capacity, weights, values, n) &#123; const kS = []; // 初始化将用于寻找解决方案的矩阵 for (let i = 0; i &lt;= n; i++) &#123; kS[i] = []; &#125; for (let i = 0; i &lt;= n; i++) &#123; for (let w = 0; w &lt;= capacity; w++) &#123; if (i === 0 || w === 0) &#123; // &#123;2&#125; kS[i][w] = 0; &#125; else if (weights[i - 1] &lt;= w) &#123; // 。物品 i 的重量必须小于约束 const a = values[i - 1] + kS[i - 1][w - weights[i - 1]]; const b = kS[i - 1][w]; // 当找到可以构成解决方案的物品时，选择价值最大的那个 kS[i][w] = a &gt; b ? a : b; // &#123;4&#125; max(a,b) &#125; else &#123; kS[i][w] = kS[i - 1][w]; // &#123;5&#125; &#125; &#125; &#125; findValues(n, capacity, kS, weights, values); // &#123;6&#125; 增加的代码 return kS[n][capacity]; // &#123;7&#125;&#125;function findValues(n, capacity, kS, weights, values) &#123; let i = n; let k = capacity; console.log(&#x27;构成解的物品：&#x27;); while (i &gt; 0 &amp;&amp; k &gt; 0) &#123; if (kS[i][k] !== kS[i - 1][k]) &#123; console.log( `物品 $&#123;i&#125; 可以是解的一部分 w,v: $&#123;weights[i - 1]&#125;, $&#123;values[i - 1]&#125;` ); i--; k -= kS[i][k]; &#125; else &#123; i--; &#125; &#125;&#125; 最长公共子序列(LCS)找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function lcs(wordX, wordY) &#123; const m = wordX.length; const n = wordY.length; const l = []; for (let i = 0; i &lt;= m; i++) &#123; l[i] = []; // &#123;1&#125; // solution[i] = []; for (let j = 0; j &lt;= n; j++) &#123; l[i][j] = 0; // &#123;2&#125; // solution[i][j] = &#x27;0&#x27;; &#125; &#125; for (let i = 0; i &lt;= m; i++) &#123; for (let j = 0; j &lt;= n; j++) &#123; if (i === 0 || j === 0) &#123; l[i][j] = 0; &#125; else if (wordX[i - 1] === wordY[j - 1]) &#123; l[i][j] = l[i - 1][j - 1] + 1; // &#123;3&#125; // solution[i][j] = &#x27;diagonal&#x27;; &#125; else &#123; const a = l[i - 1][j]; const b = l[i][j - 1]; l[i][j] = a &gt; b ? a : b; // &#123;4&#125; max(a,b) // solution[i][j]=(l[i][j] == l[i-1][j]) ? &#x27;top&#x27; : &#x27;left&#x27;; &#125; &#125; &#125; return l[m][n]; // &#123;5&#125; // printSolution(solution, wordX, m, n);&#125;function printSolution(solution, wordX, m, n) &#123; let a = m; let b = n; let x = solution[a][b]; let answer = &#x27;&#x27;; while (x !== &#x27;0&#x27;) &#123; if (solution[a][b] === &#x27;diagonal&#x27;) &#123; answer = wordX[a - 1] + answer; a--; b--; &#125; else if (solution[a][b] === &#x27;left&#x27;) &#123; b--; &#125; else if (solution[a][b] === &#x27;top&#x27;) &#123; a--; &#125; x = solution[a][b]; &#125; console.log(&#x27;lcs: &#x27; + answer);&#125; 矩阵链相乘要找出一组矩阵相乘的最佳方式（顺序） ABC*D 的乘法 A 是一个 10 行 100 列的矩阵；B 是一个 100 行 5 列的矩阵；C 是一个 5 行 50 列的矩阵；D 是一个 50 行 1 列的矩阵；ABC*D 的结果是一个 10 行 1 列的矩阵 (1) (A(B(CD)))：乘法运算的次数是 1750 次。(2) ((AB)(CD))：乘法运算的次数是 5300 次。(3) (((AB)C)D)：乘法运算的次数是 8000 次。(4) ((A(BC))D)：乘法运算的次数是 75 500 次。(5) (A((BC)D))：乘法运算的次数是 31 000 次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function matrixChainOrder(p) &#123; const n = p.length; const m = []; const s = []; for (let i = 1; i &lt;= n; i++) &#123; m[i] = []; m[i][i] = 0; &#125; // const s = []; // for (let i = 0; i &lt;= n; i++)&#123; // s[i] = []; // for (let j=0; j &lt;= n; j++)&#123; // s[i][j] = 0; // &#125; // &#125; for (let l = 2; l &lt; n; l++) &#123; for (let i = 1; i &lt;= n - l + 1; i++) &#123; const j = i + l - 1; m[i][j] = Number.MAX_SAFE_INTEGER; for (let k = i; k &lt;= j - 1; k++) &#123; const q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j]; // &#123;1&#125; if (q &lt; m[i][j]) &#123; m[i][j] = q; // &#123;2&#125; // s[i][j] = k; &#125; &#125; &#125; &#125; return m[1][n - 1]; // &#123;3&#125; // printOptimalParenthesis(s, 1, n-1);&#125;function printOptimalParenthesis(s, i, j) &#123; if (i === j) &#123; console.log(&#x27;A[&#x27; + i + &#x27;]&#x27;); &#125; else &#123; console.log(&#x27;(&#x27;); printOptimalParenthesis(s, i, s[i][j]); printOptimalParenthesis(s, s[i][j] + 1, j); console.log(&#x27;)&#x27;); &#125;&#125;// (A[1](A[2](A[3]A[4]))) =&gt; (A(B(CD))) 贪心算法贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。 最少硬币找零问题 1234567891011121314function minCoinChange(coins, amount) &#123; const change = []; let total = 0; for (let i = coins.length; i &gt;= 0; i--) &#123; // &#123;1&#125; const coin = coins[i]; while (total + coin &lt;= amount) &#123; // &#123;2&#125; change.push(coin); // &#123;3&#125; total += coin; // &#123;4&#125; &#125; &#125; return change;&#125; 比起动态规划算法而言，贪心算法更简单、更快。然而，它并不总是得到最优答案。但是综合来看，它相对执行时间来说，输出了一个可以接受的解。 分数背包问题 123456789101112131415161718function knapSack(capacity, weights, values) &#123; const n = values.length; let load = 0; let val = 0; for (let i = 0; i &lt; n &amp;&amp; load &lt; capacity; i++) &#123; // &#123;1&#125; if (weights[i] &lt;= capacity - load) &#123; // &#123;2&#125; val += values[i]; load += weights[i]; &#125; else &#123; const r = (capacity - load) / weights[i]; // &#123;3&#125; val += r * values[i]; load += weights[i]; &#125; &#125; return val;&#125; 回溯算法回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。 迷宫老鼠问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162export function ratInAMaze(maze) &#123; const solution = []; // 每个位置初始化为零 for (let i = 0; i &lt; maze.length; i++) &#123; // &#123;1&#125; solution[i] = []; for (let j = 0; j &lt; maze[i].length; j++) &#123; solution[i][j] = 0; &#125; &#125; if (findPath(maze, 0, 0, solution) === true) &#123; // &#123;2&#125; return solution; &#125; return &#x27;NO PATH FOUND&#x27;; // &#123;3&#125;&#125;function findPath(maze, x, y, solution) &#123; const n = maze.length; if (x === n - 1 &amp;&amp; y === n - 1) &#123; // &#123;4&#125; solution[x][y] = 1; return true; &#125; if (isSafe(maze, x, y) === true) &#123; // &#123;5&#125; solution[x][y] = 1; // &#123;6&#125; if (findPath(maze, x + 1, y, solution)) &#123; // &#123;7&#125; return true; &#125; if (findPath(maze, x, y + 1, solution)) &#123; // &#123;8&#125; return true; &#125; solution[x][y] = 0; // &#123;9&#125; return false; &#125; return false; // &#123;10&#125;&#125;function isSafe(maze, x, y) &#123; const n = maze.length; if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; n &amp;&amp; maze[x][y] !== 0) &#123; return true; // &#123;11&#125; &#125; return false;&#125;const maze = [ [1, 0, 0, 0], [1, 1, 1, 1], [0, 0, 1, 0], [0, 1, 1, 1],];console.log(ratInAMaze(maze));[ [1, 0, 0, 0], [1, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 1],]; 数独解题器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103function sudokuSolver(matrix) &#123; if (solveSudoku(matrix) === true) &#123; return matrix; &#125; return &#x27;问题无解！&#x27;;&#125;const UNASSIGNED = 0;function solveSudoku(matrix) &#123; let row = 0; let col = 0; let checkBlankSpaces = false; for (row = 0; row &lt; matrix.length; row++) &#123; // &#123;1&#125; for (col = 0; col &lt; matrix[row].length; col++) &#123; if (matrix[row][col] === UNASSIGNED) &#123; checkBlankSpaces = true; // &#123;2&#125; break; &#125; &#125; if (checkBlankSpaces === true) &#123; // &#123;3&#125; break; &#125; &#125; if (checkBlankSpaces === false) &#123; return true; // &#123;4&#125; &#125; for (let num = 1; num &lt;= 9; num++) &#123; // &#123;5&#125; if (isSafe(matrix, row, col, num)) &#123; // &#123;6&#125; matrix[row][col] = num; // &#123;7&#125; if (solveSudoku(matrix)) &#123; // &#123;8&#125; return true; &#125; matrix[row][col] = UNASSIGNED; // &#123;9&#125; &#125; &#125; return false; // &#123;10&#125;&#125;function isSafe(matrix, row, col, num) &#123; return ( !usedInRow(matrix, row, num) &amp;&amp; !usedInCol(matrix, col, num) &amp;&amp; !usedInBox(matrix, row - (row % 3), col - (col % 3), num) );&#125;function usedInRow(matrix, row, num) &#123; for (let col = 0; col &lt; matrix.length; col++) &#123; // &#123;11&#125; if (matrix[row][col] === num) &#123; return true; &#125; &#125; return false;&#125;function usedInCol(matrix, col, num) &#123; for (let row = 0; row &lt; matrix.length; row++) &#123; // &#123;12&#125; if (matrix[row][col] === num) &#123; return true; &#125; &#125; return false;&#125;function usedInBox(matrix, boxStartRow, boxStartCol, num) &#123; for (let row = 0; row &lt; 3; row++) &#123; for (let col = 0; col &lt; 3; col++) &#123; if (matrix[row + boxStartRow][col + boxStartCol] === num) &#123; // &#123;13&#125; return true; &#125; &#125; &#125; return false;&#125;const sudokuGrid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9],];console.log(sudokuSolver(sudokuGrid));[ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9],]; 函数式编程(FP)简介函数式编程与命令式编程 123456789101112131415161718// 命令式编程const printArray = function (array) &#123; for (var i = 0; i &lt; array.length; i++) &#123; console.log(array[i]); &#125;&#125;;printArray([1, 2, 3, 4, 5]);// 函数式编程const forEach = function (array, action) &#123; for (var i = 0; i &lt; array.length; i++) &#123; action(array[i]); &#125;&#125;;const logItem = function (item) &#123; console.log(item);&#125;;forEach([1, 2, 3, 4, 5], logItem); 注意：(1)函数式编程的主要目标是描述数据，以及要对数据应用的转换。(2)在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常重要的。(3)函数和数据集合是函数式编程的核心。(4)在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、赋值、条件和函数。(5)在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。 JavaScript 函数式类库和数据结构Underscode.js：http://underscorejs.org/Bilby.js：http://bilby.brianmckenna.org/Lazy.js：http://danieltao.com/lazy.js/Bacon.js：https://baconjs.github.io/Fn.js：http://eliperelman.com/fn.js/Functional.js：http://functionaljs.com/Ramda.js：http://ramdajs.com/0.20.1/index.htmlMori：http://swannodette.github.io/mori/ JavaScript 函数式编程：https://www.packtpub.com/web-development/functional-programming-javascript 算法复杂度大 O 表示法用于描述算法的性能和复杂程度。大 O 表示法将算法按照消耗的时间进行分类，依据随输入增大所需要的空间/内存。 符 号 名 称 O(1) 常数的 O(log(n)) 对数的 O((log(n))c) 对数多项式的 O(n) 线性的 O(n^2) 二次的 O(n^c) 多项式的 O(c^n) 指数的 理解大 O 表示法 衡量算法的效率：通常是用资源，例如 CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大 O 表示法时，一般考虑的是 CPU（时间）占用。 O(1) 123function increment(num) &#123; return ++num;&#125; 假设运行 increment(1)函数，执行时间等于 X。如果再用不同的参数（例如 2）运行一次 increment 函数，执行时间依然是 X。和参数无关，increment 函数的性能都一样。因此，我们说上述函数的复杂度是 O(1)（常数） O(n) 函数执行的总开销取决于数组元素的个数（数组大小），而且也和搜索的值有关。如果是查找数组中存在的值，查找运算执行次数由值的位置决定。如果查找的是数组中不存在的值，查找运算就会执行和数组大小一样多次，这就是通常所说的最坏情况。最坏情况下，如果数组大小是 10，开销就是 10；如果数组大小是 1000，开销就是 1000。可以得出 sequentialSearch 函数的时间复杂度是 O(n)，n 是（输入）数组的大小。 以顺序搜索算法为例 1234567891011121314151617181920212223function sequentialSearch(array, value, equalsFn = defaultEquals) &#123; for (let i = 0; i &lt; array.length; i++) &#123; if (equalsFn(value, array[i])) &#123; // &#123;1&#125; return i; &#125; &#125; return -1;&#125;function sequentialSearch(array, value, equalsFn = defaultEquals) &#123; let cost = 0; for (let i = 0; i &lt; array.length; i++) &#123; cost++; if (equalsFn(value, array[i])) &#123; return i; &#125; &#125; console.log( `cost for sequentialSearch with input size $&#123;array.length&#125; is $&#123;cost&#125;` ); return -1;&#125; O(n^2) 以冒泡排序为例 1234567891011121314151617181920212223242526272829303132function bubbleSort(array, compareFn = defaultCompare) &#123; const &#123; length &#125; = array; for (let i = 0; i &lt; length; i++) &#123; // &#123;1&#125; for (let j = 0; j &lt; length - 1; j++) &#123; // &#123;2&#125; if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) &#123; swap(array, j, j + 1); &#125; &#125; &#125; return array;&#125;// 假设行&#123;1&#125;和行&#123;2&#125;的开销分别是 1。修改算法的实现使之计算开销。function bubbleSort(array, compareFn = defaultCompare) &#123; const &#123; length &#125; = array; let cost = 0; for (let i = 0; i &lt; length; i++) &#123; // &#123;1&#125; cost++; for (let j = 0; j &lt; length - 1; j++) &#123; // &#123;2&#125; cost++; if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) &#123; swap(array, j, j + 1); &#125; &#125; &#125; console.log(`cost for bubbleSort with input size $&#123;length&#125; is $&#123;cost&#125;`); return array;&#125; 如果用大小为 10 的数组执行 bubbleSort，开销是 100（10^2）。如果用大小为 100 的数组执行bubbleSort，开销就是 10 000（100^2）。需要注意，我们每次增加输入的大小，执行都会越来越久 时间复杂度 O(n)的代码只有一层循环，而 O(n^2)的代码有双层嵌套循环。如果算法有三层迭代数组的嵌套循环，它的时间复杂度很可能就是 O(n^3) 时间复杂度比较 输入大小（n） O(1) O(log(n)) O(n) O(nlog(n)) O(n^2) O(2^n) 10 1 1 10 10 100 1024 20 1 1.30 20 26.02 400 1 048 576 50 1 1.69 50 84.94 2500 非常大 100 1 2 100 200 10 000 非常大 500 1 2.69 500 1349.48 250 000 非常大 1000 1 3 1000 3000 1 000 000 非常大 10 000 1 4 10 000 40 000 100 000 000 非常大 不同的大 O 表示法的消耗 常用数据结构的时间复杂度 图的时间复杂度 排序算法的时间复杂度 搜索算法的时间复杂度 NP 完全理论概述一般来说，如果一个算法的复杂度为 O(n^k)，其中 k 是常数，我们就认为这个算法是高效的，这就是多项式算法. 对于给定的问题，如果存在多项式算法，则计为 P（polynomial，多项式） NP（nondeterministic polynomial，非确定性多项式）算法。如果一个问题可以在多项式时间内验证解是否正确，则计为 NP 如果一个问题存在多项式算法，自然可以在多项式时间内验证其解。因此，所有的 P 都是NP。然而，P = NP 是否成立，仍然不得而知。 NP 问题中最难的是 NP 完全问题。如果满足以下两个条件，则称决策问题 L 是 NP 完全的：(1) L 是 NP 问题，也就是说，可以在多项式时间内验证解，但还没有找到多项式算法；(2) 所有的 NP 问题都能在多项式时间内归约为 L。 为了理解问题的归约，考虑两个决策问题 L和 M。假设算法 A可以解决问题 L，算法 B可以验证输入 y是否为 M的解。目标是找到一个把 L转化为 M的方法，使得算法 B可以用于构造算法 A。 还有一类问题，只需满足 NP 完全问题的第二个条件，称为 NP 困难问题。因此，NP 完全问题也是 NP 困难问题的子集。 下面是满足 P&lt;&gt;NP 时，P、NP、NP 完全和 NP 困难问题的欧拉图。 非 NP 完全的 NP 困难问题的例子有停机问题和布尔可满足性问题（SAT）。 NP 完全问题的例子有子集和问题、旅行商问题、顶点覆盖问题，等等。 以上问题，具体可查看：https://en.wikipedia.org/wiki/NP-completeness 不可解问题与启发式算法有些问题是不可解的。然而，仍然有办法在符合要求的时间内找到一个近似解。启发式算法就是其中之一。启发式算法得到的未必是最优解，但足够解决问题了。启发式算法的例子有局部搜索、遗传算法、启发式导航、机器学习等。详情请查阅 https://en.wikipedia.org/wiki/Heuristic_(computer_science) UVa Online Judge（http://uva.onlinejudge.org/）Sphere Online Judge（http://www.spoj.com/）Coderbyte（http://coderbyte.com/）Project Euler（https://projecteuler.net/）HackerRank（https://www.hackerrank.com）CodeChef（http://www.codechef.com/）Top Coder（http://www.topcoder.com/） 疑问点尾调用优化 调用栈长 使用后性能有较大的提升Floyd-Warshall 算法Kruskal 算法背包问题最长公共子序列矩阵链相乘NP 完全理论 多项式时间 算法的使用，什么情况下用合适？需要将数据转换处理合适 自己写的算法怎么验证正确性？LeetCode或其他刷题网站 antd升级后的visible修改任务评估修改时间testing-library/react测试react组件的库，安装了却没用？umc-ui的项目框架使用的是别的项目的，原来就有，没删","categories":[],"tags":[]},{"title":"数据结构与算法阅读笔记(6)","slug":"38-data-structure6","date":"2022-10-13T06:15:28.000Z","updated":"2023-08-03T03:03:51.025Z","comments":true,"path":"2022/10/13/38-data-structure6/","link":"","permalink":"https://sunjinkang.github.io/2022/10/13/38-data-structure6/","excerpt":"排序和搜索算法排序算法冒泡排序冒泡排序(复杂度是 O(n2))比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。","text":"排序和搜索算法排序算法冒泡排序冒泡排序(复杂度是 O(n2))比较所有相邻的两个项，如果第一个比第二个大，则交换它们。元素项向上移动至正确的顺序，就好像气泡升至表面一样，冒泡排序因此得名。 123456789101112131415161718192021222324function defaultCompare(a, b) &#123; return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN;&#125;function bubbleSort(array, compareFn = defaultCompare) &#123; const &#123; length &#125; = array; // &#123;1&#125; for (let i = 0; i &lt; length; i++) &#123; // &#123;2&#125; for (let j = 0; j &lt; length - 1; j++) &#123; // &#123;3&#125; if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) &#123; // &#123;4&#125; swap(array, j, j + 1); // &#123;5&#125; &#125; &#125; &#125; return array;&#125;function swap(array, a, b) &#123; /* const temp = array[a]; array[a] = array[b]; array[b] = temp; */ // 经典方式 [array[a], array[b]] = [array[b], array[a]]; // ES2015 的方式&#125; 改进后的冒泡排序 123456789101112function modifiedBubbleSort(array, compareFn = defaultCompare) &#123; const &#123; length &#125; = array; for (let i = 0; i &lt; length; i++) &#123; for (let j = 0; j &lt; length - 1 - i; j++) &#123; // &#123;1&#125; if (compareFn(array[j], array[j + 1]) === Compare.BIGGER_THAN) &#123; swap(array, j, j + 1); &#125; &#125; &#125; return array;&#125; 选择排序选择排序算法(复杂度为 O(n2))是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推. 1234567891011121314151617181920function selectionSort(array, compareFn = defaultCompare) &#123; const &#123; length &#125; = array; // &#123;1&#125; let indexMin; for (let i = 0; i &lt; length - 1; i++) &#123; // &#123;2&#125; indexMin = i; // &#123;3&#125; for (let j = i; j &lt; length; j++) &#123; // &#123;4&#125; if (compareFn(array[indexMin], array[j]) === Compare.BIGGER_THAN) &#123; // &#123;5&#125; indexMin = j; // &#123;6&#125; &#125; &#125; if (i !== indexMin) &#123; // &#123;7&#125; swap(array, i, indexMin); &#125; &#125; return array;&#125; 插入排序插入排序每次排一个数组项，以此方式构建最后的排序数组。假定第一项已经排序了。接着，它和第二项进行比较——第二项是应该待在原位还是插到第一项之前呢？这样，头两项就已正确排序，接着和第三项比较（它是该插入到第一、第二还是第三的位置呢），以此类推. 12345678910111213141516function insertionSort(array, compareFn = defaultCompare) &#123; const &#123; length &#125; = array; // &#123;1&#125; let temp; for (let i = 1; i &lt; length; i++) &#123; // &#123;2&#125; let j = i; // &#123;3&#125; temp = array[i]; // &#123;4&#125; while (j &gt; 0 &amp;&amp; compareFn(array[j - 1], temp) === Compare.BIGGER_THAN) &#123; // &#123;5&#125; array[j] = array[j - 1]; // &#123;6&#125; j--; &#125; array[j] = temp; // &#123;7&#125; &#125; return array;&#125; 排序小型数组时，插入排序算法比选择排序和冒泡排序性能要好。 归并排序归并排序是第一个可以实际使用的排序算法。前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。 JavaScript 的 Array 类定义了一个 sort 函数（Array.prototype.sort）用以排序 JavaScript 数组（我们不必自己实现这个算法）。ECMAScript 没有定义用哪个排序算法，所以浏览器厂商可以自行去实现算法。例如，Mozilla Firefox 使用归并排序作为 Array.prototype.sort 的实现，而 Chrome（V8 引擎）使用了一个快速排序的变体。 归并排序是一种分而治之算法。其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。 由于是分治法，归并排序也是递归的。将算法分为两个函数：第一个负责将一个大数组分为多个小数组并调用用来排序的辅助函数。 1234567891011121314151617181920212223242526function mergeSort(array, compareFn = defaultCompare) &#123; if (array.length &gt; 1) &#123; // &#123;1&#125; const &#123; length &#125; = array; const middle = Math.floor(length / 2); // &#123;2&#125; const left = mergeSort(array.slice(0, middle), compareFn); // &#123;3&#125; const right = mergeSort(array.slice(middle, length), compareFn); // &#123;4&#125; array = merge(left, right, compareFn); // &#123;5&#125; &#125; return array;&#125;function merge(left, right, compareFn) &#123; let i = 0; // &#123;6&#125; let j = 0; const result = []; while (i &lt; left.length &amp;&amp; j &lt; right.length) &#123; // &#123;7&#125; result.push( compareFn(left[i], right[j]) === Compare.LESS_THAN ? left[i++] : right[j++] ); // &#123;8&#125; &#125; return result.concat(i &lt; left.length ? left.slice(i) : right.slice(j)); // &#123;9&#125;&#125; 快速排序快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开） (1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的子数组）重复之前的两个步骤，直至数组已完全排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445function quickSort(array, compareFn = defaultCompare) &#123; return quick(array, 0, array.length - 1, compareFn);&#125;function quick(array, left, right, compareFn) &#123; let index; // &#123;1&#125; if (array.length &gt; 1) &#123; // &#123;2&#125; index = partition(array, left, right, compareFn); // &#123;3&#125; if (left &lt; index - 1) &#123; // &#123;4&#125; quick(array, left, index - 1, compareFn); // &#123;5&#125; &#125; if (index &lt; right) &#123; // &#123;6&#125; quick(array, index, right, compareFn); // &#123;7&#125; &#125; &#125; return array;&#125;function partition(array, left, right, compareFn) &#123; // 选择中间值作为主元 const pivot = array[Math.floor((right + left) / 2)]; // &#123;8&#125; let i = left; // &#123;9&#125; let j = right; // &#123;10&#125; while (i &lt;= j) &#123; // &#123;11&#125; while (compareFn(array[i], pivot) === Compare.LESS_THAN) &#123; // &#123;12&#125; i++; &#125; while (compareFn(array[j], pivot) === Compare.BIGGER_THAN) &#123; // &#123;13&#125; j--; &#125; if (i &lt;= j) &#123; // &#123;14&#125; swap(array, i, j); // &#123;15&#125; i++; j--; &#125; &#125; return i; // &#123;16&#125;&#125; 划分操作的第一次执行对有较小值的子数组执行的划分操作针对有较大值的子数组 计数排序计数排序是一个分布式排序。分布式排序使用已组织好的辅助数据结构（称为桶），然后进行合并，得到排好序的数组。计数排序使用一个用来存储每个元素在原始数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序后的结果数组 它是用来排序整数的优秀算法（它是一个整数排序算法），时间复杂度为 O(n+k)，其中 k 是临时计数数组的大小；但是，它确实需要更多的内存来存放临时数组。 12345678910111213141516171819202122232425262728293031323334function countingSort(array) &#123; if (array.length &lt; 2) &#123; // &#123;1&#125; return array; &#125; const maxValue = findMaxValue(array); // &#123;2&#125; const counts = new Array(maxValue + 1); // &#123;3&#125; array.forEach((element) =&gt; &#123; if (!counts[element]) &#123; // &#123;4&#125; counts[element] = 0; &#125; counts[element]++; // &#123;5&#125; &#125;); let sortedIndex = 0; counts.forEach((count, i) =&gt; &#123; while (count &gt; 0) &#123; // &#123;6&#125; array[sortedIndex++] = i; // &#123;7&#125; count--; // &#123;8&#125; &#125; &#125;); return array;&#125;function findMaxValue(array) &#123; let max = array[0]; for (let i = 1; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; return max;&#125; 桶排序桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行排序。然后，它将所有的桶合并为结果数组。 默认情况下，我们会使用 5 个桶。桶排序在所有元素平分到各个桶中时的表现最好。如果元素非常稀疏，则使用更多的桶会更好。如果元素非常密集，则使用较少的桶会更好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function bucketSort(array, bucketSize = 5) &#123; // &#123;1&#125; if (array.length &lt; 2) &#123; return array; &#125; // 创建桶并将元素分布到不同的桶中 const buckets = createBuckets(array, bucketSize); // &#123;2&#125; // 对每个桶执行插入排序算法和将所有桶合并为排序后的结果数组 return sortBuckets(buckets); // &#123;3&#125;&#125;function createBuckets(array, bucketSize) &#123; let minValue = array[0]; let maxValue = array[0]; for (let i = 1; i &lt; array.length; i++) &#123; // &#123;4&#125; if (array[i] &lt; minValue) &#123; minValue = array[i]; &#125; else if (array[i] &gt; maxValue) &#123; maxValue = array[i]; &#125; &#125; // 计算每个桶中需要分布的元素个数 const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; // &#123;5&#125; const buckets = []; for (let i = 0; i &lt; bucketCount; i++) &#123; // 初始化每个桶 buckets[i] = []; &#125; for (let i = 0; i &lt; array.length; i++) &#123; // &#123;7&#125; const bucketIndex = Math.floor((array[i] - minValue) / bucketSize); // &#123;8&#125; buckets[bucketIndex].push(array[i]); &#125; return buckets;&#125;function sortBuckets(buckets) &#123; const sortedArray = []; // &#123;9&#125; for (let i = 0; i &lt; buckets.length; i++) &#123; // &#123;10&#125; if (buckets[i] != null) &#123; insertionSort(buckets[i]); // &#123;11&#125; sortedArray.push(...buckets[i]); // &#123;12&#125; &#125; &#125; return sortedArray;&#125; 基数排序基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排序）将整数分布到桶中。基数是基于数组中值的记数制的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function radixSort(array, radixBase = 10) &#123; if (array.length &lt; 2) &#123; return array; &#125; const minValue = findMinValue(array); const maxValue = findMaxValue(array); let significantDigit = 1; // &#123;1&#125; while ((maxValue - minValue) / significantDigit &gt;= 1) &#123; // &#123;2&#125; array = countingSortForRadix(array, radixBase, significantDigit, minValue); // &#123;3&#125; significantDigit *= radixBase; // &#123;4&#125; &#125; return array;&#125;function countingSortForRadix(array, radixBase, significantDigit, minValue) &#123; let bucketsIndex; const buckets = []; const aux = []; for (let i = 0; i &lt; radixBase; i++) &#123; // &#123;5&#125; buckets[i] = 0; &#125; for (let i = 0; i &lt; array.length; i++) &#123; // 基于数组中数的有效位（行&#123;7&#125;）进行计数排序 bucketsIndex = Math.floor( ((array[i] - minValue) / significantDigit) % radixBase ); // &#123;7&#125; buckets[bucketsIndex]++; // &#123;8&#125; &#125; for (let i = 1; i &lt; radixBase; i++) &#123; // 计算累积结果来得到正确的计数值 buckets[i] += buckets[i - 1]; &#125; for (let i = array.length - 1; i &gt;= 0; i--) &#123; // &#123;10&#125; bucketsIndex = Math.floor( ((array[i] - minValue) / significantDigit) % radixBase ); // &#123;11&#125; aux[--buckets[bucketsIndex]] = array[i]; // &#123;12&#125; &#125; for (let i = 0; i &lt; array.length; i++) &#123; // &#123;13&#125; array[i] = aux[i]; &#125; return array;&#125; 搜索算法顺序搜索顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找的元素做比较。顺序搜索是最低效的一种搜索算法 1234567891011const DOES_NOT_EXIST = -1;function sequentialSearch(array, value, equalsFn = defaultEquals) &#123; for (let i = 0; i &lt; array.length; i++) &#123; // &#123;1&#125; if (equalsFn(value, array[i])) &#123; // &#123;2&#125; return i; // &#123;3&#125; &#125; &#125; return DOES_NOT_EXIST; // &#123;4&#125;&#125; 二分搜索个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。(1) 选择数组的中间值。(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）。(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。 12345678910111213141516171819202122232425function binarySearch(array, value, compareFn = defaultCompare) &#123; const sortedArray = quickSort(array); // &#123;1&#125; let low = 0; // &#123;2&#125; let high = sortedArray.length - 1; // &#123;3&#125; while (lesserOrEquals(low, high, compareFn)) &#123; // &#123;4&#125; const mid = Math.floor((low + high) / 2); // &#123;5&#125; const element = sortedArray[mid]; // &#123;6&#125; if (compareFn(element, value) === Compare.LESS_THAN) &#123; // &#123;7&#125; low = mid + 1; // &#123;8&#125; &#125; else if (compareFn(element, value) === Compare.BIGGER_THAN) &#123; // &#123;9&#125; high = mid - 1; // &#123;10&#125; &#125; else &#123; return mid; // &#123;11&#125; &#125; &#125; return DOES_NOT_EXIST; // &#123;12&#125;&#125;function lesserOrEquals(a, b, compareFn) &#123; const comp = compareFn(a, b); return comp === Compare.LESS_THAN || comp === Compare.EQUALS;&#125; 内插搜索内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根据要搜索的值检查数组中的不同地方。 算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤 (1) 使用 position 公式选中一个值；(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；(3) 如果待搜索值比选中值要小，则返回步骤 1 并在选中值左边的子数组中寻找（较小）；(4) 如果待搜索值比选中值要大，则返回步骤 1 并在选种值右边的子数组中寻找（较大）。 123456789101112131415161718192021222324252627282930313233343536373839404142function interpolationSearch( array, value, compareFn = defaultCompare, equalsFn = defaultEquals, diffFn = defaultDiff) &#123; const &#123; length &#125; = array; let low = 0; let high = length - 1; let position = -1; let delta = -1; while ( low &lt;= high &amp;&amp; biggerOrEquals(value, array[low], compareFn) &amp;&amp; lesserOrEquals(value, array[high], compareFn) ) &#123; /** 如果查找的值更接近 array[high]则查找 position 位置旁更大的值，如果查找的值更接近 array[low]则查找position 位置旁更小的值。这个算法在数组中的值都是均匀分布时性能最好（delta 会非常小） */ delta = diffFn(value, array[low]) / diffFn(array[high], array[low]); position = low + Math.floor((high - low) * delta); // &#123;2&#125; if (equalsFn(array[position], value)) &#123; // &#123;3&#125; return position; &#125; if (compareFn(array[position], value) === Compare.LESS_THAN) &#123; // &#123;4&#125; low = position + 1; &#125; else &#123; high = position - 1; &#125; &#125; return DOES_NOT_EXIST;&#125;function lesserOrEquals(a, b, compareFn) &#123; const comp = compareFn(a, b); return comp === Compare.LESS_THAN || comp === Compare.EQUALS;&#125;function biggerOrEquals(a, b, compareFn) &#123; const comp = compareFn(a, b); return comp === Compare.BIGGER_THAN || comp === Compare.EQUALS;&#125; 随机算法Fisher-Yates 随机它的含义是迭代数组，从最后一位开始并将当前位置和一个随机位置进行交换。这个随机位置比当前位置小。这样，这个算法可以保证随机过的位置不会再被随机一次（洗扑克牌的次数越多，随机效果越差） 1234567function shuffle(array) &#123; for (let i = array.length - 1; i &gt; 0; i--) &#123; const randomIndex = Math.floor(Math.random() * (i + 1)); swap(array, i, randomIndex); &#125; return array;&#125;","categories":[],"tags":[]},{"title":"数据结构与算法阅读笔记(5)","slug":"37-data-structure5","date":"2022-10-08T08:33:37.000Z","updated":"2023-08-03T03:03:45.424Z","comments":true,"path":"2022/10/08/37-data-structure5/","link":"","permalink":"https://sunjinkang.github.io/2022/10/08/37-data-structure5/","excerpt":"二叉堆和堆排序二叉堆数据结构(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性","text":"二叉堆和堆排序二叉堆数据结构(1)它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。(2)二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。这叫作堆特性 二叉树有两种表示方式第一种是使用一个动态的表示方式，也就是指针（用节点表示）第二种是使用一个数组，通过索引值检索父节点、左侧和右侧子节点的值。 访问使用普通数组的二叉树节点:它的左侧子节点的位置是 2 _ index + 1（如果位置可用）；它的右侧子节点的位置是 2 _ index + 2（如果位置可用）；它的父节点位置是 index / 2（如果位置可用） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import &#123; defaultCompare &#125; from &#x27;../util&#x27;;export class MinHeap &#123; constructor(compareFn = defaultCompare) &#123; this.compareFn = compareFn; // &#123;1&#125; this.heap = []; // &#123;2&#125; &#125; getLeftIndex(index) &#123; return 2 * index + 1; &#125; getRightIndex(index) &#123; return 2 * index + 2; &#125; getParentIndex(index) &#123; if (index === 0) &#123; return undefined; &#125; return Math.floor((index - 1) / 2); &#125; insert(value) &#123; if (value != null) &#123; this.heap.push(value); // &#123;1&#125; this.siftUp(this.heap.length - 1); // &#123;2&#125; return true; &#125; return false; &#125; // 上移操作 siftUp(index) &#123; let parent = this.getParentIndex(index); // &#123;1&#125; while ( index &gt; 0 &amp;&amp; this.compareFn(this.heap[parent], this.heap[index]) &gt; Compare.BIGGER_THAN ) &#123; // &#123;2&#125; swap(this.heap, parent, index); // &#123;3&#125; index = parent; parent = this.getParentIndex(index); // &#123;4&#125; &#125; function swap(array, a, b) &#123; const temp = array[a]; // &#123;5&#125; array[a] = array[b]; // &#123;6&#125; array[b] = temp; // &#123;7&#125; &#125; &#125; size() &#123; return this.heap.length; &#125; isEmpty() &#123; return this.size() === 0; &#125; findMinimum() &#123; return this.isEmpty() ? undefined : this.heap[0]; // &#123;1&#125; &#125; extract() &#123; if (this.isEmpty()) &#123; return undefined; // &#123;1&#125; &#125; if (this.size() === 1) &#123; return this.heap.shift(); // &#123;2&#125; &#125; const removedValue = this.heap.shift(); // &#123;3&#125; this.siftDown(0); // &#123;4&#125; return removedValue; // &#123;5&#125; &#125; siftDown(index) &#123; let element = index; const left = this.getLeftIndex(index); // &#123;1&#125; const right = this.getRightIndex(index); // &#123;2&#125; const size = this.size(); if ( left &lt; size &amp;&amp; this.compareFn(this.heap[element], this.heap[left]) &gt; Compare.BIGGER_THAN ) &#123; // &#123;3&#125; element = left; // &#123;4&#125; &#125; if ( right &lt; size &amp;&amp; this.compareFn(this.heap[element], this.heap[right]) &gt; Compare.BIGGER_THAN ) &#123; // &#123;5&#125; element = right; // &#123;6&#125; &#125; if (index !== element) &#123; // &#123;7&#125; swap(this.heap, index, element); // &#123;8&#125; this.siftDown(element); // &#123;9&#125; &#125; &#125;&#125; 创建最大堆类MaxHeap 类的算法和 MinHeap 类的算法一模一样。不同之处在于我们要把所有&gt;（大于）的比较换成&lt;（小于）的比较。 12345678910function reverseCompare(compareFn) &#123; return (a, b) =&gt; compareFn(b, a);&#125;export class MaxHeap extends MinHeap &#123; constructor(compareFn = defaultCompare) &#123; super(compareFn); this.compareFn = reverseCompare(compareFn); // &#123;1&#125; &#125;&#125; 堆排序算法(1) 用数组创建一个最大堆用作源数据。(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个值，将堆的大小减 1。(3) 最后，我们将堆的根节点下移并重复步骤 2 直到堆的大小为 1 123456789101112131415function heapSort(array, compareFn = defaultCompare) &#123; let heapSize = array.length; buildMaxHeap(array, compareFn); // 步骤 1 while (heapSize &gt; 1) &#123; swap(array, 0, --heapSize); // 步骤 2 heapify(array, 0, heapSize, compareFn); // 步骤 3 &#125; return array;&#125;function buildMaxHeap(array, compareFn) &#123; for (let i = Math.floor(array.length / 2); i &gt;= 0; i -= 1) &#123; heapify(array, i, array.length, compareFn); &#125; return array;&#125; heapify 函数和我们创建的 siftDown 方法有相同的代码。不同之处是我们会将堆本身、堆的大小和要使用的比较函数传入作为参数。这是因为我们不会直接使用堆数据结构，而是使用它的逻辑来开发 heapSort 算法 堆排序算法不是一个稳定的排序算法，也就是说如果数组没有排好序，可能会得到不一样的结果。 图图的相关术语图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）G = (V, E)V: 一组顶点E: 一组边，连接 V 中的顶点 由一条边连接在一起的顶点称为相邻顶点。比如，A 和 B 是相邻的，A 和 D 是相邻的，A 和 C 是相邻的，A 和 E 不是相邻的。一个顶点的度是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此 A 的度为 3；E 和其他两个顶点相连，因此 E 的度为 2。路径是顶点 v1, v2, …, vk 的一个连续序列，其中 vi 和 vi+1 是相邻的。以上一示意图中的图为例，其中包含路径 A B E I 和 A C D G。简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），环也是一个简单路径，比如 A D C A（最后一个顶点重新回到 A）。如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。 有向图和无向图图可以是无向的（边没有方向）或是有向的（有向图）。如果图中每两个顶点间在双向上都存在路径，则该图是强连通的。例如，C 和 D 是强连通的，而 A 和 B 不是强连通的。图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。 图的表示邻接矩阵每个节点都和一个整数相关联，该整数将作为数组的索引。用一个二维数组来表示顶点之间的连接。如果索引为 i 的节点和索引为 j 的节点相邻，则 array[i][j] === 1，否则 array[i][j] === 0缺点：(1)不是强连通的图（稀疏图）如果用邻接矩阵来表示，则矩阵中将会有很多 0，浪费了计算机存储空间来表示根本不存在的边。(2)顶点的数量可能会改变，而二维数组不太灵活 邻接表邻接表由图中每个顶点的相邻顶点列表所组成。存在好几种方式来表示这种数据结构。可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表 关联矩阵在关联矩阵中，矩阵的行表示顶点，列表示边。使用二维数组来表示两者之间的连通性，如果顶点 v 是边 e 的入射点，则 array[v][e] === 1；否则，array[v][e] === 0关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存 创建 Graph 类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Graph &#123; constructor(isDirected = false) &#123; // 表示图是否有向 this.isDirected = isDirected; // &#123;1&#125; // 所有顶点的名字 this.vertices = []; // &#123;2&#125; // 字典将会使用顶点的名字作为键，邻接顶点列表作为值 this.adjList = new Dictionary(); // &#123;3&#125; &#125; // 一个用来向图中添加一个新的顶点 addVertex(v) &#123; if (!this.vertices.includes(v)) &#123; // &#123;5&#125; this.vertices.push(v); // &#123;6&#125; this.adjList.set(v, []); // &#123;7&#125; &#125; &#125; // 来添加顶点之间的边 addEdge(v, w) &#123; if (!this.adjList.get(v)) &#123; this.addVertex(v); // &#123;8&#125; &#125; if (!this.adjList.get(w)) &#123; this.addVertex(w); // &#123;9&#125; &#125; this.adjList.get(v).push(w); // &#123;10&#125; if (!this.isDirected) &#123; this.adjList.get(w).push(v); // &#123;11&#125; &#125; &#125; // 获取顶点列表 getVertices() &#123; return this.vertices; &#125; // 获取邻接表 getAdjList() &#123; return this.adjList; &#125; toString() &#123; let s = &#x27;&#x27;; for (let i = 0; i &lt; this.vertices.length; i++) &#123; // &#123;15&#125; s += `$&#123;this.vertices[i]&#125; -&gt; `; const neighbors = this.adjList.get(this.vertices[i]); // &#123;16&#125; for (let j = 0; j &lt; neighbors.length; j++) &#123; // &#123;17&#125; s += `$&#123;neighbors[j]&#125; `; &#125; s += &#x27;\\n&#x27;; // &#123;18&#125; &#125; return s; &#125;&#125; 图的遍历作用：图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。 广度优先搜索（breadth-first search，BFS）深度优先搜索（depth-first search，DFS）不同点：待访问顶点列表的数据结构| 算 法 | 数据结构 | 描 述 || ———— | ——– | ————————————————————– || 深度优先搜索 | 栈 | 将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问 || 广度优先搜索 | 队列 | 将顶点存入队列，最先入队列的顶点先被探索 | 12345678910111213141516// 白色：表示该顶点还没有被访问。// 灰色：表示该顶点被访问过，但并未被探索过。// 黑色：表示该顶点被访问过且被完全探索过const Colors = &#123; WHITE: 0, GREY: 1, BLACK: 2,&#125;;// 初始化每个顶点的颜色const initializeColor = (vertices) =&gt; &#123; const color = &#123;&#125;; for (let i = 0; i &lt; vertices.length; i++) &#123; color[vertices[i]] = Colors.WHITE; &#125; return color;&#125;; 广度优先搜索从指定的第一个顶点开始遍历图，先访问其所有的邻点（相邻顶点），就像一次访问图的一层。换句话说，就是先宽后深地访问顶点步骤(1) 创建一个队列 Q。(2) 标注 v 为被发现的（灰色），并将 v 入队列 Q。(3) 如果 Q 非空，则运行以下步骤： (a) 将 u 从 Q 中出队列； (b) 标注 u 为被发现的（灰色）； (c) 将 u 所有未被访问过的邻点（白色）入队列； (d) 标注 u 为已被探索的（黑色） 1234567891011121314151617181920212223242526272829303132export const breadthFirstSearch = (graph, startVertex, callback) =&gt; &#123; const vertices = graph.getVertices(); const adjList = graph.getAdjList(); const color = initializeColor(vertices); // &#123;1&#125; const queue = new Queue(); // &#123;2&#125; queue.enqueue(startVertex); // &#123;3&#125; while (!queue.isEmpty()) &#123; // &#123;4&#125; const u = queue.dequeue(); // &#123;5&#125; const neighbors = adjList.get(u); // &#123;6&#125; // 发现了节点，但尚未完成探索 color[u] = Colors.GREY; // &#123;7&#125; for (let i = 0; i &lt; neighbors.length; i++) &#123; // &#123;8&#125; const w = neighbors[i]; // &#123;9&#125; if (color[w] === Colors.WHITE) &#123; // &#123;10&#125; color[w] = Colors.GREY; // &#123;11&#125; queue.enqueue(w); // &#123;12&#125; &#125; &#125; color[u] = Colors.BLACK; // &#123;13&#125; // 可选回调函数 if (callback) &#123; // &#123;14&#125; callback(u); &#125; &#125;&#125;;const printVertex = (value) =&gt; console.log(&#x27;Visited vertex: &#x27; + value); // &#123;15&#125;breadthFirstSearch(graph, myVertices[0], printVertex); 使用 BFS 寻找最短路径给定一个图 G 和源顶点 v，找出每个顶点 u 和 v 之间最短路径的距离（以边的数量计） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const BFS = (graph, startVertex) =&gt; &#123; const vertices = graph.getVertices(); const adjList = graph.getAdjList(); const color = initializeColor(vertices); // 创建一个队列 const queue = new Queue(); const distances = &#123;&#125;; // &#123;1&#125; const predecessors = &#123;&#125;; // &#123;2&#125; queue.enqueue(startVertex); for (let i = 0; i &lt; vertices.length; i++) &#123; // &#123;3&#125; distances[vertices[i]] = 0; // &#123;4&#125; predecessors[vertices[i]] = null; // &#123;5&#125; &#125; while (!queue.isEmpty()) &#123; const u = queue.dequeue(); const neighbors = adjList.get(u); color[u] = Colors.GREY; for (let i = 0; i &lt; neighbors.length; i++) &#123; const w = neighbors[i]; if (color[w] === Colors.WHITE) &#123; color[w] = Colors.GREY; distances[w] = distances[u] + 1; // &#123;6&#125; predecessors[w] = u; // &#123;7&#125; queue.enqueue(w); &#125; &#125; color[u] = Colors.BLACK; &#125; return &#123; // &#123;8&#125; distances, // 从 v(源顶点) 到 u(除源顶点外的任意顶点) 的距离 distances[u] predecessors, // 前溯点 predecessors[u]，用来推导出从 v 到其他每个顶点 u 的最短路径 &#125;;&#125;;const shortestPathA = BFS(graph, myVertices[0]);console.log(shortestPathA);// distances: &#123;A: 0, B: 1, C: 1, D: 1, E: 2, F: 2, G: 2, H: 2 , I: 3&#125;,// predecessors: &#123;A: null, B: &quot;A&quot;, C: &quot;A&quot;, D: &quot;A&quot;, E: &quot;B&quot;, F: &quot;B&quot;, G: &quot;C&quot;, H: &quot;D&quot;, I: &quot;E&quot;&#125;const fromVertex = myVertices[0]; // &#123;9&#125;for (i = 1; i &lt; myVertices.length; i++) &#123; // &#123;10&#125; const toVertex = myVertices[i]; // &#123;11&#125; // 创建一个栈 const path = new Stack(); // &#123;12&#125; // 获取当前节点，然后获取当前节点的前溯点，一级级向上直到查找到源顶点 for (let v = toVertex; v !== fromVertex; v = shortestPathA.predecessors[v]) &#123; // &#123;13&#125; path.push(v); // &#123;14&#125; &#125; path.push(fromVertex); // &#123;15&#125; let s = path.pop(); // &#123;16&#125; while (!path.isEmpty()) &#123; // &#123;17&#125; s += &#x27; - &#x27; + path.pop(); // &#123;18&#125; &#125; console.log(s); // &#123;19&#125;&#125;// A - B// A - C// A - D// A - B - E// A - B - F// A - C - G// A - D - H// A - B - E - I 深入学习最短路径算法Dijkstra 算法解决了单源最短路径问题。Bellman-Ford 算法解决了边权值为负的单源最短路径问题。A*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。Floyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题 深度优先搜索深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点 深度优先搜索算法不需要一个源顶点。在深度优先搜索算法中，若图中顶点 v 未访问，则访问该顶点 v。步骤(1) 标注 v 为被发现的（灰色）；(2) 对于 v 的所有未访问（白色）的邻点 w，访问顶点 w；(3) 标注 v 为已被探索的（黑色）。 深度优先搜索的步骤是递归的，这意味着深度优先搜索算法使用栈来存储函数调用（由递归调用所创建的栈） 1234567891011121314151617181920212223242526272829303132333435363738394041const depthFirstSearch = (graph, callback) =&gt; &#123; // &#123;1&#125; const vertices = graph.getVertices(); const adjList = graph.getAdjList(); const color = initializeColor(vertices); for (let i = 0; i &lt; vertices.length; i++) &#123; // &#123;2&#125; if (color[vertices[i]] === Colors.WHITE) &#123; // &#123;3&#125; depthFirstSearchVisit(vertices[i], color, adjList, callback); // &#123;4&#125; &#125; &#125;&#125;;const depthFirstSearchVisit = (u, color, adjList, callback) =&gt; &#123; color[u] = Colors.GREY; // &#123;5&#125; if (callback) &#123; // &#123;6&#125; callback(u); &#125; const neighbors = adjList.get(u); // &#123;7&#125; for (let i = 0; i &lt; neighbors.length; i++) &#123; // &#123;8&#125; const w = neighbors[i]; // &#123;9&#125; if (color[w] === Colors.WHITE) &#123; // &#123;10&#125; depthFirstSearchVisit(w, color, adjList, callback); // &#123;11&#125; &#125; &#125; color[u] = Colors.BLACK; // &#123;12&#125;&#125;;depthFirstSearch(graph, printVertex);// Visited vertex: A// Visited vertex: B// Visited vertex: E// Visited vertex: I// Visited vertex: F// Visited vertex: C// Visited vertex: D// Visited vertex: G// Visited vertex: H Angular（版本 2+）在探测变更（验证 HTML 模板是否需要更新）方面使用的算法和深度优先搜索算法非常相似。 探索深度优先算法对于给定的图 G，我们希望深度优先搜索算法遍历图 G 的所有节点，构建“森林”（有根树的一个集合）以及一组源顶点（根），并输出两个数组：发现时间和完成探索时间。 12345678910111213141516171819202122232425262728293031323334353637383940export const DFS = (graph) =&gt; &#123; const vertices = graph.getVertices(); const adjList = graph.getAdjList(); const color = initializeColor(vertices); const d = &#123;&#125;; const f = &#123;&#125;; const p = &#123;&#125;; const time = &#123; count: 0 &#125;; // &#123;1&#125; for (let i = 0; i &lt; vertices.length; i++) &#123; // &#123;2&#125; f[vertices[i]] = 0; d[vertices[i]] = 0; p[vertices[i]] = null; &#125; for (let i = 0; i &lt; vertices.length; i++) &#123; if (color[vertices[i]] === Colors.WHITE) &#123; DFSVisit(vertices[i], color, d, f, p, time, adjList); &#125; &#125; return &#123; // &#123;3&#125; discovery: d, // 顶点 u 的发现时间 d[u]； finished: f, // 当顶点 u 被标注为黑色时，u 的完成探索时间 f[u]； predecessors: p, // 顶点 u 的前溯点 p[u] &#125;;&#125;;const DFSVisit = (u, color, d, f, p, time, adjList) =&gt; &#123; color[u] = Colors.GREY; d[u] = ++time.count; // &#123;4&#125; const neighbors = adjList.get(u); for (let i = 0; i &lt; neighbors.length; i++) &#123; const w = neighbors[i]; if (color[w] === Colors.WHITE) &#123; p[w] = u; // &#123;5&#125; DFSVisit(w, color, d, f, p, time, adjList); &#125; &#125; color[u] = Colors.BLACK; f[u] = ++time.count; // &#123;6&#125;&#125;; (1)时间（time）变量值的范围只可能在图顶点数量的一倍到两倍（2|V|）之间；(2)对于所有的顶点 u，d[u] &lt; f[u] (意味着，发现时间的值比完成时间的值小，完成时间意思是所有顶点都已经被探索过了)。在这两个假设下，我们有如下的规则。1 &lt;= d [u] &lt; f [u] &lt;= 2|V|如果对同一个图再跑一遍新的深度优先搜索方法，对图中每个顶点，我们会得到如下的发现/完成时间 拓扑排序——使用深度优先搜索有向无环图（DAG） 需要编排一些任务或步骤的执行顺序时，称为拓扑排序（topological sorting，英文亦写作 topsort 或是 toposort） 拓扑排序只能应用于 DAG 123456789101112graph = new Graph(true); // 有向图myVertices = [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;];for (i = 0; i &lt; myVertices.length; i++) &#123; graph.addVertex(myVertices[i]);&#125;graph.addEdge(&#x27;A&#x27;, &#x27;C&#x27;);graph.addEdge(&#x27;A&#x27;, &#x27;D&#x27;);graph.addEdge(&#x27;B&#x27;, &#x27;D&#x27;);graph.addEdge(&#x27;B&#x27;, &#x27;E&#x27;);graph.addEdge(&#x27;C&#x27;, &#x27;F&#x27;);graph.addEdge(&#x27;F&#x27;, &#x27;E&#x27;);const result = DFS(graph); 12345678910111213141516const fTimes = result.finished;s = &#x27;&#x27;;for (let count = 0; count &lt; myVertices.length; count++) &#123; let max = 0; let maxName = null; for (i = 0; i &lt; myVertices.length; i++) &#123; if (fTimes[myVertices[i]] &gt; max) &#123; max = fTimes[myVertices[i]]; maxName = myVertices[i]; &#125; &#125; s += &#x27; - &#x27; + maxName; delete fTimes[maxName];&#125;console.log(s);// B - A - D - C - F - E 最短路径算法Dijkstra 算法Dijkstra 算法是一种计算从单个源到所有其他源的最短路径的贪心算法，这意味着我们可以用它来计算从图的一个顶点到其余各顶点的最短路径。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var graph = [ [0, 2, 4, 0, 0, 0], [0, 0, 1, 4, 2, 0], [0, 0, 0, 0, 3, 0], [0, 0, 0, 0, 0, 2], [0, 0, 0, 3, 0, 2], [0, 0, 0, 0, 0, 0],];// JavaScript 最大的数 INF = Number.MAX_SAFE_INTEGERconst INF = Number.MAX_SAFE_INTEGER;const dijkstra = (graph, src) =&gt; &#123; const dist = []; const visited = []; const &#123; length &#125; = graph; for (let i = 0; i &lt; length; i++) &#123; // &#123;1&#125; dist[i] = INF; // 把所有的距离（dist）初始化为无限大 visited[i] = false; &#125; dist[src] = 0; // &#123;2&#125; 把源顶点到自己的距离设为 0 for (let i = 0; i &lt; length - 1; i++) &#123; // &#123;3&#125; const u = minDistance(dist, visited); // &#123;4&#125; 从尚未处理的顶点中选出距离最近的顶点 visited[u] = true; // &#123;5&#125; 把选出的顶点标为 visited，以免重复计算 for (let v = 0; v &lt; length; v++) &#123; if ( !visited[v] &amp;&amp; graph[u][v] !== 0 &amp;&amp; dist[u] !== INF &amp;&amp; dist[u] + graph[u][v] &lt; dist[v] ) &#123; // 如果找到更短的路径，则更新最短路径的值 // &#123;6&#125; dist[v] = dist[u] + graph[u][v]; // &#123;7&#125; &#125; &#125; &#125; return dist; // &#123;8&#125;&#125;;const minDistance = (dist, visited) =&gt; &#123; let min = INF; let minIndex = -1; for (let v = 0; v &lt; dist.length; v++) &#123; if (visited[v] === false &amp;&amp; dist[v] &lt;= min) &#123; min = dist[v]; minIndex = v; &#125; &#125; return minIndex;&#125;;// 0 0// 1 2// 2 4// 3 6// 4 4// 5 6 Floyd-Warshall 算法Floyd-Warshall 算法是一种计算图中所有最短路径的动态规划算法。通过该算法，我们可以找出从所有源到所有顶点的最短路径。 123456789101112131415161718192021222324252627282930313233343536373839const floydWarshall = (graph) =&gt; &#123; const dist = []; const &#123; length &#125; = graph; for (let i = 0; i &lt; length; i++) &#123; // &#123;1&#125; dist[i] = []; for (let j = 0; j &lt; length; j++) &#123; if (i === j) &#123; dist[i][j] = 0; // &#123;2&#125; &#125; else if (!isFinite(graph[i][j])) &#123; // 如果两个顶点之间没有边，就将其表示为 Infinity dist[i][j] = Infinity; // &#123;3&#125; &#125; else &#123; // 为 i 到 j 可能的最短距离就是这些顶点间的权值 dist[i][j] = graph[i][j]; // &#123;4&#125; &#125; &#125; &#125; // 将顶点 0 到 k 作为中间点（行&#123;5&#125;），从 i 到 j 的最短路径经过 k。 for (let k = 0; k &lt; length; k++) &#123; // &#123;5&#125; for (let i = 0; i &lt; length; i++) &#123; for (let j = 0; j &lt; length; j++) &#123; // 计算通过顶点 k 的 i 和 j 之间的最短路径 if (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123; // &#123;6&#125; dist[i][j] = dist[i][k] + dist[k][j]; // &#123;7&#125; &#125; &#125; &#125; &#125; return dist;&#125;;// 0 2 4 6 4 6// INF 0 2 4 2 4// INF INF 0 6 3 5// INF INF INF 0 INF 2// INF INF INF 3 0 2// INF INF INF INF INF 0 最小生成树(MST)Prim 算法Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var graph = [ [0, 2, 4, 0, 0, 0], [2, 0, 2, 4, 2, 0], [4, 2, 0, 0, 3, 0], [0, 4, 0, 0, 3, 2], [0, 2, 3, 3, 0, 2], [0, 0, 0, 2, 2, 0],];const INF = Number.MAX_SAFE_INTEGER;const prim = (graph) =&gt; &#123; const parent = []; const key = []; const visited = []; const &#123; length &#125; = graph; // 把所有顶点（key）初始化为无限大 for (let i = 0; i &lt; length; i++) &#123; // &#123;1&#125; key[i] = INF; visited[i] = false; &#125; // 选择第一个 key 作为第一个顶点，同时，因为第一个顶点总是 MST 的根节点，所以 parent[0] = -1 key[0] = 0; // &#123;2&#125; parent[0] = -1; for (let i = 0; i &lt; length - 1; i++) &#123; // &#123;3&#125; // 从未处理的顶点集合中选出 key 值最小的顶点（与 Dijkstra 算法中使用的minDistance 函数一样，只是名字不同） const u = minKey(graph, key, visited); // &#123;4&#125; visited[u] = true; // &#123;5&#125; for (let v = 0; v &lt; length; v++) &#123; // 如果得到更小的权值，则保存 MST 路径（parent）并更新其权值 if (graph[u][v] &amp;&amp; !visited[v] &amp;&amp; graph[u][v] &lt; key[v]) &#123; // &#123;6&#125; parent[v] = u; // &#123;7&#125; key[v] = graph[u][v]; // &#123;8&#125; &#125; &#125; &#125; return parent; // &#123;9&#125;&#125;;const minDistance = (dist, key, visited) =&gt; &#123; let min = INF; let minIndex = -1; for (let v = 0; v &lt; dist[key].length; v++) &#123; if (visited[v] === false &amp;&amp; dist[key][v] &lt;= min) &#123; min = dist[key][v]; minIndex = v; &#125; &#125; return minIndex;&#125;;// Edge Weight// 0 - 1 2// 1 - 2 2// 5 - 3 2// 1 - 4 2// 4 - 5 2 Kruskal 算法是一种求加权无向连通图的 MST 的贪心算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const kruskal = (graph) =&gt; &#123; const &#123; length &#125; = graph; const parent = []; let ne = 0; let a; let b; let u; let v; // 首先，把邻接矩阵的值复制到 cost 数组，以方便修改且可以保留原始值 const cost = initializeCost(graph); // &#123;1&#125; // 当 MST 的边数小于顶点总数减 1 时 while (ne &lt; length - 1) &#123; // 找出权值最小的边 for (let i = 0, min = INF; i &lt; length; i++) &#123; // &#123;3&#125; for (let j = 0; j &lt; length; j++) &#123; if (cost[i][j] &lt; min) &#123; min = cost[i][j]; a = u = i; b = v = j; &#125; &#125; &#125; // 检查 MST 中是否已存在这条边，以避免环路 u = find(u, parent); // &#123;4&#125; v = find(v, parent); // &#123;5&#125; // 如果 u 和 v 是不同的边，则将其加入 MST if (union(u, v, parent)) &#123; // &#123;6&#125; ne++; &#125; // ：从列表中移除这些边，以免重复计算 cost[a][b] = cost[b][a] = INF; // &#123;7&#125; &#125; return parent;&#125;;const find = (i, parent) =&gt; &#123; while (parent[i]) &#123; i = parent[i]; &#125; return i;&#125;;const union = (i, j, parent) =&gt; &#123; if (i !== j) &#123; parent[j] = i; return true; &#125; return false;&#125;;","categories":[],"tags":[]},{"title":"数据结构与算法阅读笔记(4)","slug":"36-data-structure4","date":"2022-10-08T05:25:18.000Z","updated":"2023-08-03T03:03:40.028Z","comments":true,"path":"2022/10/08/36-data-structure4/","link":"","permalink":"https://sunjinkang.github.io/2022/10/08/36-data-structure4/","excerpt":"递归递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。 每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。","text":"递归递归是一种解决问题的方法，它从解决问题的各个小部分开始，直到解决最初的大问题。递归通常涉及函数调用自身。 每个递归函数都必须有基线条件，即一个不再递归调用的条件（停止点），以防止无限递归。 12345678function understandRecursion(doIunderstandRecursion) &#123; const recursionAnswer = confirm(&#x27;Do you understand recursion?&#x27;); if (recursionAnswer === true) &#123; // 基线条件或停止点 return true; &#125; understandRecursion(recursionAnswer); // 递归调用&#125; 计算一个数的阶乘数 n 的阶乘，定义为 n!，表示从 1 到 n 的整数的乘积。5 的阶乘表示为 5!，和 5 × 4 × 3 × 2 × 1 相等，结果是 120(1)迭代阶乘(n) _ (n - 1) _ (n - 2) _ (n - 3) _ … * 1 123456789function factorialIterative(number) &#123; if (number &lt; 0) return undefined; let total = 1; for (let n = number; n &gt; 1; n--) &#123; total = total * n; &#125; return total;&#125;console.log(factorialIterative(5)); // 120 (2)递归阶乘 12345678function factorial(n) &#123; if (n === 1 || n === 0) &#123; // 基线条件 return 1; &#125; return n * factorial(n - 1); // 递归调用&#125;console.log(factorial(5)); // 120 如果忘记加上用以停止函数递归调用的基线条件，递归并不会无限地执行下去，浏览器会抛出错误，也就是所谓的栈溢出错误（stack overflow error） 测试浏览器最大调用栈大小 12345678910let i = 0;function recursiveFn() &#123; i++; recursiveFn();&#125;try &#123; recursiveFn();&#125; catch (ex) &#123; console.log(&#x27;i = &#x27; + i + &#x27; error: &#x27; + ex);&#125; ECMAScript 2015 有尾调用优化（tail call optimization）。如果函数内的最后一个操作是调用函数（就像示例中加粗的那行），会通过“跳转指令”（jump）而不是“子程序调用”（subroutine call）来控制。也就是说，在 ECMAScript 2015 中，这里的代码可以一直执行下去。因此，具有停止递归的基线条件非常重要。有关尾调用优化的更多相关信息，请访问 https://www.chromestatus.com/feature/5516876633341952 斐波那契数列(1)位置 0 的斐波那契数是零(2)1 和 2 的斐波那契数是 1(3)n（此处 n &gt; 2）的斐波那契数是（n - 1）的斐波那契数加上（n - 2）的斐波那契数 迭代求斐波那契数 123456789101112131415function fibonacciIterative(n) &#123; if (n &lt; 1) return 0; if (n &lt;= 2) return 1; let fibNMinus2 = 0; let fibNMinus1 = 1; let fibN = n; for (let i = 2; i &lt;= n; i++) &#123; // n &gt;= 2 fibN = fibNMinus1 + fibNMinus2; // f(n-1) + f(n-2) fibNMinus2 = fibNMinus1; fibNMinus1 = fibN; &#125; return fibN;&#125;fibonacciIterative(9); // 34 递归求斐波那契数 123456function fibonacci(n) &#123; if (n &lt; 1) return 0; // &#123;1&#125; if (n &lt;= 2) return 1; // &#123;2&#125; return fibonacci(n - 1) + fibonacci(n - 2); // &#123;3&#125;&#125;fibonacci(9); // 34 记忆化斐波那契数 123456789function fibonacciMemoization(n) &#123; const memo = [0, 1]; // &#123;1&#125; const fibonacci = (n) =&gt; &#123; if (memo[n] != null) return memo[n]; // &#123;2&#125; return (memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo)); // &#123;3&#125; &#125;; return fibonacci(n);&#125;fibonacciMemoization(9); // 34 迭代的版本比递归的版本快很多，所以这表示递归更慢。但是，递归版本更容易理解，需要的代码通常也更少。另外，对一些算法来说，迭代的解法可能不可用，而且有了尾调用优化，递归的多余消耗甚至可能被消除 树数据结构树的相关术语一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点 位于树顶部的节点叫作根节点。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点。没有子元素的节点称为外部节点或叶节点。 一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。 子树：子树由节点和它的后代构成。 节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。 树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第 0 层，它的子节点在第 1 层，以此类推。 二叉树和二叉搜索树二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这个定义有助于我们写出更高效地在树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。 二叉搜索树（BST）是二叉树的一种，但是只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值。 通过指针（引用）来表示节点之间的关系（树相关的术语称其为边）键是树相关的术语中对节点的称呼 中序遍历先序遍历后序遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165export class Node &#123; constructor(key) &#123; this.key = key; // &#123;1&#125; 节点值 this.left = null; // 左侧子节点引用 this.right = null; // 右侧子节点引用 &#125;&#125;import &#123; Compare, defaultCompare &#125; from &#x27;../util&#x27;;import &#123; Node &#125; from &#x27;./models/node&#x27;;export default class BinarySearchTree &#123; constructor(compareFn = defaultCompare) &#123; this.compareFn = compareFn; // 用来比较节点值 this.root = null; // &#123;1&#125; Node 类型的根节点 &#125; // 向二叉搜索树中插入一个键 insert(key) &#123; if (this.root == null) &#123; // &#123;1&#125; this.root = new Node(key); // &#123;2&#125; &#125; else &#123; this.insertNode(this.root, key); // &#123;3&#125; &#125; &#125; insertNode(node, key) &#123; if (this.compareFn(key, node.key) === Compare.LESS_THAN) &#123; // &#123;4&#125; if (node.left == null) &#123; // &#123;5&#125; node.left = new Node(key); // &#123;6&#125; &#125; else &#123; this.insertNode(node.left, key); // &#123;7&#125; &#125; &#125; else &#123; if (node.right == null) &#123; // &#123;8&#125; node.right = new Node(key); // &#123;9&#125; &#125; else &#123; this.insertNode(node.right, key); // &#123;10&#125; &#125; &#125; &#125; // 中序遍历 // 中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。 // 中序遍历的一种应用就是对树进行排序操作。 inOrderTraverse(callback) &#123; this.inOrderTraverseNode(this.root, callback); // &#123;1&#125; &#125; inOrderTraverseNode(node, callback) &#123; if (node != null) &#123; // &#123;2&#125; this.inOrderTraverseNode(node.left, callback); // &#123;3&#125; callback(node.key); // &#123;4&#125; this.inOrderTraverseNode(node.right, callback); // &#123;5&#125; &#125; &#125; // 先序遍历 // 先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档 preOrderTraverse(callback) &#123; this.preOrderTraverseNode(this.root, callback); &#125; preOrderTraverseNode(node, callback) &#123; if (node != null) &#123; callback(node.key); // &#123;1&#125; this.preOrderTraverseNode(node.left, callback); // &#123;2&#125; this.preOrderTraverseNode(node.right, callback); // &#123;3&#125; &#125; &#125; // 后序遍历 // 后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小 postOrderTraverse(callback) &#123; this.postOrderTraverseNode(this.root, callback); &#125; postOrderTraverseNode(node, callback) &#123; if (node != null) &#123; this.postOrderTraverseNode(node.left, callback); // &#123;1&#125; this.postOrderTraverseNode(node.right, callback); // &#123;2&#125; callback(node.key); // &#123;3&#125; &#125; &#125; // 搜索最小值和最大值 min() &#123; return this.minNode(this.root); // &#123;1&#125; &#125; minNode(node) &#123; let current = node; while (current != null &amp;&amp; current.left != null) &#123; // &#123;2&#125; current = current.left; // &#123;3&#125; &#125; return current; // &#123;4&#125; &#125; max() &#123; return this.maxNode(this.root); &#125; maxNode(node) &#123; let current = node; while (current != null &amp;&amp; current.right != null) &#123; // &#123;5&#125; current = current.right; &#125; return current; &#125; // 搜索一个特定的值 search(key) &#123; return this.searchNode(this.root, key); // &#123;1&#125; &#125; searchNode(node, key) &#123; if (node == null) &#123; // &#123;2&#125; return false; &#125; if (this.compareFn(key, node.key) === Compare.LESS_THAN) &#123; // &#123;3&#125; return this.searchNode(node.left, key); // &#123;4&#125; &#125; else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123; // &#123;5&#125; return this.searchNode(node.right, key); // &#123;6&#125; &#125; else &#123; return true; // &#123;7&#125; &#125; &#125; // 移除一个节点 remove(key) &#123; this.root = this.removeNode(this.root, key); // &#123;1&#125; &#125; removeNode(node, key) &#123; if (node == null) &#123; // &#123;2&#125; return null; &#125; if (this.compareFn(key, node.key) === Compare.LESS_THAN) &#123; // &#123;3&#125; node.left = this.removeNode(node.left, key); // &#123;4&#125; return node; // &#123;5&#125; &#125; else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123; // &#123;6&#125; node.right = this.removeNode(node.right, key); // &#123;7&#125; return node; // &#123;8&#125; &#125; else &#123; // 键等于 node.key // 第一种情况: 该节点是一个没有左侧或右侧子节点的叶节点 if (node.left == null &amp;&amp; node.right == null) &#123; // &#123;9&#125; node = null; // &#123;10&#125; return node; // &#123;11&#125; &#125; // 第二种情况: 移除有一个左侧子节点或右侧子节点的节点 if (node.left == null) &#123; // &#123;12&#125; node = node.right; // &#123;13&#125; return node; // &#123;14&#125; &#125; else if (node.right == null) &#123; // &#123;15&#125; node = node.left; // &#123;16&#125; return node; // &#123;17&#125; &#125; // 第三种情况: 具体流程可查看后续文章 const aux = this.minNode(node.right); // &#123;18&#125; node.key = aux.key; // &#123;19&#125; node.right = this.removeNode(node.right, aux.key); // &#123;20&#125; return node; // &#123;21&#125; &#125; &#125;&#125; 移除有两个子节点的节点要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。(1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）。(2) 然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，我们改变了这个节点的键，也就是说它被移除了。(3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）。(4) 最后，向它的父节点返回更新后节点的引用（行{21}）。 自平衡树Adelson-Velskii-Landi 树（AVL 树）AVL 树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为 1。 在 AVL 树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为 0、1 或-1。如果结果不是这三个值之一，则需要平衡该 AVL 树。这就是平衡因子的概念 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138const BalanceFactor = &#123; UNBALANCED_RIGHT: 1, SLIGHTLY_UNBALANCED_RIGHT: 2, BALANCED: 3, SLIGHTLY_UNBALANCED_LEFT: 4, UNBALANCED_LEFT: 5,&#125;;class AVLTree extends BinarySearchTree &#123; constructor(compareFn = defaultCompare) &#123; super(compareFn); this.compareFn = compareFn; this.root = null; &#125; // 节点的高度和平衡因子 getNodeHeight(node) &#123; if (node == null) &#123; return -1; &#125; return ( Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) + 1 ); &#125; getBalanceFactor(node) &#123; const heightDifference = this.getNodeHeight(node.left) - this.getNodeHeight(node.right); switch (heightDifference) &#123; case -2: return BalanceFactor.UNBALANCED_RIGHT; case -1: return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT; case 1: return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT; case 2: return BalanceFactor.UNBALANCED_LEFT; default: return BalanceFactor.BALANCED; &#125; &#125; rotationLL(node) &#123; const tmp = node.left; // &#123;1&#125; node.left = tmp.right; // &#123;2&#125; tmp.right = node; // &#123;3&#125; return tmp; &#125; rotationRR(node) &#123; const tmp = node.right; // &#123;1&#125; node.right = tmp.left; // &#123;2&#125; tmp.left = node; // &#123;3&#125; return tmp; &#125; rotationLR(node) &#123; node.left = this.rotationRR(node.left); return this.rotationLL(node); &#125; rotationRL(node) &#123; node.right = this.rotationLL(node.right); return this.rotationRR(node); &#125; // 向 AVL 树插入节点 insert(key) &#123; this.root = this.insertNode(this.root, key); &#125; insertNode(node, key) &#123; // 像在 BST 树中一样插入节点 if (node == null) &#123; return new Node(key); &#125; else if (this.compareFn(key, node.key) === Compare.LESS_THAN) &#123; node.left = this.insertNode(node.left, key); &#125; else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) &#123; node.right = this.insertNode(node.right, key); &#125; else &#123; return node; // 重复的键 &#125; // 如果需要，将树进行平衡操作 const balanceFactor = this.getBalanceFactor(node); // &#123;1&#125; if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123; // &#123;2&#125; if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) &#123; // &#123;3&#125; node = this.rotationLL(node); // &#123;4&#125; &#125; else &#123; return this.rotationLR(node); // &#123;5&#125; &#125; &#125; if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123; // &#123;6&#125; if (this.compareFn(key, node.right.key) === Compare.BIGGER_THAN) &#123; // &#123;7&#125; node = this.rotationRR(node); // &#123;8&#125; &#125; else &#123; return this.rotationRL(node); // &#123;9&#125; &#125; &#125; return node; &#125; // 从 AVL 树中移除节点 removeNode(node, key) &#123; node = super.removeNode(node, key); // &#123;1&#125; if (node == null) &#123; return node; // null，不需要进行平衡 &#125; // 检测树是否平衡 const balanceFactor = this.getBalanceFactor(node); // &#123;2&#125; if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) &#123; // &#123;3&#125; const balanceFactorLeft = this.getBalanceFactor(node.left); // &#123;4&#125; if ( balanceFactorLeft === BalanceFactor.BALANCED || balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT ) &#123; // &#123;5&#125; return this.rotationLL(node); // &#123;6&#125; &#125; if (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) &#123; // &#123;7&#125; return this.rotationLR(node.left); // &#123;8&#125; &#125; &#125; if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) &#123; // &#123;9&#125; const balanceFactorRight = this.getBalanceFactor(node.right); // &#123;10&#125; if ( balanceFactorRight === BalanceFactor.BALANCED || balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT ) &#123; // &#123;11&#125; return this.rotationRR(node); // &#123;12&#125; &#125; if (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) &#123; // &#123;13&#125; return this.rotationRL(node.right); // &#123;14&#125; &#125; &#125; return node; &#125;&#125; 平衡操作——AVL 旋转(1)左-左（LL）：向右的单旋转这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的 rotationLL 方法与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为+2）所在的位置（行{1}）；节点 X 的左子树保持不变；将节点 Y 的左子节点置为节点 X 的右子节点 Z（行{2}）；将节点 X 的右子节点置为节点 Y（行{3}） (2)右-右（RR）：向左的单旋转右  右的情况和左  左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的 rotationRR 方法与平衡操作相关的节点有三个（X、Y、Z），将节点 X 置于节点 Y（平衡因子为 2）所在的位置（行{1}）；节点 X 的右子树保持不变；将节点 Y 的右子节点置为节点 X 的左子节点 Z（行{2}）；将节点 X 的左子节点置为节点 Y（行{3}） (3)左-右（LR）：向右的双旋转这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复 rotationLR 方法将节点 X 置于节点 Y（平衡因子为 2）所在的位置；将节点 Z 的左子节点置为节点 X 的右子节点；将节点 Y 的右子节点置为节点 X 的左子节点；将节点 X 的右子节点置为节点 Y；将节点 X 的左子节点置为节点 Z (4)右-左（RL）：向左的双旋转右-左的情况和左  右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右  右的情况，然后我们再对不平衡的节点进行一个左旋转来修复 rotationRL 方法将节点 X 置于节点 Y（平衡因子为+2）所在的位置；将节点 Y 的左子节点置为节点 X 的右子节点；将节点 Z 的右子节点置为节点 X 的左子节点；将节点 X 的左子节点置为节点 Y；将节点 X 的右子节点置为节点 Z 红黑树包含多次插入和删除的自平衡树，红黑树是比较好的。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL 树比红黑树更好 在红黑树中，每个节点都遵循以下规则：(1) 顾名思义，每个节点不是红的就是黑的；(2) 树的根节点是黑的；(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；(4) 如果一个节点是红的，那么它的两个子节点都是黑的；(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；(6) 从给定的节点到它的后代节点（NULL 叶节点）的所有路径包含相同数量的黑色节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145class RedBlackNode extends Node &#123; constructor(key) &#123; super(key); this.key = key; this.color = Colors.RED; // &#123;6&#125; this.parent = null; // &#123;7&#125; &#125; isRed() &#123; return this.color === Colors.RED; &#125;&#125;class RedBlackTree extends BinarySearchTree &#123; constructor(compareFn = defaultCompare) &#123; super(compareFn); this.compareFn = compareFn; this.root = null; &#125; insert(key: T) &#123; if (this.root == null) &#123; // &#123;1&#125; this.root = new RedBlackNode(key); // &#123;2&#125; this.root.color = Colors.BLACK; // &#123;3&#125; &#125; else &#123; const newNode = this.insertNode(this.root, key); // &#123;4&#125; this.fixTreeProperties(newNode); // &#123;5&#125; &#125; &#125; insertNode(node, key) &#123; if (this.compareFn(key, node.key) === Compare.LESS_THAN) &#123; if (node.left == null) &#123; node.left = new RedBlackNode(key); node.left.parent = node; // &#123;8&#125; return node.left; // &#123;9&#125; &#125; else &#123; return this.insertNode(node.left, key); &#125; &#125; else if (node.right == null) &#123; node.right = new RedBlackNode(key); node.right.parent = node; // &#123;10&#125; return node.right; // &#123;11&#125; &#125; else &#123; return this.insertNode(node.right, key); &#125; &#125; fixTreeProperties(node) &#123; while ( node &amp;&amp; node.parent &amp;&amp; node.parent.color.isRed() &amp;&amp; // &#123;1&#125; node.color !== Colors.BLACK ) &#123; // &#123;2&#125; let parent = node.parent; // &#123;3&#125; const grandParent = parent.parent; // &#123;4&#125; // 情形 A：父节点是左侧子节点 if (grandParent &amp;&amp; grandParent.left === parent) &#123; // &#123;5&#125; const uncle = grandParent.right; // &#123;6&#125; // 情形 1A：叔节点也是红色——只需要重新填色 if (uncle &amp;&amp; uncle.color === Colors.RED) &#123; // &#123;7&#125; grandParent.color = Colors.RED; parent.color = Colors.BLACK; uncle.color = Colors.BLACK; node = grandParent; // &#123;8&#125; &#125; else &#123; // 情形 2A：节点是右侧子节点——左旋转 if (node === parent.right) &#123; this.rotationRR(parent); // &#123;12&#125; node = parent; // &#123;13&#125; parent = node.parent; // &#123;14&#125; &#125; // 情形 3A：节点是左侧子节点——右旋转 this.rotationLL(grandParent); // &#123;15&#125; parent.color = Colors.BLACK; // &#123;16&#125; grandParent.color = Colors.RED; // &#123;17&#125; node = parent; // &#123;18&#125; &#125; &#125; else &#123; // 情形 B：父节点是右侧子节点 const uncle = grandParent.left; // &#123;9&#125; // 情形 1B：叔节点是红色——只需要重新填色 if (uncle &amp;&amp; uncle.color === Colors.RED) &#123; // &#123;10&#125; grandParent.color = Colors.RED; parent.color = Colors.BLACK; uncle.color = Colors.BLACK; node = grandParent; &#125; else &#123; // 情形 2B：节点是左侧子节点——左旋转 if (node === parent.left) &#123; this.rotationLL(parent); // &#123;19&#125; node = parent; parent = node.parent; &#125; // 情形 3B：节点是右侧子节点——左旋转 this.rotationRR(grandParent); // &#123;20&#125; parent.color = Colors.BLACK; grandParent.color = Colors.RED; node = parent; &#125; &#125; &#125; this.root.color = Colors.BLACK; // &#123;11&#125; &#125; rotationLL(node) &#123; const tmp = node.left; node.left = tmp.right; if (tmp.right &amp;&amp; tmp.right.key) &#123; tmp.right.parent = node; &#125; tmp.parent = node.parent; if (!node.parent) &#123; this.root = tmp; &#125; else &#123; if (node === node.parent.left) &#123; node.parent.left = tmp; &#125; else &#123; node.parent.right = tmp; &#125; &#125; tmp.right = node; node.parent = tmp; &#125; rotationRR(node) &#123; const tmp = node.right; node.right = tmp.left; if (tmp.left &amp;&amp; tmp.left.key) &#123; tmp.left.parent = node; &#125; tmp.parent = node.parent; if (!node.parent) &#123; this.root = tmp; &#125; else &#123; if (node === node.parent.left) &#123; node.parent.left = tmp; &#125; else &#123; node.parent.right = tmp; &#125; &#125; tmp.left = node; node.parent = tmp; &#125;&#125; 左-左（LL）：父节点是祖父节点的左侧子节点，节点是父节点的左侧子节点（情形 3A）。左-右（LR）：父节点是祖父节点的左侧子节点，节点是父节点的右侧子节点（情形 2A）。右-右（RR）：父节点是祖父节点的右侧子节点，节点是父节点的右侧子节点（情形 2A）。右-左（RL）：父节点是祖父节点的右侧子节点，节点是父节点的左侧子节点（情形 2A）。","categories":[],"tags":[]},{"title":"数据结构与算法阅读笔记(3)","slug":"35-data-structure3","date":"2022-09-29T02:49:51.000Z","updated":"2023-08-03T03:03:34.934Z","comments":true,"path":"2022/09/29/35-data-structure3/","link":"","permalink":"https://sunjinkang.github.io/2022/09/29/35-data-structure3/","excerpt":"集合集合是由一组无序且唯一（即不能重复）的项组成的 创建集合类","text":"集合集合是由一组无序且唯一（即不能重复）的项组成的 创建集合类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Set &#123; constructor() &#123; this.items = &#123;&#125;; &#125; has(element) &#123; return element in items; &#125; // Object 原型有 hasOwnProperty 方法。该方法返回一个表明对象是否具有特定属性的布尔值。 // in 运算符则返回表示对象在原型链上是否有特定属性的布尔值。 // has(element) &#123; // return Object.prototype.hasOwnProperty.call(this.items, element); // &#125; add(element) &#123; if (!this.has(element)) &#123; this.items[element] = element; // &#123;1&#125; return true; &#125; return false; &#125; delete(element) &#123; if (this.has(element)) &#123; delete this.items[element]; // &#123;1&#125; return true; &#125; return false; &#125; clear() &#123; this.items = &#123;&#125;; // &#123;2&#125; &#125; size() &#123; return Object.keys(this.items).length; // &#123;1&#125; &#125; // sizeLegacy() &#123; // let count = 0; // for(let key in this.items) &#123; // &#123;2&#125; // 不能简单地使用 for-in 语句迭代 items 对象的属性，并递增 count 变量 // 的值，还需要使用 has 方法（以验证 items 对象具有该属性），因为对象的原 // 型包含了额外的属性（属性既有继承自 JavaScript 的 Object 类的，也有属于对 // 象自身、未用于数据结构的） // if(this.items.hasOwnProperty(key)) &#123; // &#123;3&#125; // count++; // &#123;4&#125; // &#125; // return count; // &#125; values() &#123; return Object.values(this.items); &#125; // valuesLegacy() &#123; // let values = []; // for(let key in this.items) &#123; // &#123;1&#125; // if(this.items.hasOwnProperty(key)) &#123; // values.push(key); // &#123;2&#125; // &#125; // &#125; // return values; // &#125;&#125; 集合运算(1)并集：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。 1234567891011121314151617181920// 没有副作用的方法和函数被称为纯函数。纯函数不会修改当前的实例或参数，只会生成一个新的结果union(otherSet) &#123; const unionSet = new Set(); // &#123;1&#125; // 获取第一个集合（当前的 Set 类实例）所有的值（values），迭代并全部添加到代表并集的集合中 this.values().forEach(value =&gt; unionSet.add(value)); // &#123;2&#125; otherSet.values().forEach(value =&gt; unionSet.add(value)); // &#123;3&#125; return unionSet;&#125;const setA = new Set();setA.add(1);setA.add(2);setA.add(3);const setB = new Set();setB.add(3);setB.add(4);setB.add(5);setB.add(6);const unionAB = setA.union(setB);console.log(unionAB.values());// [1,2,3,4,5,6] (2)交集：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。 123456789101112131415161718192021222324252627282930313233343536373839404142intersection(otherSet) &#123; const intersectionSet = new Set(); // &#123;1&#125; const values = this.values(); for (let i = 0; i &lt; values.length; i++) &#123; // &#123;2&#125; if (otherSet.has(values[i])) &#123; // &#123;3&#125; intersectionSet.add(values[i]); // &#123;4&#125; &#125; &#125; return intersectionSet;&#125;const setA = new Set();setA.add(1);setA.add(2);setA.add(3);const setB = new Set();setB.add(2);setB.add(3);setB.add(4);const intersectionAB = setA.intersection(setB);console.log(intersectionAB.values());// [2,3]// 优化intersection(otherSet) &#123; const intersectionSet = new Set(); // &#123;1&#125; const values = this.values(); // &#123;2&#125; const otherValues = otherSet.values(); // &#123;3&#125; let biggerSet = values; // &#123;4&#125; let smallerSet = otherValues; // &#123;5&#125; if (otherValues.length - values.length &gt; 0) &#123; // &#123;6&#125; biggerSet = otherValues; smallerSet = values; &#125; smallerSet.forEach(value =&gt; &#123; // &#123;7&#125; if (biggerSet.includes(value)) &#123; intersectionSet.add(value); &#125; &#125;); return intersectionSet;&#125; (3)差集：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。 123456789101112131415161718192021difference(otherSet) &#123; const differenceSet = new Set(); // &#123;1&#125; this.values().forEach(value =&gt; &#123; // &#123;2&#125; if (!otherSet.has(value)) &#123; // &#123;3&#125; differenceSet.add(value); // &#123;4&#125; &#125; &#125;); return differenceSet;&#125;const setA = new Set();setA.add(1);setA.add(2);setA.add(3);const setB = new Set();setB.add(2);setB.add(3);setB.add(4);const differenceAB = setA.difference(setB);console.log(differenceAB.values());// [1] (4)子集：验证一个给定集合是否是另一集合的子集 12345678910111213141516171819202122232425262728293031isSubsetOf(otherSet) &#123; if (this.size() &gt; otherSet.size()) &#123; // &#123;1&#125; return false; &#125; let isSubset = true; // &#123;2&#125; // 只要回调函数返回 true，every 方法就会被调用（行&#123;6&#125;）。如果回调函数返回 false，循环会停止 this.values().every(value =&gt; &#123; // &#123;3&#125; if (!otherSet.has(value)) &#123; // &#123;4&#125; isSubset = false; // &#123;5&#125; return false; &#125; return true; // &#123;6&#125; &#125;); return isSubset; // &#123;7&#125;&#125;const setA = new Set();setA.add(1);setA.add(2);const setB = new Set();setB.add(1);setB.add(2);setB.add(3);const setC = new Set();setC.add(2);setC.add(3);setC.add(4);console.log(setA.isSubsetOf(setB));// trueconsole.log(setA.isSubsetOf(setC));// false 使用扩展运算符12345678// 并集console.log(new Set([...setA, ...setB]));// 交集console.log(new Set([...setA].filter((x) =&gt; setB.has(x))));// 差集console.log(new Set([...setA].filter((x) =&gt; !setB.has(x)))); 字典和散列表字典在字典中，存储的是[键，值]对，其中键名是用来查询特定元素的。字典和集合很相似，集合以[值，值]的形式存储元素，字典则是以[键，值]的形式来存储元素。字典也称作映射、符号表或关联数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// util.jsexport function defaultToString(item) &#123; if (item === null) &#123; return &#x27;NULL&#x27;; &#125; else if (item === undefined) &#123; return &#x27;UNDEFINED&#x27;; &#125; else if (typeof item === &#x27;string&#x27; || item instanceof String) &#123; return `$&#123;item&#125;`; &#125; return item.toString(); // &#123;1&#125;&#125;class ValuePair &#123; constructor(key, value) &#123; this.key = key; this.value = value; &#125; toString() &#123; return `[#$&#123;this.key&#125;: $&#123;this.value&#125;]`; &#125;&#125;import &#123; defaultToString &#125; from &#x27;../util&#x27;;export default class Dictionary &#123; constructor(toStrFn = defaultToString) &#123; this.toStrFn = toStrFn; // &#123;1&#125; this.table = &#123;&#125;; // &#123;2&#125; &#125; // 检测一个键是否存在于字典中 hasKey(key) &#123; return this.table[this.toStrFn(key)] != null; &#125; // 在字典和 ValuePair 类中设置键和值 set(key, value) &#123; if (key != null &amp;&amp; value != null) &#123; const tableKey = this.toStrFn(key); // &#123;1&#125; this.table[tableKey] = new ValuePair(key, value); // &#123;2&#125; return true; &#125; return false; &#125; // 从字典中移除一个值 remove(key) &#123; if (this.hasKey(key)) &#123; delete this.table[this.toStrFn(key)]; return true; &#125; return false; &#125; // 从字典中检索一个值 get(key) &#123; const valuePair = this.table[this.toStrFn(key)]; // &#123;1&#125; return valuePair == null ? undefined : valuePair.value; // &#123;2&#125; &#125; keyValues() &#123; return Object.values(this.table); &#125; keys() &#123; return this.keyValues().map((valuePair) =&gt; valuePair.key); &#125; values() &#123; return this.keyValues().map((valuePair) =&gt; valuePair.value); &#125; forEach(callbackFn) &#123; const valuePairs = this.keyValues(); // &#123;1&#125; for (let i = 0; i &lt; valuePairs.length; i++) &#123; // &#123;2&#125; const result = callbackFn(valuePairs[i].key, valuePairs[i].value); // &#123;3&#125; if (result === false) &#123; break; // &#123;4&#125; &#125; &#125; &#125; size() &#123; return Object.keys(this.table).length; &#125; isEmpty() &#123; return this.size() === 0; &#125; clear() &#123; this.table = &#123;&#125;; &#125; toString() &#123; if (this.isEmpty()) &#123; return &#x27;&#x27;; &#125; const valuePairs = this.keyValues(); let objString = `$&#123;valuePairs[0].toString()&#125;`; // &#123;1&#125; for (let i = 1; i &lt; valuePairs.length; i++) &#123; objString = `$&#123;objString&#125;,$&#123;valuePairs[i].toString()&#125;`; // &#123;2&#125; &#125; return objString; // &#123;3&#125; &#125;&#125; 散列表散列算法的作用是尽可能快地在数据结构中找到一个值 散列函数的作用是给定一个键值，然后返回值在表中的地址 散列表有一些在计算机科学中应用的例子:(1)用来对数据库进行索引。当我们在关系型数据库（如 MySQL、Microsoft SQL Server、Oracle，等等）中创建一个新的表时，一个不错的做法是同时创建一个索引来更快地查询到记录的 key。在这种情况下，散列表可以用来保存键和对表中记录的引用(2)使用散列表来表示对象。JavaScript 语言内部就是使用散列表来表示每个对象。此时，对象的每个属性和方法（成员）被存储为 key 对象类型，每个 key 指向对应的对象成员。 散列函数 —- lose lose 散列函数 HashTable 和 Dictionary 类很相似。不同之处在于在 Dictionary 类中，我们将 valuePair 保存在 table 的 key 属性中（在它被转化为字符串之后），而在 HashTable 类中，我们由 key（hash）生成一个数，并将 valuePair 保存在 hash 位置（或属性） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class HashTable &#123; constructor(toStrFn = defaultToString) &#123; this.toStrFn = toStrFn; this.table = &#123;&#125;; &#125; // 创建散列函数 loseloseHashCode(key) &#123; if (typeof key === &#x27;number&#x27;) &#123; // &#123;1&#125; return key; &#125; const tableKey = this.toStrFn(key); // &#123;2&#125; // 根据组成 key 的每个字符的 ASCII 码值的和得到一个数 let hash = 0; // &#123;3&#125; for (let i = 0; i &lt; tableKey.length; i++) &#123; hash += tableKey.charCodeAt(i); // &#123;4&#125; &#125; // 为了得到比较小的数值，我们会使用 hash 值和一个任意数做除法的余数（%）（行&#123;5&#125;） // 这可以规避操作数超过数值变量最大表示范围的风险 return hash % 37; // &#123;5&#125; &#125; hashCode(key) &#123; return this.loseloseHashCode(key); &#125; put(key, value) &#123; if (key != null &amp;&amp; value != null) &#123; // &#123;1&#125; const position = this.hashCode(key); // &#123;2&#125; this.table[position] = new ValuePair(key, value); // &#123;3&#125; return true; &#125; return false; &#125; get(key) &#123; const valuePair = this.table[this.hashCode(key)]; return valuePair == null ? undefined : valuePair.value; &#125; remove(key) &#123; const hash = this.hashCode(key); // &#123;1&#125; const valuePair = this.table[hash]; // &#123;2&#125; if (valuePair != null) &#123; delete this.table[hash]; // &#123;3&#125; return true; &#125; return false; &#125;&#125;const hash = new HashTable();hash.put(&#x27;Gandalf&#x27;, &#x27;gandalf@email.com&#x27;);hash.put(&#x27;John&#x27;, &#x27;johnsnow@email.com&#x27;);hash.put(&#x27;Tyrion&#x27;, &#x27;tyrion@email.com&#x27;);console.log(hash.hashCode(&#x27;Gandalf&#x27;) + &#x27; - Gandalf&#x27;);console.log(hash.hashCode(&#x27;John&#x27;) + &#x27; - John&#x27;);console.log(hash.hashCode(&#x27;Tyrion&#x27;) + &#x27; - Tyrion&#x27;);// 19 - Gandalf// 29 - John// 16 - Tyrion 散列集合散列集合由一个集合构成，但是插入、移除或获取元素时，使用的是 hashCode 函数散列集合和散列表的不同之处在于，不再添加键值对，而是只插入值而没有键。例如，可以使用散列集合来存储所有的英语单词（不包括它们的定义）。和集合相似，散列集合只存储不重复的唯一值。 散列表中的冲突有时候，一些键会有相同的散列值。不同的值在散列表中对应相同位置的时候，我们称其为冲突 处理冲突有几种方法：分离链接、线性探查和双散列法。 (1)分离链接分离链接法包括为散列表的每一个位置创建一个链表并将元素存储在里面。它是解决冲突的最简单的方法，但是在 HashTable 实例之外还需要额外的存储空间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class HashTableSeparateChaining &#123; constructor(toStrFn = defaultToString) &#123; this.toStrFn = toStrFn; this.table = &#123;&#125;; &#125; put(key, value) &#123; if (key != null &amp;&amp; value != null) &#123; const position = this.hashCode(key); // 将验证要加入新元素的位置是否已经被占据 if (this.table[position] == null) &#123; // &#123;1&#125; this.table[position] = new LinkedList(); // &#123;2&#125; &#125; this.table[position].push(new ValuePair(key, value)); // &#123;3&#125; return true; &#125; return false; &#125; // 除了在 get 方法内部搜索 key，还可以在 put 方法中实例化 // LinkedList，向 LinkedList 的构造函数传入自定义的 equalsFn，只用它来比较元素的 key // 属性（即 ValuePair 实例）。我们要记住，默认情况下，LinkedList 会使用===运算符来比较 // 它的元素实例，也就是说会比较 ValuePair 实例的引用。这种情况下，在 get 方法中，我们要 // 使用 indexOf 方法来搜索目标 key，如果返回大于或等于零的位置，则说明元素存在于链表中。 // 有了该位置，我们就可以使用 getElementAt 方法来从链表中获取 ValuePair 实例。 get(key) &#123; const position = this.hashCode(key); const linkedList = this.table[position]; // &#123;1&#125; if (linkedList != null &amp;&amp; !linkedList.isEmpty()) &#123; // &#123;2&#125; let current = linkedList.getHead(); // &#123;3&#125; while (current != null) &#123; // &#123;4&#125; if (current.element.key === key) &#123; // &#123;5&#125; return current.element.value; // &#123;6&#125; &#125; current = current.next; // &#123;7&#125; &#125; &#125; return undefined; // &#123;8&#125; &#125; remove(key) &#123; const position = this.hashCode(key); const linkedList = this.table[position]; if (linkedList != null &amp;&amp; !linkedList.isEmpty()) &#123; let current = linkedList.getHead(); while (current != null) &#123; if (current.element.key === key) &#123; // &#123;1&#125; linkedList.remove(current.element); // &#123;2&#125; if (linkedList.isEmpty()) &#123; // &#123;3&#125; delete this.table[position]; // &#123;4&#125; &#125; return true; // &#123;5&#125; &#125; current = current.next; // &#123;6&#125; &#125; &#125; return false; // &#123;7&#125; &#125;&#125; (2)线性探查它处理冲突的方法是将元素直接存储到表中，而不是在单独的数据结构中当想向表中某个位置添加一个新元素的时候，如果索引为 position 的位置已经被占据了，就尝试 position+1 的位置。如果 position+1 的位置也被占据了，就尝试 position+2 的位置，以此类推，直到在散列表中找到一个空闲的位置 线性探查技术分为两种。 第一种是软删除方法。我们使用一个特殊的值（标记）来表示键值对被删除了（惰性删除或软删除），而不是真的删除它。经过一段时间，散列表被操作过后，我们会得到一个标记了若干删除位置的散列表。这会逐渐降低散列表的效率，因为搜索键值会随时间变得更慢。能快速访问并找到一个键是我们使用散列表的一个重要原因源代码 第二种方法需要检验是否有必要将一个或多个元素移动到之前的位置。当搜索一个键的时候，这种方法可以避免找到一个空位置。如果移动元素是必要的，我们就需要在散列表中挪动键值对。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// move-keyclass HashTableSeparateChainingMoveKey &#123; constructor(toStrFn = defaultToString) &#123; this.toStrFn = toStrFn; this.table = &#123;&#125;; &#125; put(key, value) &#123; if (key != null &amp;&amp; value != null) &#123; const position = this.hashCode(key); if (this.table[position] == null) &#123; // &#123;1&#125; this.table[position] = new ValuePair(key, value); // &#123;2&#125; &#125; else &#123; let index = position + 1; // &#123;3&#125; while (this.table[index] != null) &#123; // &#123;4&#125; index++; // &#123;5&#125; &#125; this.table[index] = new ValuePair(key, value); // &#123;6&#125; &#125; return true; &#125; return false; &#125; // 在一些编程语言中，我们需要定义数组的大小。如果使用线性探查的话，需要注 // 意的一个问题是数组的可用位置可能会被用完。当算法到达数组的尾部时，它需 // 要循环回到开头并继续迭代元素。如果必要的话，我们还需要创建一个更大的数 // 组并将元素复制到新数组中。在 JavaScript 中，不需要担心这个问题。我们不需 // 要定义数组的大小，因为它可以根据需要自动改变——这是 JavaScript 内置的一 // 个功能 get(key) &#123; const position = this.hashCode(key); if (this.table[position] != null) &#123; // &#123;1&#125; if (this.table[position].key === key) &#123; // &#123;2&#125; return this.table[position].value; // &#123;3&#125; &#125; let index = position + 1; // &#123;4&#125; while (this.table[index] != null &amp;&amp; this.table[index].key !== key) &#123; // &#123;5&#125; index++; &#125; if (this.table[index] != null &amp;&amp; this.table[index].key === key) &#123; // &#123;6&#125; return this.table[position].value; // &#123;7&#125; &#125; &#125; return undefined; // &#123;8&#125; &#125; remove(key) &#123; const position = this.hashCode(key); if (this.table[position] != null) &#123; if (this.table[position].key === key) &#123; delete this.table[position]; // &#123;1&#125; this.verifyRemoveSideEffect(key, position); // &#123;2&#125; return true; &#125; let index = position + 1; while (this.table[index] != null &amp;&amp; this.table[index].key !== key) &#123; index++; &#125; if (this.table[index] != null &amp;&amp; this.table[index].key === key) &#123; delete this.table[index]; // &#123;3&#125; this.verifyRemoveSideEffect(key, index); // &#123;4&#125; return true; &#125; &#125; return false; &#125; verifyRemoveSideEffect(key, removedPosition) &#123; const hash = this.hashCode(key); // &#123;1&#125; let index = removedPosition + 1; // &#123;2&#125; while (this.table[index] != null) &#123; // &#123;3&#125; const posHash = this.hashCode(this.table[index].key); // &#123;4&#125; if (posHash &lt;= hash || posHash &lt;= removedPosition) &#123; // &#123;5&#125; this.table[removedPosition] = this.table[index]; // &#123;6&#125; delete this.table[index]; removedPosition = index; &#125; index++; &#125; &#125;&#125; 更好的散列函数一个表现良好的散列函数是由几个方面构成的：插入和检索元素的时间（即性能），以及较低的冲突可能性。 123456789101112djb2HashCode(key) &#123; const tableKey = this.toStrFn(key); // &#123;1&#125;// 括初始化一个 hash 变量并赋值为一个质数,大多数实现使用5381 let hash = 5381; // &#123;2&#125; for (let i = 0; i &lt; tableKey.length; i++) &#123; // &#123;3&#125;// 将 hash 与 33相乘（用作一个幻数，在编程中指直接使用的常数），并和当前迭代到的字符的 ASCII 码值相加 hash = (hash * 33) + tableKey.charCodeAt(i); // &#123;4&#125; &#125;// 将使用相加的和与另一个随机质数相除的余数 return hash % 1013; // &#123;5&#125;&#125;// 也有一些为数字键值准备的散列函数：http://t.cn/Eqg1yb0 ES2015 Map 类 1234567891011const map = new Map();map.set(&#x27;Gandalf&#x27;, &#x27;gandalf@email.com&#x27;);map.set(&#x27;John&#x27;, &#x27;johnsnow@email.com&#x27;);map.set(&#x27;Tyrion&#x27;, &#x27;tyrion@email.com&#x27;);console.log(map.has(&#x27;Gandalf&#x27;)); // trueconsole.log(map.size); // 3console.log(map.keys()); // 输出&#123;&quot;Gandalf&quot;, &quot;John&quot;, &quot;Tyrion&quot;&#125;console.log(map.values()); // 输出&#123;&quot;gandalf@email.com&quot;, &quot;johnsnow@email.com&quot;,&quot;tyrion@email.com&quot;&#125;console.log(map.get(&#x27;Tyrion&#x27;)); // tyrion@email.commap.delete(&#x27;John&#x27;); ES2105 WeakMap 类和 WeakSet 类Map 和 Set 与其弱化版本之间仅有的区别是:(1)WeakSet 或 WeakMap 类没有 entries、keys 和 values 等方法(2)WeakSet 和 WeakMap 只能用对象作为键 12345678910const map = new WeakMap();const ob1 = &#123; name: &#x27;Gandalf&#x27; &#125;; // &#123;1&#125;const ob2 = &#123; name: &#x27;John&#x27; &#125;;const ob3 = &#123; name: &#x27;Tyrion&#x27; &#125;;map.set(ob1, &#x27;gandalf@email.com&#x27;); // &#123;2&#125;map.set(ob2, &#x27;johnsnow@email.com&#x27;);map.set(ob3, &#x27;tyrion@email.com&#x27;);console.log(map.has(ob1)); // true &#123;3&#125;console.log(map.get(ob3)); // tyrion@email.com &#123;4&#125;map.delete(ob2); // &#123;5&#125; 注意：WeakMap 类也可以用 set 方法，但不能使用数、字符串、布尔值等基本数据类型，需要将名字转换为对象","categories":[],"tags":[]},{"title":"数据结构与算法阅读笔记(2)","slug":"34-data-structure2","date":"2022-09-23T07:52:54.000Z","updated":"2023-08-03T03:03:19.237Z","comments":true,"path":"2022/09/23/34-data-structure2/","link":"","permalink":"https://sunjinkang.github.io/2022/09/23/34-data-structure2/","excerpt":"队列队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾","text":"队列队列是遵循先进先出（FIFO，也称为先来先服务）原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素必须排在队列的末尾 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Queue &#123; constructor() &#123; this.count = 0; // &#123;1&#125; this.lowestCount = 0; // &#123;2&#125; this.items = &#123;&#125;; // &#123;3&#125; &#125; // 向队列添加元素 enqueue(element) &#123; this.items[this.count] = element; this.count++; &#125; // 从队列移除元素 dequeue() &#123; if (this.isEmpty()) &#123; return undefined; &#125; const result = this.items[this.lowestCount]; // &#123;1&#125; delete this.items[this.lowestCount]; // &#123;2&#125; this.lowestCount++; // &#123;3&#125; return result; // &#123;4&#125; &#125; // 查看队列头元素 peek() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.lowestCount]; &#125; // 检查队列是否为空 isEmpty() &#123; return this.count - this.lowestCount === 0; &#125; // 获取队列的长度 size() &#123; return this.count - this.lowestCount; &#125; // 清空队列 clear() &#123; this.items = &#123;&#125;; this.count = 0; this.lowestCount = 0; &#125; toString() &#123; if (this.isEmpty()) &#123; return &#x27;&#x27;; &#125; let objString = `$&#123;this.items[this.lowestCount]&#125;`; for (let i = this.lowestCount + 1; i &lt; this.count; i++) &#123; objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`; &#125; return objString; &#125;&#125; 双端队列双端队列（deque，或称 double-ended queue）是一种允许我们同时从前端和后端添加和移除元素的特殊队列 由于双端队列同时遵守了先进先出和后进先出原则，可以说它是把队列和栈相结合的一种数据结构 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Deque &#123; constructor() &#123; this.count = 0; this.lowestCount = 0; this.items = &#123;&#125;; &#125; // 向双端队列的前端添加元素 addFront(element) &#123; if (this.isEmpty()) &#123; // &#123;1&#125; this.addBack(element); &#125; else if (this.lowestCount &gt; 0) &#123; // &#123;2&#125; this.lowestCount--; this.items[this.lowestCount] = element; &#125; else &#123; for (let i = this.count; i &gt; 0; i--) &#123; // &#123;3&#125; this.items[i] = this.items[i - 1]; &#125; this.count++; this.lowestCount = 0; this.items[0] = element; // &#123;4&#125; &#125; &#125; addBack(element) &#123; this.items[this.count] = element; this.count++; &#125; removeFront() &#123; if (this.isEmpty()) &#123; return undefined; &#125; const result = this.items[this.lowestCount]; // &#123;1&#125; delete this.items[this.lowestCount]; // &#123;2&#125; this.lowestCount++; // &#123;3&#125; return result; // &#123;4&#125; &#125; removeBack() &#123; if (this.isEmpty()) &#123; return undefined; &#125; this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; &#125; peekFront() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.lowestCount]; &#125; peekBack() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.count - 1]; &#125; isEmpty() &#123; return this.count - this.lowestCount === 0; &#125; clear() &#123; this.count = 0; this.lowestCount = 0; this.items = &#123;&#125;; &#125;&#125; 循环队列 - 击鼓传花场景：在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者） 12345678910111213141516171819202122232425262728function hotPotato(elementsList, num) &#123; const queue = new Queue(); // &#123;1&#125; const elimitatedList = []; // 把名单的名字全都加入队列 for (let i = 0; i &lt; elementsList.length; i++) &#123; queue.enqueue(elementsList[i]); // &#123;2&#125; &#125; // 迭代队列 while (queue.size() &gt; 1) &#123; for (let i = 0; i &lt; num; i++) &#123; // 将队列开头一项移除，添加到队列末尾 queue.enqueue(queue.dequeue()); // &#123;3&#125; &#125; // 将超出限制的队列开头一项移除，作为淘汰项 elimitatedList.push(queue.dequeue()); // &#123;4&#125; &#125; return &#123; eliminated: elimitatedList, winner: queue.dequeue() // &#123;5&#125; &#125;;&#125;const names = [&#x27;John&#x27;, &#x27;Jack&#x27;, &#x27;Camila&#x27;, &#x27;Ingrid&#x27;, &#x27;Carl&#x27;]; const result = hotPotato(names, 7);result.eliminated.forEach(name =&gt; &#123; console.log(`$&#123;name&#125;在击鼓传花游戏中被淘汰。`); &#125;); console.log(`胜利者： $&#123;result.winner&#125;`); 回文检查器回文：回文是正反都能读通的单词、词组、数或一系列字符的序列，例如 madam或 racecar。 12345678910111213141516171819202122232425function palindromeChecker(aString) &#123; // 检查传入的字符串参数是否合法 if (aString === undefined || aString === null || (aString !== null &amp;&amp; aString.length === 0)) &#123; // &#123;1&#125; return false; &#125; const deque = new Deque(); // &#123;2&#125; // 将所有字母转化为小写，同时移除所有的空格 const lowerString = aString.toLocaleLowerCase().split(&#x27; &#x27;).join(&#x27;&#x27;); // &#123;3&#125; let isEqual = true; let firstChar, lastChar; // 将所有字符串加入队列中 for (let i = 0; i &lt; lowerString.length; i++) &#123; // &#123;4&#125; deque.addBack(lowerString.charAt(i)); &#125; while (deque.size() &gt; 1 &amp;&amp; isEqual) &#123; // &#123;5&#125; firstChar = deque.removeFront(); // &#123;6&#125; lastChar = deque.removeBack(); // &#123;7&#125; if (firstChar !== lastChar) &#123; isEqual = false; // &#123;8&#125; &#125; &#125; return isEqual;&#125; javascript事件循环 链表链表数据结构链表的好处：添加或移除元素的时候不需要移动其他元素要想访问链表中间的一个元素，需要从起点（表头）开始迭代链表直到找到所需的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// util.jsexport function defaultEquals(a, b) &#123; return a === b; &#125;// models/linked-list-modelsexport class Node &#123; constructor(element) &#123; this.element = element; this.next = undefined; &#125;&#125; import &#123; defaultEquals &#125; from &#x27;../util&#x27;; import &#123; Node &#125; from &#x27;./models/linked-list-models&#x27;; // &#123;1&#125; export default class LinkedList &#123; constructor(equalsFn = defaultEquals) &#123; this.count = 0; // &#123;2&#125; this.head = undefined; // &#123;3&#125; this.equalsFn = equalsFn; // &#123;4&#125; &#125; // 向链表尾部添加元素 push(element) &#123; const node = new Node(element); // &#123;1&#125; let current; // &#123;2&#125; if (this.head == null) &#123; // &#123;3&#125; this.head = node; &#125; else &#123; current = this.head; // &#123;4&#125; while (current.next != null) &#123; // &#123;5&#125; 获得最后一项 current = current.next; &#125; // 将其 next 赋为新元素，建立链接 current.next = node; // &#123;6&#125; &#125; this.count++; // &#123;7&#125; &#125; // 从链表中移除元素 removeAt(index) &#123; // 检查越界值 if (index &gt;= 0 &amp;&amp; index &lt; this.count) &#123; // &#123;1&#125; let current = this.head; // &#123;2&#125; // 移除第一项 if (index === 0) &#123; // &#123;3&#125; this.head = current.next; &#125; else &#123; // 获取当前index的前一个节点 const previous = this.getElementAt(index - 1); current = previous.next; // 将 previous 与 current 的下一项链接起来：跳过 current，从而移除它 previous.next = current.next; // &#123;8&#125; &#125; this.count--; // &#123;9&#125; return current.element; &#125; return undefined; // &#123;10&#125; &#125; // 循环迭代链表直到目标位置 getElementAt(index) &#123; if (index &gt;= 0 &amp;&amp; index &lt;= this.count) &#123; // &#123;1&#125; let node = this.head; // &#123;2&#125; for (let i = 0; i &lt; index &amp;&amp; node != null; i++) &#123; // &#123;3&#125; node = node.next; &#125; return node; // &#123;4&#125; &#125; return undefined; // &#123;5&#125; &#125; // 在任意位置插入元素 insert(element, index) &#123; if (index &gt;= 0 &amp;&amp; index &lt;= this.count) &#123; // &#123;1&#125; const node = new Node(element); if (index === 0) &#123; // 在第一个位置添加 const current = this.head; node.next = current; // &#123;2&#125; this.head = node; &#125; else &#123; const previous = this.getElementAt(index - 1); // &#123;3&#125; const current = previous.next; // &#123;4&#125; node.next = current; // &#123;5&#125; previous.next = node; // &#123;6&#125; &#125; this.count++; // 更新链表的长度 return true; &#125; return false; // &#123;7&#125; &#125; // indexOf 方法：返回一个元素的位置 indexOf(element) &#123; let current = this.head; // &#123;1&#125; for (let i = 0; i &lt; this.count &amp;&amp; current != null; i++) &#123; // &#123;2&#125; if (this.equalsFn(element, current.element)) &#123; // &#123;3&#125; return i; // &#123;4&#125; &#125; current = current.next; // &#123;5&#125; &#125; return -1; // &#123;6&#125; &#125; // 从链表中移除元素 remove(element) &#123; const index = this.indexOf(element); return this.removeAt(index); &#125; size() &#123; return this.count; &#125; isEmpty() &#123; return this.count === 0; &#125; getHead() &#123; return this.head; &#125; toString() &#123; if (this.head == null) &#123; // &#123;1&#125; return &#x27;&#x27;; &#125; let objString = `$&#123;this.head.element&#125;`; // &#123;2&#125; let current = this.head.next; // &#123;3&#125; for (let i = 1; i &lt; this.size() &amp;&amp; current != null; i++) &#123; // &#123;4&#125; objString = `$&#123;objString&#125;,$&#123;current.element&#125;`; current = current.next; &#125; return objString; // &#123;5&#125; &#125;&#125; javascript垃圾回收器 双向链表在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class DoublyNode extends Node &#123; // &#123;1&#125; constructor(element, next, prev) &#123; super(element, next); // &#123;2&#125; this.prev = prev; // &#123;3&#125; 新增的 &#125; &#125;class DoublyLinkedList extends LinkedList &#123; // &#123;4&#125; constructor(equalsFn = defaultEquals) &#123; super(equalsFn); // &#123;5&#125; this.tail = undefined; // &#123;6&#125; 新增的 &#125; // 在任意位置插入新元素 insert(element, index) &#123; if (index &gt;= 0 &amp;&amp; index &lt;= this.count) &#123; const node = new DoublyNode(element); let current = this.head; if (index === 0) &#123; if (this.head == null) &#123; // &#123;1&#125; 新增的 this.head = node; this.tail = node; &#125; else &#123; node.next = this.head; // &#123;2&#125; current.prev = node; // &#123;3&#125; 新增的 this.head = node; // &#123;4&#125; &#125; &#125; else if (index === this.count) &#123; // 最后一项 // 新增的 current = this.tail; // &#123;5&#125; current.next = node; // &#123;6&#125; node.prev = current; // &#123;7&#125; this.tail = node; // &#123;8&#125; &#125; else &#123; const previous = this.getElementAt(index - 1); // &#123;9&#125; current = previous.next; // &#123;10&#125; node.next = current; // &#123;11&#125; previous.next = node; // &#123;12&#125; current.prev = node; // &#123;13&#125; 新增的 node.prev = previous; // &#123;14&#125; 新增的 &#125; this.count++; return true; &#125; return false; &#125; // 从任意位置移除元素 removeAt(index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; this.count) &#123; let current = this.head; if (index === 0) &#123; this.head = current.next; // &#123;1&#125; // 如果只有一项，更新 tail // 新增的 if (this.count === 1) &#123; // &#123;2&#125; this.tail = undefined; &#125; else &#123; this.head.prev = undefined; // &#123;3&#125; &#125; &#125; else if (index === this.count - 1) &#123; // 最后一项 //新增的 current = this.tail; // &#123;4&#125; this.tail = current.prev; // &#123;5&#125; this.tail.next = undefined; // &#123;6&#125; &#125; else &#123; current = this.getElementAt(index); // &#123;7&#125; const previous = current.prev; // &#123;8&#125; // 将 previous 与 current 的下一项链接起来——跳过 current previous.next = current.next; // &#123;9&#125; current.next.prev = previous; // &#123;10&#125; 新增的 &#125; this.count--; return current.element; &#125; return undefined; &#125;&#125;// 源码：https://github.com/loiane/javascript-datastructures-algorithms 循环链表循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用undefined，而是指向第一个元素（head）双向循环链表有指向 head 元素的 tail.next 和指向 tail 元素的 head.prev 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class CircularLinkedList extends LinkedList &#123; constructor(equalsFn = defaultEquals) &#123; super(equalsFn); &#125; // 在任意位置插入新元素 insert(element, index) &#123; if (index &gt;= 0 &amp;&amp; index &lt;= this.count) &#123; const node = new Node(element); let current = this.head; if (index === 0) &#123; if (this.head == null) &#123; this.head = node; // &#123;1&#125; node.next = this.head; // &#123;2&#125; 新增的 &#125; else &#123; node.next = current; // &#123;3&#125; current = this.getElementAt(this.size()); // &#123;4&#125; // 更新最后一个元素 this.head = node; // &#123;5&#125; current.next = this.head; // &#123;6&#125; 新增的 &#125; &#125; else &#123; // 这种场景没有变化 const previous = this.getElementAt(index - 1); node.next = previous.next; previous.next = node; &#125; this.count++; return true; &#125; return false; &#125; // 从任意位置移除元素 removeAt(index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; this.count) &#123; let current = this.head; if (index === 0) &#123; if (this.size() === 1) &#123; this.head = undefined; &#125; else &#123; const removed = this.head; // &#123;1&#125; current = this.getElementAt(this.size()); // &#123;2&#125; 新增的 this.head = this.head.next; // &#123;3&#125; current.next = this.head; // &#123;4&#125; current = removed; // &#123;5&#125; &#125; &#125; else &#123; // 不需要修改循环链表最后一个元素 const previous = this.getElementAt(index - 1); current = previous.next; previous.next = current.next; &#125; this.count--; return current.element; // &#123;6&#125; &#125; return undefined; &#125;&#125; 有序链表有序链表是指保持元素有序的链表结构。除了使用排序算法之外，我们还可以将元素插入到正确的位置来保证链表的有序性。 123456789101112131415161718192021222324252627282930313233343536const Compare = &#123; LESS_THAN: -1, BIGGER_THAN: 1 &#125;; function defaultCompare(a, b) &#123; if (a === b) &#123; // &#123;1&#125; return 0; &#125; return a &lt; b ? Compare.LESS_THAN : Compare.BIGGER_THAN; // &#123;2&#125; &#125; class SortedLinkedList extends LinkedList &#123; constructor(equalsFn = defaultEquals, compareFn = defaultCompare) &#123; super(equalsFn); this.compareFn = compareFn; // &#123;3&#125; &#125; // 有序插入元素 insert(element, index = 0) &#123; // &#123;1&#125; if (this.isEmpty()) &#123; return super.insert(element, 0); // &#123;2&#125; &#125; const pos = this.getIndexNextSortedElement(element); // &#123;3&#125; return super.insert(element, pos); // &#123;4&#125; &#125; getIndexNextSortedElement(element) &#123; let current = this.head; let i = 0; for (; i &lt; this.size() &amp;&amp; current; i++) &#123; const comp = this.compareFn(element, current.element); // &#123;5&#125; if (comp === Compare.LESS_THAN) &#123; // &#123;6&#125; return i; &#125; current = current.next; &#125; return i; // &#123;7&#125; &#125;&#125; 创建 StackLinkedList 类1234567891011121314class StackLinkedList &#123; constructor() &#123; this.items = new DoublyLinkedList(); // &#123;1&#125; &#125; push(element) &#123; this.items.push(element); // &#123;2&#125; &#125; pop() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items.removeAt(this.size() - 1); // &#123;3&#125; &#125; &#125;","categories":[],"tags":[]},{"title":"js中apply怎么把数组转化为参数？","slug":"32-apply-array-to-params","date":"2022-09-21T09:07:53.000Z","updated":"2023-08-03T03:02:58.640Z","comments":true,"path":"2022/09/21/32-apply-array-to-params/","link":"","permalink":"https://sunjinkang.github.io/2022/09/21/32-apply-array-to-params/","excerpt":"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组12345678910111213141516171819202122232425262728293031323334function test(a, b) &#123; console.log(a); console.log(b);&#125;const array = [1, 10];test(array);// [1, 10]// undefinedtest.apply(null, array);// 1// 10var test = &#123; func: function (a, b) &#123; console.log(a); console.log(b); &#125;&#125;const array = [1, 10];test.func(array);// [1, 10]// undefinedtest.func.apply(test.func, array);test.func.apply(null, array);// 1// 10const array = [1, 2, 4, 6, 2, 8];Math.max(array);// NaNconst array = [1, 2, 4, 6, 2, 8];Math.max.apply(null, array);// 8","text":"apply可以改变函数的this指向（类似的还有call和bind），且函数的输入参数需要是一个数组12345678910111213141516171819202122232425262728293031323334function test(a, b) &#123; console.log(a); console.log(b);&#125;const array = [1, 10];test(array);// [1, 10]// undefinedtest.apply(null, array);// 1// 10var test = &#123; func: function (a, b) &#123; console.log(a); console.log(b); &#125;&#125;const array = [1, 10];test.func(array);// [1, 10]// undefinedtest.func.apply(test.func, array);test.func.apply(null, array);// 1// 10const array = [1, 2, 4, 6, 2, 8];Math.max(array);// NaNconst array = [1, 2, 4, 6, 2, 8];Math.max.apply(null, array);// 8 ES6中的扩展符1234567891011121314151617181920212223function test(a, b) &#123; console.log(a); console.log(b);&#125;const array = [1, 10];test(...array);// 1// 10var test = &#123; func: function (a, b) &#123; console.log(a); console.log(b); &#125;&#125;const array = [1, 10];test.func(...array);// 1// 10const array = [1, 2, 4, 6, 2, 8];Math.max(...array);// 8 使用arguments对象（不建议使用）函数内的arguments对象，其本身是由给函数传入的参数，以类似数组的形式组合而成的对象。 123456789function test() &#123; for (let i = 0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125;test(1,12,5);// 1 12 5test(1,12,3,4,5);// 1 12 3 4 5","categories":[],"tags":[]},{"title":"数据结构与算法阅读笔记(1)","slug":"33-data-structure1","date":"2022-09-20T09:41:00.000Z","updated":"2023-08-03T03:03:06.411Z","comments":true,"path":"2022/09/20/33-data-structure1/","link":"","permalink":"https://sunjinkang.github.io/2022/09/20/33-data-structure1/","excerpt":"ECMAScript 和 javascript 的关系ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。 ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别 (1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称) (2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6)","text":"ECMAScript 和 javascript 的关系ECMAScript 是一个语言标准，JavaScript 是该标准(最流行)的一个实现。 ES5、ES6、ES2015、ES7、ES2016、ES8、ES2017 和 ES.Next 的区别 (1)2009 年 12 月发布的 ECMAScript5(即 ES5，其中的 ES 是 ECMAScript 的简称) (2)ECMAScript2015(ES2015)在 2015 年 6 月标准化。负责起草 ECMAScript 规范的委员会决定把定义新标准的模式改为每年更新一次，新的特性一旦通过就加入标准。因此，ECMAScript 第六版更名为 ECMAScript2015(ES6) (3)2016 年 6 月，ECMAScript 第七版被标准化，称为 ECMAScript2016 或 ES2016(ES7) (4)2017 年 6 月，ECMAScript 第八版被标准化。我们称它为 ECMAScript2017 或 ES2017(ES8) (5)ES.Next 用来指代下一个版本的 ECMAScript ES6 兼容性：http://kangax.github.io/compat-table/es6/ES7 兼容性：http://kangax.github.io/compat-table/es2016plus/ ES5 中 class 类，使用属性存取器(1)声明 get 和 set 函数，只需要在我们要暴露和使用的函数名前面加上 get 或 set 关键字(2)可以用相同的名字声明类属性，或者在属性名前面加下划线，让这个属性看起来像是私有的 12345678910111213141516171819class Person &#123; constructor(name) &#123; this._name = name; // &#123;1&#125; &#125; get name() &#123; // &#123;2&#125; return this._name; &#125; set name(value) &#123; // &#123;3&#125; this._name = value; &#125;&#125;let lotrChar = new Person(&#x27;Frodo&#x27;);console.log(lotrChar.name); // &#123;4&#125; // FrodolotrChar.name = &#x27;Gandalf&#x27;; // &#123;5&#125;console.log(lotrChar.name); // GandalflotrChar._name = &#x27;Sam&#x27;; // &#123;6&#125;console.log(lotrChar.name); // Sam 乘方运算符 1234const area = 3.14 * r * r;const area = 3.14 * Math.pow(r, 2);// ES2016 中引入了**运算符，用来进行指数运算const area = 3.14 * r ** 2; JavaScript 和 ECMAScript 的完整功能列表 TypeScriptTypeScript 有一个名为鸭子类型的概念：如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样叫，那么它一定是一只鸭子.(1)接口 12345678910111213141516171819202122// 第一种定义接口的方式interface Person &#123; name: string; age: number;&#125;function printName(person: Person) &#123; console.log(person.name);&#125;/** 第二种定义接口的方式：Comparable 接口告诉 MyObject 类，它需要实现一个叫作 compareTo 的方法，并且该方法接收一个参数。在该方法内部，我们可以实现需要的逻辑。**/interface Comparable &#123; compareTo(b): number;&#125;class MyObject implements Comparable &#123; age: number; compareTo(b): number &#123; if (this.age === b.age) &#123; return 0; &#125; return this.age &gt; b.age ? 1 : -1; &#125;&#125; JavaScript 中使用一些类型和错误检测功能方式：在计算机上全局安装 TypeScript，使用时，只需要在 JavaScript 文件的第一行添加一句 // @ts-check 数组数组是最简单的内存数据结构。JavaScript 里也有数组类型，但它的第一个版本并没有支持数组 (1)使用@@iterator 对象ES2015 为 Array 类增加了一个@@iterator 属性，需要通过 Symbol.iterator 来访问 1234567891011121314151617const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];let iterator = numbers[Symbol.iterator]();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3console.log(iterator.next().value); // 4console.log(iterator.next().value); // 5const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];iterator = numbers[Symbol.iterator]();for (const n of iterator) &#123; console.log(n);&#125;// 复制已有数组let numbers2 = Array.from(numbers);let numbers3 = Array.of(...numbers); (2)copyWithincopyWithin 方法复制数组中的一系列元素到同一数组指定的起始位置 1234copyArray = [1, 2, 3, 4, 5, 6];copyArray.copyWithin(1, 3, 5);// copyWithin(起始位置，开始位置，结束位置)// [1, 4, 5, 4, 5, 6] (3)排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 自定义排序const friends = [ &#123; name: &#x27;John&#x27;, age: 30 &#125;, &#123; name: &#x27;Ana&#x27;, age: 20 &#125;, &#123; name: &#x27;Chris&#x27;, age: 25 &#125;, // ES2017 允许存在尾逗号];function comparePerson(a, b) &#123; if (a.age &lt; b.age) &#123; return -1; &#125; if (a.age &gt; b.age) &#123; return 1; &#125; return 0;&#125;console.log(friends.sort(comparePerson));/**[ &#123; name: &#x27;Ana&#x27;, age: 20 &#125;, &#123; name: &#x27;Chris&#x27;, age: 25 &#125;, &#123; name: &#x27;John&#x27;, age: 30 &#125;, ]*/// 忽略大小写的比较const names = [&#x27;Ana&#x27;, &#x27;ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;]; // 重置数组的初始状态console.log( names.sort((a, b) =&gt; &#123; if (a.toLowerCase() &lt; b.toLowerCase()) &#123; return -1; &#125; if (a.toLowerCase() &gt; b.toLowerCase()) &#123; return 1; &#125; return 0; &#125;));// 希望小写字母排在前面或者对带有重音符号的字符做排序的话，那么需要使用 localeCompare 方法const names = [&#x27;Ana&#x27;, &#x27;ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;];names.sort((a, b) =&gt; a.localeCompare(b));// [&#x27;ana&#x27;, &#x27;Ana&#x27;, &#x27;john&#x27;, &#x27;John&#x27;]const names2 = [&#x27;Maève&#x27;, &#x27;Maeve&#x27;];console.log(names2.sort((a, b) =&gt; a.localeCompare(b)));// [&quot;Maeve&quot;, &quot;Maève&quot;] 类型数组 类型数组 数据类型 Int8Array 8 位二进制补码整数 Uint8Array 8 位无符号整数 Uint8ClampedArray 8 位无符号整数 Int16Array 16 位二进制补码整数 Uint16Array 16 位无符号整数 Int32Array 32 位二进制补码整数 Uint32Array 32 位无符号整数 Float32Array 32 位 IEEE 浮点数 Float64Array 64 位 IEEE 浮点数 12345678let length = 5;let int16 = new Int16Array(length);let array16 = [];array16.length = length;for (let i = 0; i &lt; length; i++) &#123; int16[i] = i + 1;&#125;console.log(int16); 类型数组作用：WebGL API、位操作、处理文件和图像 类型数组文档 栈栈是一种遵从后进先出（LIFO）原则的有序集合。新添加或待删除的元素都保存在栈的同一端，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底 栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮） (1)创建一个基于数组的栈 1234567891011121314151617181920212223242526272829class Stack &#123; constructor() &#123; this.items = []; &#125; // 添加一个（或几个）新元素到栈顶 push(element) &#123; this.items.push(element); &#125; // 移除栈顶的元素，同时返回被移除的元素 pop() &#123; return this.items.pop(); &#125; // 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它） peek() &#123; return this.items[this.items.length - 1]; &#125; // 如果栈里没有任何元素就返回 true，否则返回 false isEmpty() &#123; return this.items.length === 0; &#125; // 返回栈里的元素个数。该方法和数组的 length 属性很类似 size() &#123; return this.items.length; &#125; // 移除栈里的所有元素 clear() &#123; this.items = []; &#125;&#125; 在使用数组时，大部分方法的时间复杂度是 O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的 n 代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。(2)创建一个基于 JavaScript 对象的 Stack 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Stack &#123; constructor() &#123; this.count = 0; // count 属性记录栈的大小,也能帮助我们从数据结构中添加和删除元素 this.items = &#123;&#125;; &#125; // 向栈中插入元素,只允许一次插入一个元素 push(element) &#123; this.items[this.count] = element; this.count++; &#125; // 验证一个栈的大小 size() &#123; return this.count; &#125; // 获取栈是否为空 isEmpty() &#123; return this.count === 0; &#125; // 从栈中弹出元素 pop() &#123; if (this.isEmpty()) &#123; return undefined; &#125; this.count--; const result = this.items[this.count]; delete this.items[this.count]; return result; &#125; // 查看栈顶的值 peek() &#123; if (this.isEmpty()) &#123; return undefined; &#125; return this.items[this.count - 1]; &#125; // 清空栈 clear() &#123; this.items = &#123;&#125;; this.count = 0; // while (!this.isEmpty()) &#123; // this.pop(); // &#125; &#125; toString() &#123; if (this.isEmpty()) &#123; return &#x27;&#x27;; &#125; let objString = `$&#123;this.items[0]&#125;`; // &#123;1&#125; for (let i = 1; i &lt; this.count; i++) &#123; // &#123;2&#125; objString = `$&#123;objString&#125;,$&#123;this.items[i]&#125;`; // &#123;3&#125; &#125; return objString; &#125;&#125; javascript 实现私有属性的方法下划线命名约定 1234567// 中使用下划线命名约定来标记一个属性为私有属性class Stack &#123; constructor() &#123; this._count = 0; this._items = &#123;&#125;; &#125;&#125; 下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识 用 ES2015 的限定作用域 Symbol 实现类 1234567891011121314151617const _items = Symbol(&#x27;stackItems&#x27;);class Stack &#123; constructor() &#123; this[_items] = []; &#125; // 栈的方法&#125;const stack = new Stack();stack.push(5);stack.push(8);let objectSymbols = Object.getOwnPropertySymbols(stack);console.log(objectSymbols.length); // 输出 1console.log(objectSymbols); // [Symbol()]console.log(objectSymbols[0]); // Symbol()stack[objectSymbols[0]].push(1);stack.print(); // 输出 5, 8, 1 访问 stack[objectSymbols[0]]得到_items,并且，_items 属性是一个数组，可以进行任意的数组操作，不符合栈的要求 用 ES2015 的 WeakMap 实现类WeakMap 可以存储键值对，其中键是对象，值可以是任意数据类型 12345678910111213141516const items = new WeakMap(); // &#123;1&#125;class Stack &#123; constructor() &#123; items.set(this, []); // &#123;2&#125; &#125; push(element) &#123; const s = items.get(this); // &#123;3&#125; s.push(element); &#125; pop() &#123; const s = items.get(this); const r = s.pop(); return r; &#125; // 其他方法&#125; 代码的可读性不强，而且在扩展该类时无法继承私有属性 ECMAScript 类属性提案 12345class Stack &#123; #count = 0; #items = 0; // 栈的方法&#125; 从十进制转二进制 123456789101112131415function decimalToBinary(decNumber) &#123; const remStack = new Stack(); let number = decNumber; let rem; let binaryString = &#x27;&#x27;; while (number &gt; 0) &#123; rem = Math.floor(number % 2); remStack.push(rem); number = Math.floor(number / 2); &#125; while (!remStack.isEmpty()) &#123; binaryString += remStack.pop().toString(); &#125; return binaryString;&#125; 进制转换算法 12345678910111213141516171819function baseConverter(decNumber, base) &#123; const remStack = new Stack(); const digits = &#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;; // &#123;6&#125; let number = decNumber; let rem; let baseString = &#x27;&#x27;; if (!(base &gt;= 2 &amp;&amp; base &lt;= 36)) &#123; return &#x27;&#x27;; &#125; while (number &gt; 0) &#123; rem = Math.floor(number % base); remStack.push(rem); number = Math.floor(number / base); &#125; while (!remStack.isEmpty()) &#123; baseString += digits[remStack.pop()]; // &#123;7&#125; &#125; return baseString;&#125;","categories":[],"tags":[]},{"title":"JavaScript设计模式读书笔记(6)","slug":"28-about-design-model5","date":"2022-09-20T07:22:12.000Z","updated":"2023-08-03T03:02:21.988Z","comments":true,"path":"2022/09/20/28-about-design-model5/","link":"","permalink":"https://sunjinkang.github.io/2022/09/20/28-about-design-model5/","excerpt":"架构型设计模式架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。 同步模块模式模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。","text":"架构型设计模式架构型设计模式是一类框架结构,通过提供一些子系统，指定他们的职责,并将它们条理清晰地组织在一起。 同步模块模式模块化:将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可拓展，提高模块的复用率。同步模块模式——SMD (Synchronous Module Definition):请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。 (1)实现模块化开发，首先要有一个模块管理器，它管理着模块的创建与调度。对于模块的调用分为两类，第一类同步模块调度的实现比较简单，不需要考虑模块间的异步加载。第二类异步模块调度的实现就比较繁琐。它可实现对模块的加载调度。 异步模块模式异步模块模式——AMD (Asynchronous Module Definition):请求发出后，继续其他业务逻辑，知道模块加载完成执行后续的逻辑，实现模块开发中对模块加载完成后的引用。 Widget模式Widget:(Web Widget指的是一块可以在任意页面中执行的代码块)Widget模式是指借用Web Widget思想将页面分解成部件，针对部件开发，最终组合成完整的页面。 MVC模式MVC即模型(model)一视图(view)一控制器(controller)，用一种将业务逻辑、数据、视图分离的方式组织架构代码。 每个对象是一个自动执行的函数3个层次对象可被调用，而声明的函数在执行前是不能被调用的，比如模型对象要被视图和控制器调用，因此执行一遍为其他对象调用提供接口方法 视图层只有3个部分，一是操作模型数据对象方法的引用(M),二是内部视图创建方法对象，三是外部获取视图创建方法接口 MVP模式MVP即模型(Model)一视图(View)一管理器(Presenter): View层不直接引用Model层内的数据，而是通过Presenter层实现对Model层内的数据访问。即所有层次的交互都发生在Presenter层中。 MVP与MVC相比最重要的特征就是MVP中将视图层与数据层完全解耦，使得对视图层的修改不会影响到数据层，数据层内的数据改动又不会影响到视图层。因此，我们在管理器中对数据或者视图灵活地调用就可使数据层内的数据与视图层内的视图得到更高效的复用。因此，MVP模式也可以实现一个管理器，可以调用多个数据，或者创建多种视图，而且是不受限制的。因而管理器有更高的操作权限，因此对于业务逻辑与需求的实现只需专注于管理器的开发即可，当然管理器内过多的逻辑也使得其开发与维护成本提高。 MVVM模式MVVM模式，模型(Model)-视图(View)-视图模型(ViewModel):为视图层(View)量身定做一套视图模型(ViewModel)，并在视图模型(ViewModel)中创建属性和方法，为视图层(View)绑定数据(Model)并实现交互。 附录 疑问点：(1)为什么要缓存Array的slice方法？slice = Array.prototype.slice编程方式区分，不要糅合在一起对性能影响可以忽略不计 (2)有一些模式很像，一定需要做区分吗？从实际场景触发，贴合场景选择设计模式设计模式一定要符合当下场景，在此基础上考虑一些将来的扩展，如果未来不符合要求了，优先考虑修改涉及模式以解决当前场景问题 (3)柯理化函数；接受多个参数（一个参数没必要用柯理化）；将接受多个参数的函数变成 接受一个参数 的函数（函数嵌套），每个函数返回一个新函数并接受一个新的参数，直到最后返回计算结果调用方式不一样。普通函数：函数名(参数1, 参数2, …); 柯理化：函数名(参数1)(参数2)… 对函数式编程用处比较大，也可以选择不使用柯理化，使用其他方法解决","categories":[],"tags":[]},{"title":"JavaScript设计模式读书笔记(5)","slug":"27-about-design-model4","date":"2022-09-19T09:51:10.000Z","updated":"2023-08-03T03:02:14.866Z","comments":true,"path":"2022/09/19/27-about-design-model4/","link":"","permalink":"https://sunjinkang.github.io/2022/09/19/27-about-design-model4/","excerpt":"技巧型设计模式技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。 链模式链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。","text":"技巧型设计模式技巧型设计模式是通过一些特定技巧来解决组件的某些方面的问题，这类技巧一般通过实践经验总结得到。 链模式链模式(Operate of Responsibility):通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。 jOuery获取的元素更像一个数组，上面框架返回的更像是一个对象原因：由于JavaScript 的弱类型语言，并且数组、对象、函数都被看成是对象的实例，所以JavaScript中并没有一个纯粹的数组类型。而且JavaScript引擎的实现也没有做严格的校验，也是基于对象实现的。一些浏览器解析引擎在判断对象是否是数组的时候不仅仅判断其有没有length 属性，可否通过‘![索引值]’方式访问元素，还会判断其是否具有数组方法来确定是否要用数组的形式展现，所以只需要在 A.fn中添加几个数组常用的方法来增强数组特性就可以解决问题了 委托模式委托模式(Entrust):多个对象接收并处理同一请求，他们将请求委托给另一个对象统一处理请求。 委托模式可以优化页面中事件的数量。 事件委托是将子元素的事件委托给父元素，然后通过事件冒泡传递的，再通过判断事件源的某种特性来执行某一业务逻辑 数据访问对象模式数据访问对象模式(Data access object-DAO):抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。 节流模式节流模式(Throttler):对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。 节流模式的核心思想是创建计时器，延迟程序的执行。这也使得计时器中回调函数的操作异步执行(这里的异步执行并不是说JavaScript是多线程语言，JavaScript 从设计之初就是单线程语言，异步只是说脱离原来程序执行的顺序,看上去，异步程序像是在同时执行。但是某一时刻，当前执行的程序一定是所有异步程序(包括原程序)中的某一个)。 节流模式优势(1)第一，程序能否执行是可控的。执行前的某一时刻是否清除计时器来决定程序是否可以继续执行(2)第二，程序是异步的。由于计时器机制，使得程序脱离原程序而异步执行(当然随着worker技术的兴起，也可开启多线程模式实现)，因此不会影响后面的程序的正常执行。在其他方面，比如对异步请求(ajax)应用节流，此时可以优化请求次数来节省资源。 简单模板模式简单模板模式(Simple template):通过格式化字符串拼凑出视图避免创建视图时大量节点操作。优化内存开销。 惰性模式惰性模式(layier):减少每次代码执行时的重复性的分支判断，通过对对象重定义来屏蔽原对象中的分支判断。 两种实现方式(1)第一种就是在文件加载进来时通过闭包执行该方法对其重新定义。不过这样会使页面加载时占用一定资源。(2)第二种方式是在第一种方式基础上做一次延迟执行，在函数第一次调用的时候对其重定义。这么做的好处就是减少文件加载时的资源消耗，但是却在第一次执行时有一定的资源消耗 参与者模式参与者(participator):在特定的作用域中执行给定的函数，并将参数原封不动地传递。 函数柯里化的思想是对函数的参数分割，这有点像其他面向语言中的类的多态，就是根据传递的参数不同，可以让一个函数存在多种状态，只不过函数柯里化处理的是函数，因此要实现函数的柯里化是要以函数为基础的，借助柯里化器伪造其他函数，让这些伪造的函数在执行时调用这个基函数完成不同的功能 参与者模式实质上是两种技术的结晶，函数绑定和函数柯里化(1)对于函数绑定，它将函数以函数指针(函数名)的形式传递，使函数在被绑定的对象作用域中执行，因此函数的执行中可以顺利地访问到对象内部的数据，由于函数绑定构造复杂，执行时需消耗更多的内存，因此执行速度上要稍慢一些。不过相对于解决的问题来说这种消耗还是值得的，因此它常用于事件，setTimeout或setInterval等异步逻辑中的回调函数。(2)对于函数柯里化即是将接受多个参数的函数转化为接受一部分参数的新函数,余下的参数保存下来，当函数调用时，返回传入的参数与保存的参数共同执行的结果。通常保存下来的参数保存于闭包内,因此函数柯里化的实现要消耗一定的资源。函数的柯里化有点类似类的重载,不同点是类的重载是同一个类对象,函数的柯里化是两个不同的函数。 随着函数柯里化的发展，现在又衍生出一种反柯里化的函数，其目的是方便我们对方法的调用 等待者模式等待者模式(waiter):通过对多个异步进程监听，来触发未来发生的动作。","categories":[],"tags":[]},{"title":"JavaScript设计模式读书笔记(4)","slug":"26-about-design-model3","date":"2022-09-07T09:40:43.000Z","updated":"2023-08-03T03:02:06.784Z","comments":true,"path":"2022/09/07/26-about-design-model3/","link":"","permalink":"https://sunjinkang.github.io/2022/09/07/26-about-design-model3/","excerpt":"行为型设计模式行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现 模板方法模式模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。 多用于归一化组件","text":"行为型设计模式行为型设计模式用于不同对象之间职责划分或算法抽象，行为型设计模式不仅仅涉及类和对象,还涉及类或对象之间的交流模式并加以实现 模板方法模式模板方法模式(Template Method):父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。 多用于归一化组件 观察者模式观察者模式(Observer):又被称作发布-订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。 观察者对象包含：一个消息容器，订阅消息方法、取消订阅的消息方法、发送订阅的消息方法 状态模式状态模式(State):当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。 状态模式简化了分支判断遍历逻辑 示例思路：首先创建一个状态对象，内部保存状态变量，然后内部封装好每种,动作对应的状态，最后状态对象返回一个接口对象，它可以对内部的状态修改或者调用 策略模式策略模式(Strategy):将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化。 与状态模式异同点相同点：结构上与状态模式很像，也是在内部封装一个对象，然后通过返回的接口对象实现对内部对象的调用不同点：策略模式不需要管理状态、状态间没有依赖关系、策略之间可以相互替换、在策略对象内部保存的是相互独立的一些算法 策略模式的优点第一，策略模式封装了一组代码簇，并且封装的代码相互之间独立，便于对算法的重复引用，提高了算法的复用率。第二，策略模式与继承相比，在类的继承中继承的方法是被封装在类中，因此当需求很多算法时，就不得不创建出多种类，这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化，并且在类的外部改变类的算法难度也是极大的。第三，同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法封装使得算法更利于维护。 策略模式的缺点由于选择哪种算法的决定权在用户，所以对用户来说就必须了解每种算法的实现,增加了用户对策略对象的使用成本。由于每种算法间相互独立，这样对于一些复杂的算法处理相同逻辑的部分无法实现共享，这就会造成一些资源的浪费 优化分支语句的模式工厂方法模式，状态模式与策略模式工厂方法模式：一种创建型模式，最终目的是创建对象。状态模式是行为型模式，不过在状态模式中，其核心是对状态的控制来决定表现行为，所以状态之间通常是不能相互替代的，否则将产生不同的行为结果。策略模式是行为型模式，核心是算法，由于每种算法要处理的业务逻辑相同，因此他们可以相互替换，当然策略模式并不关心使用者环境，因为同一种策略模式最终产出的结果是一定的。 职责链模式职责链模式(Chain of Responsibility):解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。 示例 缺点职责链上的每一个对象不一定都能参与请求的传递，有时会造成一丝资源的浪费多个对象参与请求的传递，在代码调试时增加了调试成本 命令模式命令模式(Command):将请求与实现解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。命令模式常用于解耦 命令模式的优点:解决命令使用者之间的耦合。新的命令很容易加入到命令系统中，供使用者使用。命令的使用具有一致性，多数的命令在一定程度上是简化操作方法的使用的。 命令模式的缺点:命令模式是对一些操作的封装，这就造成每执行一次操作都要调用一次命令对象，增加了系统的复杂度。 访问者模式访问者模式(Visitor):针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。 中介者模式中介者模式(Mediator):通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可改变对象之间的交互。 (1)观察者模式与中介者模式的区别相同点都是通过消息的收发机制实现的差异点在观察者模式中，一个对象既可以是消息的发送者也可以是消息的接收者，他们之间信息交流依托于消息系统实现的解耦,需要写一个消息系统中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象(订阅者)才可订阅中介者的消息，当然你也可以看作是将消息系统封装在中介者对象内部，所以中介者对象只能是消息的发送者 备忘录模式备忘录模式(Memento):在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。 迭代器模式迭代器模式(Iterator):在不暴露对象内部结构的同时，可以顺序地访问聚合对象内部的元素。 解释器模式解释器模式(Interpreter):对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。 解释器即是对客户提出的需求，经过解析而形成的一个抽象解释程序。而是否可以应用解释器模式的一条重要准侧是能否根据需求解析出一套完成的语法规则,不论该语法规则简单或是复杂都是必须的。因为解释器要按照这套规则才能实现相应的功能。","categories":[],"tags":[]},{"title":"JavaScript设计模式读书笔记(3)","slug":"25-about-design-model2","date":"2022-09-06T07:11:48.000Z","updated":"2023-08-03T03:02:00.842Z","comments":true,"path":"2022/09/06/25-about-design-model2/","link":"","permalink":"https://sunjinkang.github.io/2022/09/06/25-about-design-model2/","excerpt":"结构型设计模式结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计 外观模式外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用","text":"结构型设计模式结构型设计模式关注于如何将类或对象组合成更大、更复杂的结构，以简化设计 外观模式外观模式(Facade):为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易。在JavaScript中有时也会用于对底层结构兼容性做统一封装来简化用户使用 多用于兼容模式 适配器模式适配器模式(Adapter):将一个类(对象)的接口(方法或者属性)转化成另外一个接口,以满足用户需求，使类(对象)之间接口的不兼容问题通过适配器得以解决 (1)适配异类框架(2)参数适配器：通常是以一个参数对象方式传入(3)数据适配比如一个数组，每个元素代表不同意义，数据结构语义不好，将其适配为一个对象等(4)服务端数据适配获取接口的数据，先做一个适配，再使用统一的处理方法 代理模式代理模式(Proxy):由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用 代理对象(1)img之类的标签通过src属性可以向其他域下的服务器发送请求缺点：请求是get请求，且是单向的，不会有响应数据示例：站长统计 (2)JSONP通过script标签需要其他域下的服务端配合前端做出针对处理 (3)代理模板不同域之间相互调用对方的页面是有限制的，那么自己域中的两个页面相互之间的调用是可以的，即代理页面B调用被代理的页面A中对象的方式是可以的。那么要实现这种方式我们只需要在被访问的域中，请求返回的Header重定向到代理页面，并在代理页面中处理被代理的页面A 装修者模式装饰者模式(Decorator):在不改变原对象的基础上，通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户的更复杂需求 适配器与装修者的区别适配器方法是对原有对象适配，添加的方法与原有方法功能上大致相似；使用适配器时新增的方法是要调用原来的方法，要了解原有方法实现的具体细节装饰者提供的方法与原来的方法功能项是有一定区别的；不需要了解对象原有的功能，并且对象原有的方法照样可以原封不动地使用 桥接模式桥接模式(Bridge):在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦 先抽象提取共用部分，然后将实现与抽象通过桥接方法链接在一起，来实现解耦的作用 桥接模式最主要的特点即是将实现层(如元素绑定的事件)与抽象层(如修饰页面UI逻辑)解耦分离，使两部分可以独立变化 组合模式组合模式(Composite):又称部分-整体模式，将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 组合模式常用语创建表单。 享元模式享元模式(Flyweight):运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。 享元模式主要还是对其数据、方法共享分离，它将数据和方法分成内部数据、内部方法和外部数据、外部方法。内部方法与内部数据指的是相似或者共有的数据和方法,所以将这一部分提取出来减少开销，以提高性能。 在一些小程序中，性能与内存的消耗对程序的执行影响不大时，强行应用享元模式而引入复杂的代码逻辑,往往会收到负效应。","categories":[],"tags":[]},{"title":"Object获取及设置原型对象","slug":"31-get-and-set-prototypeof","date":"2022-09-05T05:54:58.000Z","updated":"2023-08-03T03:02:42.930Z","comments":true,"path":"2022/09/05/31-get-and-set-prototypeof/","link":"","permalink":"https://sunjinkang.github.io/2022/09/05/31-get-and-set-prototypeof/","excerpt":"Object获取原型对象：Object.getPrototypeOfObject.getPrototypeOf用于获取指定对象的原型对象 1Object.getPrototypeOf(obj); 参数obj: 参数为要获取原型对象的对象返回值返回指定对象的原型对象或null注意：es5中，如果参数不是对象，会抛出TypeError错误es6中，如果参数不是对象，会强制类型转换为对象","text":"Object获取原型对象：Object.getPrototypeOfObject.getPrototypeOf用于获取指定对象的原型对象 1Object.getPrototypeOf(obj); 参数obj: 参数为要获取原型对象的对象返回值返回指定对象的原型对象或null注意：es5中，如果参数不是对象，会抛出TypeError错误es6中，如果参数不是对象，会强制类型转换为对象 示例 12345678910111213141516171819console.log(Object.getPrototypeOf(&#x27;12&#x27;) === String.prototype); // true// console.log(Object.getPrototypeOf(12) === Number.prototype); // true//console.log(Object.getPrototypeOf(&#123;&#125;) === Object.prototype); // true// console.log(Object.getPrototypeOf(true) === Boolean.prototype); // true// console.log(Object.getPrototypeOf(Symbol(&#x27;test&#x27;)) === Symbol.prototype); // true// console.log(Object.getPrototypeOf(null)); // Uncaught TypeError: Cannot convert undefined or null to object// console.log(Object.getPrototypeOf(undefined)); // Uncaught TypeError: Cannot convert undefined or null to object// 对没有原型对象的对象进行操作const obj = Object.create(null);console.log(Object.getPrototypeOf(obj)); // nullconst obj = Object.create(undefined);console.log(Object.getPrototypeOf(obj)); // Uncaught TypeError: Object prototype may only be an Object or null: undefined Object修改原型对象: Object.setPrototypeOfObject.setPrototypeOf用于将指定对象的原型对象设置到一个新的对象或null上 1Object.setPrototypeOf(obj, proto); 参数obj: 要设置原型对象的对象proto: 要设置的新原型对象或null，未设置时抛出TypeError错误 返回值设置了新原型对象的对象 注意：该操作实际上是个很耗时的操作，如果对性能有更高的要求，不建议直接修改已有对象的原型，而应该通过Object.create()方法来创建一个新的对象 示例 123456789101112const obj = &#123; name: &#x27;test&#x27; &#125;;const newObj = Object.create(obj);Object.setPrototypeOf(newObj, obj);console.log(newObj.name); // &#x27;test&#x27;const otherObj = &#123; age: 12&#125;;console.log(Object.getPrototypeOf(newObj) === obj); // trueObject.setPrototypeOf(newObj, otherObj);console.log(Object.getPrototypeOf(newObj) === obj); // falseconsole.log(Object.getPrototypeOf(newObj) === otherObj); // trueconsole.log(newObj.name); // undefinedconsole.log(newObj.age); // 12","categories":[],"tags":[]},{"title":"开发中使用的便捷代码","slug":"30-some-convenient-code","date":"2022-09-05T05:24:10.000Z","updated":"2023-08-03T03:02:34.325Z","comments":true,"path":"2022/09/05/30-some-convenient-code/","link":"","permalink":"https://sunjinkang.github.io/2022/09/05/30-some-convenient-code/","excerpt":"基于条件设置对象属性12345678// 空值const name = &#x27;&#x27;;const obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;console.log(obj); // &#123;&#125;// 非空值const name = &#x27;test_name&#x27;;const obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;console.log(obj); // &#123; name: &#x27;test_name&#x27;&#125;","text":"基于条件设置对象属性12345678// 空值const name = &#x27;&#x27;;const obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;console.log(obj); // &#123;&#125;// 非空值const name = &#x27;test_name&#x27;;const obj = &#123; ...name &amp;&amp; &#123;name&#125;&#125;;console.log(obj); // &#123; name: &#x27;test_name&#x27;&#125; 无中间变量交换变量值12345let one = &#x27;12&#x27;;let two = &#x27;34&#x27;;[one, two] = [two, one];console.log(one); // &#x27;34&#x27;console.log(two); // &#x27;12&#x27; 过滤Boolean值为false的值123const array = [0, false, 12, true, &#x27;12&#x27;, undefined, &#x27;&#x27;, 8, null];const result = array.filter(Boolean);console.log(result); // [12, true, &#x27;12&#x27;, 8] 转换元素类型123456// 将Number类型转换为Stringconst string = [1, 2, 3, 12].map(String);console.log(string); // [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;12&#x27;]// 将String类型转换为Numberconst string = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;12&#x27;].map(Number);console.log(string); // [1, 2, 3, 12] 数组去重123const repeatArray = [1,1,1,3,5,6,7,8,9,23,45,1,2,3,5,6];const result = [...new Set(repeatArray)];console.log(result); // [1, 3, 5, 6, 7, 8, 9, 23, 45, 2]","categories":[],"tags":[]},{"title":"JavaScript设计模式读书笔记(2)","slug":"24-about-design-model1","date":"2022-09-04T13:29:09.000Z","updated":"2023-08-03T03:01:51.873Z","comments":true,"path":"2022/09/04/24-about-design-model1/","link":"","permalink":"https://sunjinkang.github.io/2022/09/04/24-about-design-model1/","excerpt":"创建型设计模式创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度 简单工厂模式(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。","text":"创建型设计模式创建型设计模式是一类处理对象创建的设计模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度 简单工厂模式(1)简单工厂模式(Simple Factory):又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。 (2)一个对象有时也可代替许多类 第一种是通过类实例化对象创建的，第二种是通过创建一个新对象然后包装增强其属性和功能来实现的。他们之间的差异性也造成前面通过类创建的对象,如果这些类继承同一父类，那么他们的父类原型上的方法是可以共用的。而后面寄生方式创建的对象都是一个新的个体，所以他们的方法就不能共用了 工厂方法模式安全模式类：可以屏蔽使用这对类的错误使用造成的错误 抽象工厂模式抽象工厂模式(Abstract Factory):通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例 (1)抽象类抽象类是一种声明但不能使用的类创建的这个car类其实什么都不能做，创建时没有任何属性，然而原型prototype上的方法也不能使用，否则会报错。但在继承上却是很有用的，因为定义了一种类,并定义了该类所必备的方法，如果在子类中没有重写这些方法，那么当调用时能找到这些方法便会报错。这一特点是很有必要的，因为在一些大型应用中，总会有一些子类去继承另一些父类，这些父类经常会定义一些必要的方法，却没有具体的实现，如 car类中的 getPrice()和getSpeed()方法，那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现,那么实例化对象便会调用父类中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助的。这也是抽象类的一个作用，即定义一个产品簇，并声明一些必备的方法，如果子类中没有去重写就会抛出错误。 (2)抽象工厂模式：一般用它来作为父类创建一些子类抽象工厂其实是一个实现子类继承父类的方法，在这个方法中需要通过传递子类以及要继承父类(抽象类)的名称，并且在抽象工厂方法中又增加了一次对抽象类存在性的一次判断，如果存在，则将子类继承父类的方法。然后子类通过寄生式继承。继承父类过程中有一个地方需要注意，就是在对过渡类的原型继承时，不是继承父类的原型，而是通过new关键字复制的父类的一个实例，这么做是因为过渡类不应仅仅继承父类的原型方法，还要继承父类的对象属性，所以要通过new关键字将父类的构造函数执行一遍来复制构造函数中的属性和方法。对抽象工厂添加抽象类也很特殊,因为抽象工厂是个方法不需要实例化对象，故只需要一份，因此直接为抽象工厂添加类的属性即可，于是就可以通过点语法在抽象工厂上添加需要的三个汽车簇抽象类Car、Bus、Truck 建造者模式建造者模式(Builder):将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示 工厂模式主要是为了创建对象实例或者类簇(抽象工厂)，关心的是最终产出(创建)的是什么。不关心你创建的整个过程，仅仅需要知道你最终创建的结果。所以通过工厂模式我们得到的都是对象实例或者类簇。建造者模式在创建对象时要更为复杂一些，虽然其目的也是为了创建对象，但是它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节 工厂模式创建出来的是一个对象，它追求的是创建的结果建造者模式不仅仅可得到创建的结果，也参与了创建的具体过程，对于创建的具体实现的细节也参与了干涉，这种模式创建的对象是一个复合对象 注意：这种方式对于整体对象类的拆分无形中增加了结构的复杂性，因此如果对象粒度很小，或者模块间的复用率很低并且变动不大，最好还是创建整体对象 原型模式原型模式(Prototype):用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法 原型模式就是将可复用的、可共享的、耗时大的从基类中提出来然后放在其原型中，然后子类通过组合继承或者寄生组合式继承而将方法和属性继承下来，对于子类中那些需要重写的方法进行重写,这样子类创建的对象既具有子类的属性和方法也共享了基类的原型方法原型模式有一个特点就是在任何时候都可以对基类或者子类进行方法的拓展，而且所有被实例化的对象或者类都能获取这些方法 (1)原型继承原型模式更多的是用在对对象的创建上。比如创建一个实例对象的构造函数比较复杂，或者耗时比较长，或者通过创建多个对象来实现。此时最好不要用new关键字去复制这些基类，但可以通过对这些对象属性或者方法进行复制来实现创建，这是原型模式的最初思想。如果涉及多个对象，也可以通过原型模式来实现对新对象的创建。那么首先要有一个原型模式的对象复制方法 原型对象更适合在创建复杂的对象时，对于那些需求一直在变化而导致对象结构不停地改变时，将那些比较稳定的属性与方法共用而提取的继承的实现 单例模式单例模式(Singleton):又被称为单体模式，是只允许实例化一次的对象类。有时我们也用一个对象来规划一个命名空间，井井有条地管理对象上的属性与方法 (1)命名空间命名空间就是人们所说的namespace，有人也叫它名称空间。它解决这么一类问题:为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所以不同的人定义的变量使用的单词名称很有可能重复，此时就需要用命名空间来约束每个人定义的变量来解决这类问题 (2)静态变量 (3)惰性单例","categories":[],"tags":[]},{"title":"es6对象增强","slug":"29-es6-object-strong","date":"2022-09-02T02:42:05.000Z","updated":"2023-08-03T03:02:28.461Z","comments":true,"path":"2022/09/02/29-es6-object-strong/","link":"","permalink":"https://sunjinkang.github.io/2022/09/02/29-es6-object-strong/","excerpt":"对象字面量语法扩展(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。 12345var name = &#x27;test&#x27;;var obj = &#123; name,&#125;;console.log(obj); // &#123;name: &#x27;test&#x27;&#125;","text":"对象字面量语法扩展(1)属性赋值简写：给一个属性赋变量值时，如果变量和属性的名称相同，可以省略冒号、变量名，直接写属性名即可，js 引擎执行代码时，会自动查找与属性名相同的变量进行属性赋值。 12345var name = &#x27;test&#x27;;var obj = &#123; name,&#125;;console.log(obj); // &#123;name: &#x27;test&#x27;&#125; (2)简化属性方法定义：给一个属性赋匿名函数方法时，可以使用更简洁的方法 1234567891011121314151617181920212223// ES5const es5Obj = &#123; testFunction: function () &#123; console.log(&#x27;es5&#x27;); &#125;,&#125;;console.log(es5Obj.testFunction()); // es5// es6const es6Obj = &#123; testFunction() &#123; console.log(&#x27;es6&#x27;); &#125;,&#125;;console.log(es6Obj.testFunction()); // es6// **注意：只有赋值的是匿名函数，才可以使用简介语法**const es6Obj1 = &#123; testFunction: function Hello() &#123; console.log(&#x27;hello&#x27;); &#125;,&#125;;console.log(es6Obj1.testFunction()); // hello 常见给函数取名字的情况：(1)递归，自己调用自己；(2)debugger 的时候，方便问题定位 (3)计算属性名：属性可以动态生成，需要把动态属性用[]包括起来 12345678910const es6Obj = &#123; [&#x27;first&#x27; + &#x27;second&#x27;]: &#x27;hanmeimei&#x27;,&#125;;console.log(es6Obj[&#x27;first&#x27; + &#x27;second&#x27;]); // hanmeimeiconst first = &#x27;first&#x27;;const es6Obj1 = &#123; [first + &#x27;second&#x27;]: &#x27;hanmeimei&#x27;,&#125;;console.log(es6Obj[first + &#x27;second&#x27;]); // hanmeimei (4)重复属性名的处理：es5 中，给对象赋值，如果存在相同的属性名，会报错；es6 中，不会报错，相同属性名的最后一个，会覆盖之前的属性 12345const es6Obj = &#123; name: &#x27;first&#x27;, name: &#x27;second&#x27;,&#125;;console.log(es6Obj); // &#123;name: &#x27;second&#x27;&#125; 新方法(1)Object.is()作用：判断两个数是否相等，与===基本一致，不过有两点不同：+0 不等于-0；NaN 等于 NaN 123console.log(+0 == -0); // trueconsole.log(Object.is(+0, -0)); // falseconsole.log(Object.is(NaN, NaN)); // true (2)Object.assign()作用：将所有可枚举属性从一个或多个源对象复制到目标对象，并返回目标对象 123456// Object.assign(target, ...sources); target为目标对象 sources为源对象const target = &#123; a: 1, b: 2 &#125;;const source = &#123; b: 4, c: 5 &#125;;const returnedTarget = Object.assign(target, source);console.log(target); // Object &#123; a: 1, b: 4, c: 5 &#125;console.log(returnedTarget); // Object &#123; a: 1, b: 4, c: 5 &#125; (3)Object.setPrototypeOf()作用：设置对象的原型对象，有两个参数，一个是对象，一个是对象要链接到的原型对象 123456789101112131415161718// Object.setPrototypeOf(object, prototypeObject);let person = &#123; greeting() &#123; return &#x27;hello&#x27;; &#125;,&#125;;let dog = &#123; greeting() &#123; return &#x27;woof&#x27;; &#125;,&#125;;let obj = &#123;&#125;;// obj 链接到personObject.setPrototypeOf(obj, person);console.log(obj.greeting()); // hello// obj 链接到dogObject.setPrototypeOf(obj, dog);console.log(obj.greeting()); // woof 当在对象上有某个方法时，会直接调用对象上的方法，不会去原型链上找 12345678910111213141516171819let person = &#123; greeting() &#123; return &#x27;hello&#x27;; &#125;,&#125;;let dog = &#123; greeting() &#123; return &#x27;woof&#x27;; &#125;,&#125;;let obj = &#123; greeting() &#123; return &#x27;obj&#x27;; &#125;,&#125;;Object.setPrototypeOf(obj, person);console.log(obj.greeting()); // objObject.setPrototypeOf(obj, dog);console.log(obj.greeting()); // obj 在obj 对象中定义的方法，可能使用到原型对象上的同名方法， 只要调用原型对象上面的方法再进行一下组装就可以达到要求了。ES6 提供了super 关键词，它就指向原型对象 12345678910111213141516171819let person = &#123; greeting() &#123; return &#x27;hello&#x27;; &#125;,&#125;;let dog = &#123; greeting() &#123; return &#x27;woof&#x27;; &#125;,&#125;;let obj = &#123; greeting() &#123; return super.greeting() + &#x27;obj&#x27;; &#125;,&#125;;Object.setPrototypeOf(obj, person);console.log(obj.greeting()); // helloobjObject.setPrototypeOf(obj, dog);console.log(obj.greeting()); // woofobj 对象方法的定义只能使用简洁的语法形式，否则报错:Uncaught SyntaxError: ‘super’ keyword unexpected here为什么？？ 1234567891011121314151617181920212223242526272829303132333435363738394041let person = &#123; greeting: function() &#123; return &#x27;hello&#x27;; &#125;,&#125;;let dog = &#123; greeting: function() &#123; return &#x27;woof&#x27;; &#125;,&#125;;let obj = &#123; // 以下写法报错：Uncaught SyntaxError: &#x27;super&#x27; keyword unexpected here greeting: function() &#123; return super.greeting() + &#x27;obj&#x27;; &#125;,&#125;;Object.setPrototypeOf(obj, person);console.log(obj.greeting());Object.setPrototypeOf(obj, dog);console.log(obj.greeting());let person = &#123; greeting: function() &#123; return &#x27;hello&#x27;; &#125;,&#125;;let dog = &#123; greeting: function() &#123; return &#x27;woof&#x27;; &#125;,&#125;;let obj = &#123; // 以下方法可以正常运行 greeting() &#123; return super.greeting() + &#x27;obj&#x27;; &#125;,&#125;;Object.setPrototypeOf(obj, person);console.log(obj.greeting()); // helloobjObject.setPrototypeOf(obj, dog);console.log(obj.greeting()); // woofobj 在ES6 中，如果一个对象中定义了方法，这个方法自动获取到一个内置的属性[[HomeObject]], 来指向这个对象。super 呢，就是通过Object.getPrototypeOf([[HomeObject]]) 来获取到原型对象。obj.greeting() greeting() 方法中的[[HomeObject]] 就指向了obj. 那里面的super 就是Object.getPrototypeOf(obj), 那就是person 或dog 了，super.greeting() 就相当于person.greeting()了， 更为准确的说是 person.greeting.call(this). 因为如果person中的greenting有this, 我们还要给它指定this 指向， 不能让里面的this 指向别的对象， 只能让this 指向 obj 了。","categories":[],"tags":[]},{"title":"JavaScript设计模式读书笔记(1)","slug":"23-about-design-model","date":"2022-08-20T06:47:46.000Z","updated":"2023-08-03T03:01:42.228Z","comments":true,"path":"2022/08/20/23-about-design-model/","link":"","permalink":"https://sunjinkang.github.io/2022/08/20/23-about-design-model/","excerpt":"面向对象一、面向过程与面向对象面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里二、封装1、使用原型(prototype)为类添加属性和方法的两种方式(注意两种不能混用)：(1)为原型对象属性赋值","text":"面向对象一、面向过程与面向对象面向对象编程就是将你的需求抽象成一个对象，然后针对这个对象分析其特征（属性)与动作（方法)。这个对象我们称之为类。面向对象编程思想其中有一个特点就是封装，就是说把你需要的功能放在一个对象里二、封装1、使用原型(prototype)为类添加属性和方法的两种方式(注意两种不能混用)：(1)为原型对象属性赋值 123Book.prototype.display = function() &#123; // ....&#125; (2)将一个对象赋值给类的原型对象 123Book.prototype = &#123; display = function() &#123;&#125;&#125; 2、使用this和原型(prototype)为类添加属性和方法的区别：(1)使用this添加的属性和方法是在当前对象上添加的，每次通过类创建新对象时，this指向的属性和方法都会得到相应的创建(2)通过prototype继承的属性和方法是每个对象通过prototype访问到的，新创建对象时，不会再新创建属性和方法 3、constructor是什么？constructor是一个属性，当创建一个函数或者对象时都会为其创建一个原型对象prototype，在 prototype对象中又会像函数中创建 this一样创建一个constructor属性，那么constructor属性指向的就是拥有整个原型对象的函数或对象。 4、属性与方法的封装(1)私有属性与私有方法由于JavaScript的函数级作用域，声明在函数内部的变量以及方法在外界是访问不到的,通过此特性创建类的私有变量以及私有方法(2)共有属性和共有方法在函数内部通过 this创建的属性和方法，在类创建对象时，每个对象自身都拥有一份并且可以在外部访问到。因此通过this创建的属性可看作是对象共有属性和对象共有方法(3)特权方法(类的构造器)通过this创建的方法，不但可以访问这些对象的共有属性与共有方法，而且还能访问到类（创建时）或对象自身的私有属性和私有方法，由于这些方法权利比较大，所以我们又将它看作特权方法。在对象创建时通过使用这些特权方法我们可以初始化实例对象的一些属性,因此这些在创建对象时调用的特权方法还可以看作是类的构造器 5、在类的外部通过点语法定义的属性和方法以及在外部通过 prototype定义的属性和方法作用(1)类的外部通过点语法定义的属性和方法：通过new关键字创建新对象时，由于类外面通过点语法添加的属性和方法没有执行到,所以新创建的对象中无法获取他们，但是可以通过类来使用。因此在类外面通过点语法定义的属性以及方法被称为类的静态共有属性和类的静态共有方法(2)外部通过 prototype定义的属性和方法: 类通过prototype创建的属性或者方法在类实例的对象中是可以通过 this访问到的，所以我们将prototype对象中的属性和方法称为共有属性和共有方法通过new关键字创建的对象实质是对新对象 this 的不断赋值，并将prototype指向类的prototype所指向的对象，而类的构造函数外面通过点语法定义的属性方法是不会添加到新创建的对象上去的。因此要想在新创建的对象中使用 isChinese就得通过Book类使用而不能通过this，如 Book.isChinese，而类的原型 prototype 上定义的属性在新对象里就可以直接使用，这是因为新对象的prototype和类的prototype指向的是同一个对象。 6、闭包闭包是有权访问另外一个函数作用域中变量的函数，即在一个函数内部创建另外一个函数。我们将这个闭包作为创建对象的构造函数，这样它既是闭包又是可实例对象的函数，即可访问到类函数作用域中的变量 7、创建对象的安全模式new关键字的作用可以看作是对当前对象的this不停地赋值,没有用new，所以就会直接执行函数，而函数在全局作用域中执行所以在全局作用域中 this指向的当前对象自然就是全局变量 三、继承1、子类的原型对象 - 类式继承声明2个类而已，类式继承需要将第一个类的实例赋值给第二个类的原型类的原型对象的作用就是为类的原型添加共有方法,但类不能直接访问这些属性和方法,必须通过原型prototype来访问。而我们实例化一个父类的时候，新创建的对象复制了父类的构造函数内的属性与方法并且将原型_proto_指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法，并且这个新创建的对象可直接访问到父类原型对象上的属性与方法。如果我们将这个新创建的对象赋值给子类的原型，那么子类的原型就可以访问到父类的原型属性和方法。新创建的对象不仅仅可以访问父类原型上的属性和方法，同样也可访问从父类构造函数中复制的属性和方法。将这个对象赋值给子类的原型,那么这个子类的原型同样可以访问父类原型上的属性和方法与从父类构造函数中复制的属性和方法。这是类式继承的原理 (1)可以使用instanceof来检测某个对象是否是某个类的实例，或者说某个对象是否继承了某个类注意：instanceof是通过判断对象的 prototype链来确定这个对象是否是某个类的实例，而不关心对象与类的自身结构instanceof是判断前面的对象是否是后面类(对象)的实例，它并不表示两者的继承，在实现上面的 subClass 继承superClass时是通过将 superClass的实例赋值给subClass 的原型prototype，所以说SubClass.prototype继承了superClass (2)类式继承的缺点其一：由于子类通过其原型prototype对父类实例化，继承了父类。所以说父类中的共有属性要是引用类型，就会在子类中被所有实例共用,因此一个子类的实例更改子类原型从父类构造函数中继承来的共有属性就会直接影响到其他子类其二：由于子类实现的继承是靠其原型prototype对父类的实例化实现的，因此在创建父类的时候，是无法向父类传递参数的,因而在实例化父类的时候也无法对父类构造函数内的属性进行初始化 2、创建即继承 - 构造函数继承SuperClass.call(this，id);这条语句是构造函数式继承的精华，由于 call这个方法可以更改函数的作用环境，因此在子类中，对superClass调用这个方法就是将子类中的变量在父类中执行一遍，由于父类中是给this绑定属性的，因此子类自然也就继承了父类的共有属性。由于这种类型的继承没有涉及原型prototype，所以父类的原型方法自然不会被子类继承，而如果要想被子类继承就必须要放在构造函数中，这样创建出来的每个实例都会单独拥有一份而不能共用，这样就违背了代码复用的原则 3、将优点为我所用 - 组合继承(1)类式继承是通过子类的原型prototype对父类实例化来实现的,构造函数式继承是通过在子类的构造函数作用环境中执行一次父类的构造函数来实现的在子类构造函数中执行父类构造函数，在子类原型上实例化父类就是组合模式(2)缺点在使用构造函数继承时执行了一遍父类的构造函数，而在实现子类原型的类式继承时又调用了一遍父类构造函数。因此父类构造函数调用了两遍 4、洁净的继承者 - 原型式继承对类式继承的一个封装，其实其中的过渡对象就相当于类式继承中的子类，只不过在原型式中作为一个过渡对象出现的，目的是为了创建要返回的新的实例化对象 5、如虎添翼 - 寄生式继承寄生式继承就是对原型继承的第二次封装，并且在这第二次封装过程中对继承的对象进行了拓展,这样新创建的对象不仅仅有父类中的属性和方法而且还添加新的属性和方法 6、终极继承者 - 寄生组合式继承寄生式继承和构造函数继承 寄生式继承的改造 子类再想添加原型方法必须通过 prototype.对象，通过点语法的形式一个一个添加方法了，否则直接赋予对象就会覆盖掉从父类原型继承的对象 四、多继承单继承(extend)：对对象中的属性的一个浅复制过程，只能复制值类型的属性，无法复制引用类型属性 五、多态同一个方法多种调用方式","categories":[],"tags":[]},{"title":"基本数据类型-Symbol","slug":"22-about-symbol","date":"2022-08-19T05:37:24.000Z","updated":"2023-07-24T09:24:46.215Z","comments":true,"path":"2022/08/19/22-about-symbol/","link":"","permalink":"https://sunjinkang.github.io/2022/08/19/22-about-symbol/","excerpt":"","text":"什么是Symbol?有什么用处？Symbol的属性Symbol的方法","categories":[],"tags":[]},{"title":"装箱拆箱操作","slug":"21-devan-operation","date":"2022-08-09T05:43:57.000Z","updated":"2023-08-03T03:01:29.311Z","comments":true,"path":"2022/08/09/21-devan-operation/","link":"","permalink":"https://sunjinkang.github.io/2022/08/09/21-devan-operation/","excerpt":"我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：’hello world’.length。这是由于浏览器在内部做了装箱和拆箱操作。 什么是装箱拆箱？装箱：把基本数据类型转化为对应的引用类型的操作拆箱：把引用类型转化为基本数据类型的操作 基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol引用数据类型：对象(Object)、数组(Array)、函数(Function)四个基本的包装类型 String、Number、Boolean、Symbol 什么是包装类型？在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型","text":"我们都知道属性和方法是对象上的，但是基本数据类型可以访问属性和方法，比如：’hello world’.length。这是由于浏览器在内部做了装箱和拆箱操作。 什么是装箱拆箱？装箱：把基本数据类型转化为对应的引用类型的操作拆箱：把引用类型转化为基本数据类型的操作 基本数据类型：字符串(String)、数字(Number)、布尔(Boolean)、空(Null)、未定义(Undefined)、Symbol引用数据类型：对象(Object)、数组(Array)、函数(Function)四个基本的包装类型 String、Number、Boolean、Symbol 什么是包装类型？在 JavaScript 中的字符串、数值、布尔具有对象的使用特征，如具有属性和方法，之所以具有对象特征的原因是字符串、数值、布尔类型数据是JavaScript 底层使用 Object 构造函数“包装”来的，被称为包装类型 装箱装箱分为显式装箱和隐式装箱 显式装箱通过基本包装类型对象对基本类型进行显式装箱，即通过new的方式声明数据 12var string = new String(&#x27;test_string&#x27;);var number = new Number(1); 显式装箱可以对声明的对象进行属性和方法的添加，这是因为通过new创建的实例，在执行流离开当前作用域之前一直保留在内存中 1234567var string = new String(&#x27;test_string&#x27;);string.name = &#x27;for test&#x27;;string.sayHi = function()&#123; console.log(&#x27;this is test string&#x27;);&#125;console.log(string.name); // for teststring.sayHi(); // this is test string 隐式装箱隐式装箱是引擎自动执行的基本类型不能添加属性和方法，添加会报错。但是常常在使用的时候，可以直接调用方法，比如：’test_string’.substring()、’test_string’.indexOf()等，这是由于浏览器在内部做了隐式装箱。 下面以一个例子进行说明： 12345// 第一步var string = &#x27;test_string&#x27;;// 第二步var result = string.substring(4);console.log(result); // _string 在上面这段代码里面实际的执行步骤是：1、先创建一个String类型的一个实例2、在实例中调用方法3、销毁这个实例 1234567var string = &#x27;test_string&#x27;;// 1var newString = new String(string);// 2var result = newString.substring(4);// 3newString = null; 基于以上的隐式装箱操作，我们可以在基本类型上使用方法隐式装箱当读取一个基本类型值时，后台会创建一个该基本类型所对应的基本包装类型对象。在这个基本类型的对象上调用方法，其实就是在这个基本类型对象上调用方法。这个基本包装类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立即被销毁。这也是在基本类型上添加属性和方法会不识别或报错的原因了 显式装箱可以添加属性和方法，隐式装箱不能添加属性和方法 引用类型与基本包装类型的主要区别就是对象的生存期，使用new创建的引用类型实例当执行流离开当前作用域之前，都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后就被销毁。这就意味着我们不能给基本包装类型添加属性和方法。 拆箱拆箱是和装箱相反的操作，即把引用类型转换成基本的数据类型。通常通过引用类型的valueOf()和toString()方法来实现，toString()返回字符串，valueOf()返回对象本身。需要注意的是，toString() 和 valueOf() 返回的值有一定差别 1234567891011121314var numberObj = new Number(64);var stringObj = new String(&#x27;64&#x27;);console.log(typeof numberObj); // objectconsole.log(typeof stringObj); // object// 拆箱console.log(numberObj.valueOf()); // 64console.log(typeof numberObj.valueOf()); // number 基本的数字类型console.log(numberObj.toString()); // &#x27;64&#x27;console.log(typeof numberObj.toString()); // string 基本的字符类型console.log(stringObj.valueOf()); // &#x27;64&#x27;console.log(typeof stringObj.valueOf()); // string 基本的数据类型console.log(stringObj.toString()); // &#x27;64&#x27;console.log(typeof stringObj.toString()); // string 基本的数据类型 在进行拆箱操作的时候，toString()和valueOf()先执行哪个？在回答这个问题之前，我们先暂停一下，看一下包装类型中的symbol。 这里简单介绍一下Symbol，感兴趣的可以自己去学习。 SymbolSymbol 是 ECMAScript 2015 中新添加的特性，生成一个唯一标识符，可用于属性名称、也可用于属性值。目的是消除属性名称冲突创建Symbol 12let sym1 = Symbol();let sym2 = Symbol(&#x27;sym&#x27;); 注意：1、每次调用Symbol都会创建新的symbol2、不可以用new 创建Symbol（围绕原始数据类型创建一个显式包装器对象从 ECMAScript 6 开始不再被支持。 然而，现有的原始包装器对象，如 new Boolean、new String以及new Number，因为遗留原因仍可被创建。）3、symbol的参数可以不传，这个参数是用于描述symbol，可以用于调试但不是用于访问symbol本身4、创建Symbol包装器对象，可以使用Object()函数 123456789// 1Symbol(&#x27;sym&#x27;) === Symbol(&#x27;sym&#x27;); // false// 2let sym = new Symbol(); // TypeError: Symbol is not a constructor// 4let sym2 = Symbol(&#x27;sym&#x27;);typeof sym2; // &#x27;symbol&#x27;let sym2Obj = Object(sym2);typeof sym2Obj; // &#x27;object&#x27; 在symbol的文档中，有一个属性Symbol.toPrimitive。文档中关于它的介绍是： Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。该函数被调用时，会被传递一个字符串参数 hint ，表示要转换到的原始值的预期类型。 hint 参数的取值是 “number”、”string” 和 “default” 中的任意一个。 我们看一下这个属性是怎么干扰一个对象转换为原始值的 123456789101112131415161718192021// 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果var obj1 = &#123;&#125;;console.log(+obj1); // NaNconsole.log(`$&#123;obj1&#125;`); // &quot;[object Object]&quot;console.log(obj1 + &quot;&quot;); // &quot;[object Object]&quot;// 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果var obj2 = &#123; [Symbol.toPrimitive](hint) &#123; if (hint == &quot;number&quot;) &#123; return 10; &#125; if (hint == &quot;string&quot;) &#123; return &quot;hello&quot;; &#125; return true; &#125;&#125;;console.log(+obj2); // 10 -- hint 参数值是 &quot;number&quot;console.log(`$&#123;obj2&#125;`); // &quot;hello&quot; -- hint 参数值是 &quot;string&quot;console.log(obj2 + &quot;&quot;); // &quot;true&quot; -- hint 参数值是 &quot;default&quot; 注意：hint 取值为：‘number’:该场合需要转成数值，‘string’:该场合需要转成字符串，‘default’:该场合可以转成数值，也可以转成字符串。 对象转换成原始值的方法及执行顺序以下优先级从上到下依次降低1、先判断对象中是否有/[Symbol.toPrimitive/]/(hint/)方法，如果有的话，优先执行该方法2、如果预期被转化成字符串类型时，则优先执行toString()方法3、如果预期被转化成默认类型或数字类型时，则优先执行valueOf()方法注意：若没有valueOf()方法，但是定义了toString()方法，则会执行toString()方法 1234567891011121314151617181920212223242526272829303132333435363738394041var obj = &#123; [Symbol.toPrimitive](hint) &#123; console.log(hint); return &#x27;symbol&#x27;; &#125;, toString() &#123; return &#x27;string&#x27;; &#125;, valueOf() &#123; return &#x27;valueOf&#x27;; &#125;&#125;;console.log(String(obj)); // string symbolconsole.log(Number(obj)); // number NaNvar obj1 = &#123; toString() &#123; return &#x27;string&#x27;; &#125;, valueOf() &#123; return &#x27;valueOf&#x27;; &#125;&#125;;console.log(String(obj1)); // stringconsole.log(Number(obj1)); // NaNvar obj2 = &#123; toString() &#123; return &#x27;1&#x27;; &#125;,&#125;;console.log(String(obj2)); // &#x27;1&#x27;console.log(Number(obj2)); // 1var obj3 = &#123; valueOf() &#123; return &#x27;2&#x27;; &#125;&#125;;console.log(Number(obj3)); // 2console.log(String(obj3)); // [object Object]","categories":[],"tags":[]},{"title":"开发一个vscode插件的流程","slug":"20-create-vscode-plugin","date":"2022-08-05T02:33:23.000Z","updated":"2023-08-03T03:01:22.017Z","comments":true,"path":"2022/08/05/20-create-vscode-plugin/","link":"","permalink":"https://sunjinkang.github.io/2022/08/05/20-create-vscode-plugin/","excerpt":"vscode中文手册https://www.bookstack.cn/read/CN-VScode-Docs/README.md vscode插件脚手架安装脚手架和代码生成器 1npm install -g yo generator-code 生成vscode脚手架项目 1yo code","text":"vscode中文手册https://www.bookstack.cn/read/CN-VScode-Docs/README.md vscode插件脚手架安装脚手架和代码生成器 1npm install -g yo generator-code 生成vscode脚手架项目 1yo code","categories":[],"tags":[]},{"title":"Map 结构","slug":"19-about-map","date":"2022-08-04T06:07:12.000Z","updated":"2023-08-03T03:01:14.637Z","comments":true,"path":"2022/08/04/19-about-map/","link":"","permalink":"https://sunjinkang.github.io/2022/08/04/19-about-map/","excerpt":"什么是Map?由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。 怎么创建map？1const map = new Map(); map可以使用一个对象作为键","text":"什么是Map?由ES6提供的一种数据结构。它类似于对象，也是键值对的集合，但和对象不同的是，对象的键只能是字符串，map的键可以是各种类型的值（包括对象）。即，Object提供了 字符串-值 的对应，map提供了 值-值 的对应，是一种更完善的Hash结构实现。 怎么创建map？1const map = new Map(); map可以使用一个对象作为键 12345678const map = new Map();const o = &#123; p: &#x27;string&#x27; &#125;;map.set(o, &#x27;text&#x27;);map.get(o); // textmap.has(o); // truemap.delete(o); map还可以接受一个数组作为参数，该数组成员是一个个表示键值对的数组 1234const map = new Map([[&#x27;name&#x27;, &#x27;Tom&#x27;], [&#x27;age&#x27;, 12]]);map.size; // 2map.has(&#x27;name&#x27;); // truemap.get(&#x27;age&#x27;); // 12 注意点如果对同一个键多次赋值，后面的值将覆盖前面的值 12map.set(1, &#x27;qw&#x27;).set(1, &#x27;sdf&#x27;);map.get(1); // sdf map的实例属性和方法1、size用法：map.size作用：获取map结构的大小返回：map结构的长度大小 1234const map = new Map();map.size; // 0map.set(1, 12);map.size; // 1 2、set()用法：map.set(key, value)作用：向map中添加或修改map的数据返回：修改后的map 12const map = new Map();map.set(1, 12); 3、get()用法：map.get(key)作用：获取对应key的value值返回：map结构中key对应的值，不存在对应key时，返回undefined 1234const map = new Map();map.set(1, 12);map.get(1); // 12map.get(2); // undefined 4、has()用法：map.has(key)作用：判断map中是否有对应的key返回：true/false，依据map中是否有对应的key，返回true或false 1234const map = new Map();map.set(1, 12);map.has(1); // truemap.has(2); // has 5、delete()用法：map.delete(key)作用：删除map中对应的key及value返回：true/false，删除成功返回true，删除失败返回false 1234const map = new Map();map.set(1, 12);map.delete(1); // truemap.delete(2); // false 6、clear()用法：map.clear()作用：清空map中的数据返回：undefined 123const map = new Map();map.set(1, 12);map.clear(); // undefined map的遍历方法1、keys()2、values()3、entries()4、forEach() 参考：https://www.jianshu.com/p/93b5a5940de8","categories":[],"tags":[]},{"title":"伪数组","slug":"18-fake-array","date":"2022-08-04T02:57:14.000Z","updated":"2023-08-03T03:01:05.993Z","comments":true,"path":"2022/08/04/18-fake-array/","link":"","permalink":"https://sunjinkang.github.io/2022/08/04/18-fake-array/","excerpt":"概念ArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。 特征1、具有length属性2、按照索引方式存储数据3、不具有数组的方法，如push、pop等","text":"概念ArrayLike，也叫作类数组。是一种按照索引存储数据且具有length属性的对象。 特征1、具有length属性2、按照索引方式存储数据3、不具有数组的方法，如push、pop等 有哪些常见的伪数组1、function的arguments对象2、document.getElementsByTagName、document.getElementsByClassName等document方法获取的NodeList对象3、上传文件是选择的file对象4、自定义的某些对象 判断一个数组是不是伪数组的方法1、Array.isArray 1234// fakeArray表示伪数组// array 表示正常数组Array.isArray(fakeArray); // falseArray.isArray(array); // true 2、instanceof 1234// fakeArray表示伪数组// array 表示正常数组fakeArray instanceof Array; // falsearray instanceof Array; // true 将数组转为真正数组的方法1、使用Array.prototype.slice.call()2、使用[].slice.call()3、使用Array.from()","categories":[],"tags":[]},{"title":"javascript DOM编程艺术阅读笔记","slug":"17-about-dom","date":"2022-07-31T05:42:45.000Z","updated":"2023-08-03T03:00:58.728Z","comments":true,"path":"2022/07/31/17-about-dom/","link":"","permalink":"https://sunjinkang.github.io/2022/07/31/17-about-dom/","excerpt":"JavaScript简史1、DOMDOM是一套对文档的内容进行抽象和概念化的方法。 第0级DOM(DOM Level 0)试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。 第1级DMO(DOM Level 1)Netscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。","text":"JavaScript简史1、DOMDOM是一套对文档的内容进行抽象和概念化的方法。 第0级DOM(DOM Level 0)试验性质的初级DOM，在还未形成统一标准的初期阶段，“第0级DOM”的常见用途是翻转图片和验证表单数据。 第1级DMO(DOM Level 1)Netscape、微软和其他一些浏览器制造商们还能抛开彼此的敌意而与W3C携手制定新的标准，并于1998年10月完成了“第1级DOM”(DOM Level 1) 。 2、浏览器战争2.1 DHTMLDHTML是“Dynamic HTML”(动态HTML)的简称。DHTML并不是一项新技术，而是描述HTML、CSS和.JavaScript技术组合的术语。背后含义:(1)利用HTML把网页标记为各种元素;(2)利用CSS设置元素样式和它们的显示位置;(3)利用JavaScript实时地操控页面和改变样式。 JavaScript语法循环语句1、while循环 123while (condition)&#123; statements;&#125; do…while循环 123do &#123; statements;&#125; while (condition); 2、for循环 123for (initial condition; test condition; alter condition)&#123; statements;&#125; 函数1、变量的作用域全局变量(global variable)可以在脚本中的任何位置被引用。一旦你在某个脚本里声明了一个全局变量，就可以从这个脚本中的任何位置―一包括函数内部—―引用它。全局变量的作用域是整个脚本。局部变量(local variable）只存在于声明它的那个函数的内部，在那个函数的外部是无法引用它的。局部变量的作用域仅限于某个特定的函数。 对象对象（object）是一种非常重要的数据类型，但此前我们还没有认真对待它。对象是自包含的数据集合，包含在对象里的数据可以通过两种形式访问——属性（property)和方法(method) :-属性是隶属于某个特定对象的变量-方法是只有某个特定对象才能调用的函数对象就是由一些属性和方法组合在一起而构成的一个数据实体 1、用户定义对象(user-defined object)由程序员自行创建的对象 2、内建对象(native object)JavaScript提供了一系列预先定义好的对象，这些可以拿来就用的对象称为内建对象( native object)Array、Math、Date等 3、宿主对象(host object)由浏览器提供的预定义对象被称为宿主对象(host object )宿主对象包括document、Form、Image和Element等。我们可以通过这些对象获得关于网页上表单、图像和各种表单元素等信息 DOM1、文档:DOM中的’D’如果没有document(文档），DOM也就无从谈起。当创建了一个网页并把它加载到Web浏览器中时，DOM就在幕后悄然而生。它把你编写的网页文档转换为一个文档对象 2、对象:DOM中的’O’如上对象 3、模型:DOM中的’M’DOM中的“M”代表着“Model”(模型)，但说它代表着“Map”(地图）也未尝不可。模型也好，地图也罢，它们的含义都是某种事物的表现形式。就像一个模型火车代表着一列真正的火车、一张城市街道图代表着一个实际存在的城市那样，DOM代表着加载到浏览器窗口的当前网页。浏览器提供了网页的地图（或者说模型)，可以通过JavaScript去读取这张地图 4、节点(1)元素节点(2)文本节点(3)属性节点(4)CSS(5)获取元素-getElementById 返回一个对象-getElementsByTagName 返回一个对象数组，使用通配符（*）获取文档中总共有多少元素节点 12var shopping = document.getElementById(&quot;purchases&quot;) ;var items = shopping.getElementsByTagName(&quot;*&quot;) ; -getElementsByClassName 返回一个对象数组使用这个方法还可以查找那些带有多个类名的元素。要指定多个类名，只要在字符串参数中用空格分隔类名即可注意，即使在元素的class属性中，类名的顺序和参数中指定的不一样，也照样会匹配该元素。不仅类名的实际顺序不重要，就算元素还带有更多类名也没有关系。 12var shopping = document.getElementById(&quot;purchases&quot;);var sales = shopping.getElementsByClassName(&quot;sale&quot;); 5、获取和设置属性(1)getAttribute 只能通过元素节点调用(2)setAttribute 只能通过元素节点调用，修改属性值细节:通过setAttribute对文档做出修改后，在通过浏览器的viewsource(查看源代码）选项去查看文档的源代码时看到的仍将是改变前的属性值，也就是说，setAttribute做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式:先加载文档的静态内容，再动态刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力:对页面内容进行刷新却不需要在浏览器里刷新页面。 案例研究：JavaScript图片库DOM是一种适用于多种环境和多种程序设计语言的通用型API。如果想把DOM技巧运用在Web浏览器以外的应用环境里，严格遵守“第1级DOM”能够避免与兼容性有关的任何问题。1、childNodes属性 用来获取任何一个元素的所有子元素2、nodeType属性 共有12中可取值以下3种具有实用价值：-元素节点的nodeType属性值是1-属性节点的nodeType属性值是2-文本节点的nodeType属性值是33、nodeValue属性 得到和设置节点的值4、firstChild和lastChild 最佳实践1、平稳退化平稳退化(graceful degradation)，虽然某些功能无法使用，但最基本的操作仍能顺利完成2、“javascript:”伪协议“真”协议用来在因特网上的计算机之间传输数据包，如HTTP协议(http://) 、FTP协议（ftp://)等，伪协议则是一种非标准化的协议“javascript:”伪协议让我们通过一个链接来调用JavaScript函数 1&lt;a href=&quot;javascript:popUp(&#x27;http://www.example.com/&#x27;);&quot;&gt;Example&lt;/a&gt; 3、CSS结构与样式分离渐进增强，用一些额外的信息层去包裹原始数据4、分离javascript5、向后兼容(1)对象检测：检测浏览器对JavaScript的支持程度(2)浏览器嗅探技术通过提取浏览器供应商提供的信息来解决向后兼容问题。从理论上讲，可以通过JavaScript代码检索关于浏览器品牌和版本的信息，这些信息可以用来改善JavaScript脚本代码的向后兼容性，但这是一种风险非常大的技术。首先，浏览器有时会“撒谎”。因为历史原因，有些浏览器会把自己报告为另外一种浏览器，还有一些浏览器允许用户任意修改这些信息其次，为了适用于多种不同的浏览器，浏览器嗅探脚本会变得越来越复杂。如果想让浏览器嗅探脚本能够跨平台工作，就必须测试所有可能出现的供应商和版本号组合。这是一个无穷尽的任务，测试的组合情况越多，代码就越复杂和冗长最后，许多浏览器嗅探脚本在进行这类测试时要求浏览器的版本号必须得到精确的匹配。因此，每当市场上出现新版本时，就不得不修改这些脚本6、性能考虑(1)尽量少访问DOM和尽量减少标记(2)合并和放置脚本多个脚本合并，减少请求次数把所有/标签都放到文档的末尾，/&lt;/body/&gt;标记之前，就可以让页面变得更快(3)压缩脚本压缩工具：-Douglas Crockford的JSMin (http://www.crockford.com/javascript/jsmin.html)-雅虎的YUI Compressor (http://developer.yahoo.com/yui/compressor)-谷歌的Closure Compiler (http://closure-compiler.appspot.com/home) 动态创建标记1、document.write &amp; innerHTML属性2、DOM方法(1)createElement(1)appendChild(1)createTextNode(1)insertBefore3、Ajax(1)XMLHttpRequest对象 123456789function getHTTPObject () &#123; if (typeof XMLHttpRequest == &quot;undefined&quot;) xMLHttpRequest =function () &#123; try &#123; return new Activexobject ( &quot;Msxm12.XMLHTTP.6.0&quot;); )catch (e) &#123; &#125; try &#123; return new ActivexObject (&quot;Msxm12.XMLHTTP.3.0&quot;);)catch (e) &#123; &#125; try &#123; return new ActivexObject ( &quot;Msxm12.XMLHTTP&quot;); )catch (e) &#123; &#125; return false; &#125; return new XMLHttpRequest ( ) ;&#125; XHTML5本质上是使用严格的XML规则编写的HTML5。从技术角度说，Web浏览器应该将任何XHTML5文档都视为XML文档，而不是HTML文档。而在现实中，你还得在文档的头部发送正确的MIME类型，即application/xhtml+xml。有些浏览器不认识这个MIME类型，因而一般要在服务器端对浏览器进行探查后再发送。否则最坏的情况，页面很可能根本不会在浏览器中呈现。因此，绝大多数XHTML页面仍然是以HTML类型发送的。 CSS-DOM1、三位一体的网页(1)结构层网页的结构层(structural layer)由HTML或XHTML之类的标记语言负责创建(2)表示层表示层(presentation layer)由CSS负责完成。CSS描述页面内容应该如何呈现(3)行为层行为层(behavior layer)负责内容应该如何响应事件这一问题。这是JavaScript语言和DOM主宰的领域(4)分离-使用(X)HTML去搭建文档的结构-使用CSS去设置文档的呈现效果-使用DOM脚本去实现文档的行为2、style属性在外部样式表里声明的样式不会进入style对象，在文档的部分里声明的样式也是如此style对象只包含在HTML代码里用style属性声明的样式3、何时该使用DOM脚本设置样式(1)根据元素在节点树里的位置来设置样式(2)根据某种条件反复设置某种样式(3)响应事件4、className属性 HTML51、canvas2、video和audio 疑问点：1、遇到的知识点觉得掌握了，没有记录，后面又忘了重要的知识点都记录，不管有没有掌握2、任务拆分评估时间不准更深入的了解项目代码和业务逻辑3、看书遇到问题的时候，先记录继续阅读，还是先解决问题在阅读？先记录继续阅读，看后面是否有解答4、原型链不建议研究__proto__这种知识点，可以看看es6中新的关于原型链的继承理解知识的时候，不要添加太多概念，避免混乱","categories":[],"tags":[]},{"title":"js-基本类型与引用类型","slug":"16-origin-type-and-reference-type","date":"2022-07-19T08:23:28.000Z","updated":"2023-07-24T09:24:46.210Z","comments":true,"path":"2022/07/19/16-origin-type-and-reference-type/","link":"","permalink":"https://sunjinkang.github.io/2022/07/19/16-origin-type-and-reference-type/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"js-类型转换","slug":"15-js-transform","date":"2022-07-19T07:59:15.000Z","updated":"2023-08-03T03:00:48.326Z","comments":true,"path":"2022/07/19/15-js-transform/","link":"","permalink":"https://sunjinkang.github.io/2022/07/19/15-js-transform/","excerpt":"在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。== ：比较两个数据是否相等，允许进行类型转化比如：1==true、’1’==true，结果都是true===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false比如：1===true、’1’===true，结果为false 数学运算符中的类型转换1、减、乘、除运算非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型 123451 - true // 0, true先转换乘1，然后执行 1 - 11 - false // 1, true先转换乘0，然后执行 1 - 01 - null // 1, true先转换乘0，然后执行 1 - 01 - undefined // NaN, undefined转换为数字为 NaN2 * [&#x27;5&#x27;] // 10, [&#x27;5&#x27;]先变成&#x27;5&#x27;（这一步涉及拆箱操作）,然后变成数字5","text":"在开始之前，先说一下为什么会说这个，之前在看一篇文章的时候，提到 == 和 === 的区别。== ：比较两个数据是否相等，允许进行类型转化比如：1==true、’1’==true，结果都是true===：严格比较两个数据是否是否相等，包括比较类型是否相同，类型不匹配返回false比如：1===true、’1’===true，结果为false 数学运算符中的类型转换1、减、乘、除运算非Number类型的使用减、乘、除(-、*、/)运算符时，会先将非Number类型转换为Number类型 123451 - true // 0, true先转换乘1，然后执行 1 - 11 - false // 1, true先转换乘0，然后执行 1 - 01 - null // 1, true先转换乘0，然后执行 1 - 01 - undefined // NaN, undefined转换为数字为 NaN2 * [&#x27;5&#x27;] // 10, [&#x27;5&#x27;]先变成&#x27;5&#x27;（这一步涉及拆箱操作）,然后变成数字5 拆箱操作 2、加运算js中的加法运算，还可以用来拼接字符串 加号一侧为String类型，则加法运算被识别为拼接字符串操作，并会优先将另一侧转换为字符串类型 加号一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型 加号一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后进行拼接 以上三点，优先级从高到低* 1234123 + &#x27;123&#x27; // &#x27;123123&#x27; (规则1)123 + null // 123 (规则2)123 + true // 124 (规则2)123 + &#123;&#125; // &#x27;123[object Object]&#x27; (规则3) 逻辑运算中的类型转换1、单个变量先将变量转换为Boolean值只有null、undefined、’’、NaN、0、false的boolean值是false，其他情况都是true，比如：{}、[] 2、使用 == 比较中的5条规则建议使用 === 规则1：NaN和其他任何类型比较永远返回false(包括和他自己)1NaN == NaN // false 规则2：boolean和其他任何类型比较，Boolean首先被转换成Number类型123456true == 1 // truetrue == &#x27;2&#x27; // false,先将true转换为1，而不是把&#x27;2&#x27;变成truetrue == [&#x27;1&#x27;] // true, 先将true转换为1，[&#x27;1&#x27;]拆箱成&#x27;1&#x27;,在参考规则3true == [&#x27;2&#x27;] // false, 同上undefined == false // false, 首先false变成0，然后参考规则4null == false // false, 同上 String和Number比较，先将String转换为Number类型12123 == &#x27;123&#x27; // true, &#x27;123&#x27;会变成123&#x27;&#x27; == 0 // true，&#x27;&#x27;会变成 0 null == undefined 比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false1234567null == undefined // truenull == &#x27;&#x27; // falsenull == 0 // falsenull == false // falseundefined == &#x27;&#x27; // falseundefined == 0 // falseundefined == false // false 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型 ToPrimitive规则是引用类型向原始类型转变的规则，它遵循先 valueOf后 toString的模式期望得到一个原始类型，如果无法得到一个原始类型，就会抛出TypeError*12&#x27;[object Object]&#x27; == &#123;&#125; // true, 对象和字符串比较，对象通过toString 得到一个基本类型值&#x27;1,2,3&#x27; == [1,2,3] // true, [1,2,3]通过toString得到一个基本类型 类型转换表 类型转换对照网站https://dorey.github.io/JavaScript-Equality-Table/","categories":[],"tags":[]},{"title":"前端概念相关-渐进增强与优雅降级","slug":"14-about-fe-theory","date":"2022-07-12T02:37:56.000Z","updated":"2023-08-03T03:00:33.988Z","comments":true,"path":"2022/07/12/14-about-fe-theory/","link":"","permalink":"https://sunjinkang.github.io/2022/07/12/14-about-fe-theory/","excerpt":"渐进增强(Progressive Enhancement)(相当于向上兼容)一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验 优雅降级(Graceful Degradation)(相当于向下兼容)一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览 向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少大多数软件都是向下兼容的","text":"渐进增强(Progressive Enhancement)(相当于向上兼容)一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验 优雅降级(Graceful Degradation)(相当于向下兼容)一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览 向下兼容指的是高版本支持低版本的或者说后期开发的版本支持和兼容早期开发的版本，向上兼容的很少大多数软件都是向下兼容的 渐进增强与优雅降级的区别优雅降级和渐进增强都关注于同一网站在不同设备以及不同浏览器下的表现程度关键的区别则在于它们各自关注于何处，以及这种关注如何影响工作的流程 优雅降级观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 渐进增强观点则认为应关注于内容本身。 123456789101112.transition &#123; /*渐进增强写法*/ -webkit-transition: all .5s; -moz-transition: all .5s; -o-transition: all .5s; transition: all .5s;&#125;.transition &#123; /*优雅降级写法*/ transition: all .5s; -o-transition: all .5s; -moz-transition: all .5s; -webkit-transition: all .5s;&#125; 前缀CSS3（-webkit-* / -moz-* / -o-*）和正常CSS3在浏览器中的支持情况是这样的： 1、很久以前：浏览器前缀CSS3和正常CSS3都不支持；2、不久之前：浏览器只支持前缀CSS3，不支持正常CSS3；3、现在：浏览器既支持前缀CSS3，又支持正常CSS3；4、未来：浏览器不支持前缀CSS3，仅支持正常CSS3. 渐进增强的写法，优先考虑老版本浏览器的可用性，最后才考虑新版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，正常CSS3会覆盖前缀CSS3。优雅降级的写法，优先考虑新版本浏览器的可用性，最后才考虑老版本的可用性。在时期3前缀CSS3和正常CSS3都可用的情况下，前缀CSS3会覆盖正常的CSS3。","categories":[],"tags":[]},{"title":"各类文档地址","slug":"13-document-location","date":"2022-07-05T08:17:32.000Z","updated":"2023-08-03T03:00:25.159Z","comments":true,"path":"2022/07/05/13-document-location/","link":"","permalink":"https://sunjinkang.github.io/2022/07/05/13-document-location/","excerpt":"code spell checker配置项说明文档地址 查看chrome各个版本功能变更chrome status 查看== 、=== 、if()在不同情况下的执行结果地址","text":"code spell checker配置项说明文档地址 查看chrome各个版本功能变更chrome status 查看== 、=== 、if()在不同情况下的执行结果地址 css层叠样式表官方文档 Recoil官方文档 React官方文档 vue官方文档 VueUse–vue使用的hooks库官方文档 HTML官方文档 testing-library/react官方文档 nodejs官方文档-英文版中文文档 ahooks官方文档","categories":[],"tags":[]},{"title":"github生成令牌(Personal_access_tokens)操作步骤","slug":"12-create-github-tokens","date":"2022-06-30T03:23:56.000Z","updated":"2023-08-03T03:00:16.687Z","comments":true,"path":"2022/06/30/12-create-github-tokens/","link":"","permalink":"https://sunjinkang.github.io/2022/06/30/12-create-github-tokens/","excerpt":"github生成令牌(1)登录GitHub网站(2)找到setting页面 -&gt; Developer setting(3)选择 Personal access tokens ，点击 Generate new token 按钮(4)需要填写token的权限范围(5)注意：生成的token只在生成后可以看一次，一定要记得保存！！！","text":"github生成令牌(1)登录GitHub网站(2)找到setting页面 -&gt; Developer setting(3)选择 Personal access tokens ，点击 Generate new token 按钮(4)需要填写token的权限范围(5)注意：生成的token只在生成后可以看一次，一定要记得保存！！！","categories":[],"tags":[]},{"title":"github推送代码弹窗应该怎么输入？","slug":"11-github-push-insert-password","date":"2022-06-30T02:45:15.000Z","updated":"2023-08-03T03:00:05.799Z","comments":true,"path":"2022/06/30/11-github-push-insert-password/","link":"","permalink":"https://sunjinkang.github.io/2022/06/30/11-github-push-insert-password/","excerpt":"github推送代码弹窗应该怎么输入?当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。 (1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。","text":"github推送代码弹窗应该怎么输入?当本地修改代码后，需要推送到github仓库时，由于本地未记录用户名与密码，导致push时，先后出现GitHub登录弹窗，以及一个小弹窗，鉴于在输入实际操作中，两次输入username和password不知道应该怎么输入，做个记录，避免遗忘。 (1)本地修改代码，提交。本文仅从git push开始记录，之前的命令和操作如果不知道怎么办，请自行百度或Google。 1git push —- 注意：有时推送代码时，会出现超时等情况，可能是网络问题，可多试几次或稍后再试 123456$ git pushfatal: unable to access &#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;: Failed to connect to github.com port 443: Timed out// --------$ git pushfatal: unable to access &#x27;https://github.com/sunjinkang/test_vue3_sql.git/&#x27;: OpenSSL SSL_read: Connection was aborted, errno 10053 (2)第一个GitHub登录弹窗\" class=\"lazyload\" data-srcset=\"\" srcset=\"data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==该弹窗中 username为github的登录邮箱，password为GitHub的登录密码—- 注意：本次输入完成后，虽然输入的均为正确信息，但是由于GitHub不在支持用户名密码推送，改为使用令牌，导致输入后悔提示登录失败 12Logon failed, use ctrl+c to cancel basic credential prompt.remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. (3)第二个登录弹窗![login_insert]该弹窗会出现两次，第一次输入username，第二次输入password，username为GitHub的登录邮箱，password为GitHub网站的连接令牌(Personal access tokens)(如何生成token可以查看文章github生成令牌)—- 注意：如果password输入错误，会导致无法提交 12345$ git pushLogon failed, use ctrl+c to cancel basic credential prompt.remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.fatal: Authentication failed for &#x27;https://github.com/xxxxxxx.git/&#x27; 当username和password输入完成后，就可以正常push代码啦","categories":[],"tags":[]},{"title":"meta标签的使用","slug":"10-about-meta","date":"2022-06-28T14:16:30.000Z","updated":"2023-08-03T02:59:46.527Z","comments":true,"path":"2022/06/28/10-about-meta/","link":"","permalink":"https://sunjinkang.github.io/2022/06/28/10-about-meta/","excerpt":"meta标签的使用文档级元数据元素meta标签一般放在HTML页面的head里面，MDN定义： HTML 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(&lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt; 或 &lt;title&gt;）之一表示的任何元数据信息。","text":"meta标签的使用文档级元数据元素meta标签一般放在HTML页面的head里面，MDN定义： HTML 元素表示那些不能由其它 HTML 元相关（meta-related）元素（(&lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt; 或 &lt;title&gt;）之一表示的任何元数据信息。 meta定义的元数据类型(1)name属性：meta元素提供文档级别元数据，应用于整个页面– name和content一起使用，name表示元数据名称，content表示元数据的值—- name=”author”，表示网页作者的名字，例如某个组织或机构 1&lt;mate name=&quot;author&quot; content=&quot;xxx@mail.com&quot;&gt; —- name=”description”，是一段简短而精确的，对页面内容的描述 12//淘宝网页的meta&lt;meta name=&quot;description&quot; content=&quot;淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！&quot;&gt; —- name=”keywords”，与页面内容相关的关键词，使用逗号分隔，需要注意某些搜索引擎会用这些关键词对文档进行分类 12//淘宝网页的meta&lt;meta name=&quot;keyword&quot; content=&quot;淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺&quot;&gt; —- name=”viewport”，为viewport（视口）的初始大小提供指示，目前仅用于移动设备 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; width：用来设置viewport的宽度为设备宽度，常用值：device-width、？？？？initial-scale：为设备宽度与viewport大小之间的缩放比例maximum-scale：？？？？minimum-scale：？？？？user-scalable：？？？？minimal-ui：？？？？ —- name=”robots”，表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的content类型：all：搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索none：搜索引擎将忽略此网页index：搜索引擎索引此网页follow：搜索引擎继续通过此网页的链接索引搜索其它的网页 —- name=”renderer”，用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式 123&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; //默认webkit内核&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; //默认IE兼容模式&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; //默认IE标准模式 content类型：？？？？ —- name=”spm-id”，？？？？ 12// 淘宝&lt;meta name=&quot;spm-id&quot; content=&quot;a21bo&quot;&gt; —- name=”aplus-xplug”，？？？？ 12// 淘宝网&lt;meta name=&quot;aplus-xplug&quot; content=&quot;NONE&quot;&gt; (2)http-equiv属性：meta元素是编译指令，提供的信息与类似命名的http头部相同– http-equiv和content一起使用，http-equiv表示元数据名称，content表示元数据的值– http-equiv所有允许的值都是特定http头部的名称—- http-equiv=”X-UA-Compatible” 12// 淘宝网&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=10,chrome=1&quot;&gt;//IE浏览器适配 IE=10告诉浏览器，以当前浏览器支持的最新版本来渲染。chrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。两者都存在的情况：如果有chrome插件，就以chrome内核渲染，如果没有，就以当前浏览器支持的最高版本渲染。另外，这个属性支持的范围是IE8-IE11如果在http头部中也设置了这个属性，并且和meta中设置的有冲突，开发者偏好（meta元素）优先于Web服务器设置（HTTP头）。 —- http-equiv=”content-type”，用来声明文档类型和字符集 1&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; —- http-equiv=”x-dns-prefetch-control”一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以如下设置打开对a标签的提前解析： 1&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt; —- cache-control、Pragma、Expires，和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略 ？？？？ (3)charset属性：meta元素是一个字符集声明，告诉文档使用哪种字符编码(4)itemprop属性：meta元素提供用户定义的元数据","categories":[],"tags":[]},{"title":"MarkDown语法及示例","slug":"9-text-type-about-markdown","date":"2022-06-27T02:43:07.000Z","updated":"2024-03-27T09:56:23.200Z","comments":true,"path":"2022/06/27/9-text-type-about-markdown/","link":"","permalink":"https://sunjinkang.github.io/2022/06/27/9-text-type-about-markdown/","excerpt":"MarkDown语法及示例代码块```javascriptconst name = ‘eric’;….``` 加粗字体**文字**__文字__ 倾斜字体*文字*_文字_","text":"MarkDown语法及示例代码块```javascriptconst name = ‘eric’;….``` 加粗字体**文字**__文字__ 倾斜字体*文字*_文字_ 斜体加粗***文字***___文字___ 删除线~~文字~~ 表格 表头1 表头2 文字1 文字2 文字颜色文字 12&lt;font color=&quot;red&quot;&gt;文字&lt;/font&gt;&lt;font color=&quot;blue&quot;&gt;文字&lt;/font&gt; 文字大小文字 12&lt;font size=4&gt;文字&lt;/font&gt;&lt;font size=5&gt;文字&lt;/font&gt; 文字字体文字 12&lt;font face=&quot;黑体&quot;&gt;文字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;文字&lt;/font&gt; 文字居中1&lt;center&gt;文字&lt;/center&gt; 背景色文字 1&lt;mark style=&quot;bgcolor:red&quot;&gt;文字&lt;/mark&gt; 无序列表 第一行 第二行 第三行 第一行 第二行 第三行 第一行 第二行 第三行1234567891011* 第一行* 第二行* 第三行+ 第一行+ 第二行+ 第三行- 第一行- 第二行- 第三行 有序列表 第一行 第二行 第三行 1231. 第一行2. 第二行3. 第三行 嵌套列表: 列表嵌套只需在子列表中的选项前面添加两个或四个空格即可 第一行 1-1 第二行 2-1 第三行 3-1 第一行 1-1 第二行 2-1 第三行 3-1 12345678910111213* 第一行 - 1-1* 第二行 - 2-1* 第三行 - 3-1* 第一行 1. 1-1* 第二行 1. 2-1* 第三行 1. 3-1 区块：区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号&gt; 区块 区块1区块2 区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推 1 2 3 链接[链接名称](链接地址) 或 &lt;链接地址&gt; 12[百度](www.baidu.com)&lt;www.baidu.com&gt; 图片![alt 属性文本](图片地址) 图片居中![alt 属性文本](图片地址#pic_center) 插入公式$ 数学公式 $​​​​​​​$$ 数学公式 $$​ 指数和下标可以用^和_后加相应字符来实现,如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。a^1a_1$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$","categories":[],"tags":[]},{"title":"js-新建固定长度数据","slug":"8-create-fixed-length-array","date":"2022-06-27T02:20:46.000Z","updated":"2023-08-03T02:59:24.068Z","comments":true,"path":"2022/06/27/8-create-fixed-length-array/","link":"","permalink":"https://sunjinkang.github.io/2022/06/27/8-create-fixed-length-array/","excerpt":"新建固定长度数组使用primitives填充数组12const newArray = Array(3).fill(3);console.log(newArray); // [3, 3, 3] Array(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法","text":"新建固定长度数组使用primitives填充数组12const newArray = Array(3).fill(3);console.log(newArray); // [3, 3, 3] Array(length).fill(initialValue) 是一种创建具有所需长度并使用原始值（数字、字符串、布尔值）初始化的数组的便捷方法 使用对象填充数组(1)使用Array().fill()创建数组 12const newArray = Array(3).fill(&#123; value: 0 &#125;);console.log(newArray); // [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;] Array(length).fill({ value: 0 })创建一个 length 数组3，并为每个项目分配{ value: 0 }，要注意的是：分配相同的对象实例。这种方法创建了一个具有相同对象实例的数组。如果碰巧修改了数组中的任何一项，那么数组中的每一项都会受到影响: 1234const newArray = Array(3).fill(&#123; value: 0 &#125;);console.log(newArray); // [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]newArray[1].value = 2;console.log(newArray); // [&#123;value: 2&#125;, &#123;value: 2&#125;, &#123;value: 2&#125;] (2)使用Array.from()创建数组Array.from() 方法对一个数组或可迭代对象创建一个新的，浅拷贝的数组实例。因此利用 Array.from() 方法可以轻松地创建和初始化具有不同对象实例的数组: 1234const newArray = Array.from(Array(3), () =&gt; &#123; return &#123; value: 0 &#125;;&#125;);console.log(newArray); // [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;] 如果修改数组中的任何项目，则只有该项目会受到影响，其他项目不受影响： 123456const newArray = Array.from(Array(3), () =&gt; &#123; return &#123; value: 0 &#125;;&#125;);console.log(newArray); // [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]newArray[1].value = 2console.log(newArray); // [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;] (3)使用Array.map()结合Array.fill()创建数组注意：不要直接使用map新建数组，array.map()跳过 empty 元素 1234const newArray = Array(3).map(() =&gt; &#123; return &#123; value: 0 &#125;;&#125;);console.log(newArray); // [empty x 3] 解决方法很简单，将 empty 数组 fill null 即可： 1234const newArray = Array(3).fill(null).map(() =&gt; &#123; return &#123; value: 0 &#125;;&#125;);console.log(newArray); // [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;] 注意：使用这种方法创建的数组，修改某一项时不影响其他项： 123456const newArray = Array(3).fill(null).map(() =&gt; &#123; return &#123; value: 0 &#125;;&#125;);console.log(newArray); // [&#123;value: 0&#125;, &#123;value: 0&#125;, &#123;value: 0&#125;]newArray[1].value = 2;console.log(newArray); // [&#123;value: 0&#125;, &#123;value: 2&#125;, &#123;value: 0&#125;]","categories":[],"tags":[]},{"title":"react & vue渲染问题","slug":"7-question-about-render","date":"2022-06-23T05:21:12.000Z","updated":"2023-08-03T02:59:16.844Z","comments":true,"path":"2022/06/23/7-question-about-render/","link":"","permalink":"https://sunjinkang.github.io/2022/06/23/7-question-about-render/","excerpt":"疑问点(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？类似渲染的子节点？？？(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？没什么特别意义，团队规范规定(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？性能、更新","text":"疑问点(1)react中的快照的具体作用是什么？vue3中是否有类似的操作？类似渲染的子节点？？？(2)react中将调试打印的信息放在块级作用域中？为什么不直接放在代码里面？没什么特别意义，团队规范规定(3)vue3中在patch的时候，为什么在有了patchElement（感觉能满足大部分情况了）的情况下，分了其他几种类型？性能、更新 (4)react中react和react-dom的关系？vue3中vue.cjs.js和vue.global.jsreact-dom =》 渲染浏览器vue可以搭配react-dom(5)vue3中是否有类似react的hooks那样返回的内容含有页面代码？可以，使用createElement(6)hooks和函数的区别是什么？没区别(7)vue3中element-plus组件函数的类型从哪里获取？(8)如何将看到的东西和实际应用联系起来？(9)怎么抓住重点？","categories":[],"tags":[]},{"title":"vue3渲染","slug":"6-vue3-render","date":"2022-06-22T14:12:51.000Z","updated":"2023-08-03T02:59:03.735Z","comments":true,"path":"2022/06/22/6-vue3-render/","link":"","permalink":"https://sunjinkang.github.io/2022/06/22/6-vue3-render/","excerpt":"渲染流程(1)创建一个vue实例 -&gt; 初始化实例（包括需要相关事件与生命周期函数等）(2)调用beforeCreate(3)初始化注入，包括data、method等添加到实例对象(4)实例创建完成，调用created(5)有el挂载，使用template替换；无挂载，使用mount自动挂载(6)有template，进行编译，使其成为render函数(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板(8)调用beforeMount（vue实例挂载在虚拟DOM上）(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）(10)调用mounted– （1）数据变更，即将重新渲染– （2）调用beforeUpdate– （3）进行虚拟DOM和真实DOM对比，进行patch– （4）渲染完成，调用updated(11)实例销毁之前调用beforeUnmount(12)实例销毁，vm.$destroy(13)销毁后调用unmounted","text":"渲染流程(1)创建一个vue实例 -&gt; 初始化实例（包括需要相关事件与生命周期函数等）(2)调用beforeCreate(3)初始化注入，包括data、method等添加到实例对象(4)实例创建完成，调用created(5)有el挂载，使用template替换；无挂载，使用mount自动挂载(6)有template，进行编译，使其成为render函数(7)（1）有template，使用模板构建抽象语法树；（2）通过数据获取元素的outerHTML属性值即元素结构的字符串形式构建HTML模板(8)调用beforeMount（vue实例挂载在虚拟DOM上）(9)生成HTML元素节点，替换页面原有的挂载节点（页面渲染）(10)调用mounted– （1）数据变更，即将重新渲染– （2）调用beforeUpdate– （3）进行虚拟DOM和真实DOM对比，进行patch– （4）渲染完成，调用updated(11)实例销毁之前调用beforeUnmount(12)实例销毁，vm.$destroy(13)销毁后调用unmounted render函数(1)首先会判断Vnode是否存在，如果不存在，则调用unmount函数，进行组件的卸载(2)否则调用patch函数，对组件进行patch（PS: patch是一个递归的过程）(3)patch 结束后，会调用flushPostFlushCbs函数冲刷任务池(4)最后更新容器上的Vnode注：patch函数的主要职责就是去判断Vnode的节点类型（打上patchFlag标志），然后调用对应类型的Vnode处理方式，进行更细致的patch（最后进行render渲染） patch函数注：patch依据不同节点类型，执行不同的处理函数，包括：Text、Comment、Static、Fragment等(1)n1 与 n2 是待比较的两个节点，n1 为旧节点，n2 为新节点(2)container 是新节点的容器(3)anchor 是一个锚点，用来标识当我们对新旧节点做增删或移动等操作时，以哪个节点为参照物(4)optimized 参数是是否开启优化模式的标识 卸载组件如果调用render函数时没有传Vnode，则会调用unmount函数对组件进行卸载 ，卸载过程中：(1)如果存在ref，会首先重置ref(2)如果组件是经过Keep-Alive缓存的组件，会通过deactivate对组件进行卸载(3)如果是组件类型Vnode，会通过unmountComponent函数对组件进行卸载","categories":[],"tags":[]},{"title":"react渲染","slug":"5-react-render","date":"2022-06-22T14:12:37.000Z","updated":"2023-08-03T02:58:55.548Z","comments":true,"path":"2022/06/22/5-react-render/","link":"","permalink":"https://sunjinkang.github.io/2022/06/22/5-react-render/","excerpt":"主要步骤React.createElement语法糖(1)React.createElement(type, [props], […children]);(2)type：元素类型(3)props：属性值(4)children：子元素 虚拟DOM(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系(2)$$typeof：标识符，使用Symbol数据结构确保唯一性","text":"主要步骤React.createElement语法糖(1)React.createElement(type, [props], […children]);(2)type：元素类型(3)props：属性值(4)children：子元素 虚拟DOM(1)本质为JS对象，使用键值对存储信息，嵌套表示层级关系(2)$$typeof：标识符，使用Symbol数据结构确保唯一性 协调算法filter图示 Element转化为Dom(1)所有从React.createElement中收到的值组装成一个React的虚拟Dom，最终调用ReactDom.render方法去实现转化(2)ReactDOM.render(element, container[, callback])(3)ReactDOM.render三个参数，其中第一个参数便是生成的虚拟Dom，第二个参数则是一个真实Dom，此Dom相当于是一个容器，React元素将被渲染到这个容器里面去，第三个参数则是一个callback function 源码相关1、setState触发更新、父组件重新渲染时触发更新(1)static getDerivedStateFromProps()(2)shouldComponentUpdate(nextProps,nextState)(3)render()(4)getSnapshotBeforeUpdate(prevProps,prevState)(5)componentDidUpdate(prevProps,prevState,snapshot)其中，getSnapshotBeforeUpdate(prevProps,prevState)必须返回null或任意快照值(Snapshot Value，undefined除外)。返回的快照值将作为componentDidUpdate的第三个形参2、forceUpdate触发更新(1)static getDerivedStateFromProps()(2)render()(3)getSnapshotBeforeUpdate()(4)componentDidUpdate()","categories":[],"tags":[]},{"title":"浏览器渲染","slug":"4-browser-render","date":"2022-05-23T06:13:56.000Z","updated":"2023-08-03T02:58:43.709Z","comments":true,"path":"2022/05/23/4-browser-render/","link":"","permalink":"https://sunjinkang.github.io/2022/05/23/4-browser-render/","excerpt":"渲染流程(1)深度遍历解析HTML建立DOM树(2)解析CSS建立CSSOM树(3)依据DOM树和CSSOM树构造Render树(4)计算各元素尺寸、位置(5)绘制页面像素信息(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。)","text":"渲染流程(1)深度遍历解析HTML建立DOM树(2)解析CSS建立CSSOM树(3)依据DOM树和CSSOM树构造Render树(4)计算各元素尺寸、位置(5)绘制页面像素信息(6)浏览器将各层信息发送给GPU，GPU将各层合成，显示在屏幕上(7)(PS:上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完某一部分（整体大块的）内容就显示一部分内容，同时，可能还在通过网络下载其余内容。) GUI渲染线程(1)解析HTML，CSS，构建DOM树和Render树，布局和绘制等(2)重排/重绘–1、重排又称重构、回流，当我们通过JavaScript或者CSS修改了元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段。重排需要更新完整的渲染流水线，所以开销也是最大的。每个页面至少需要一次reflow，就是在页面第一次加载的时候。–2、任何页面布局和几何属性的改变都会触发重排，比如：页面渲染初始化；(无法避免)添加或删除可见的DOM元素；元素位置的改变；改变元素尺寸（宽、高、内外边距、边框等）；浏览器窗口尺寸的变化（resize事件发生时）；填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变；读取某些元素属性：（offsetLeft/Top/Height/Width, clientTop/Left/Width/Height, scrollTop/Left/Width/Height, width/height, getComputedStyle(), currentStyle(IE) )–3、重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。比如通过 JavaScript 更改某些元素的背景颜色，没有改变元素的几何属性，那么布局阶段不会执行，而是直接进入绘制阶段。–4、重绘省去了布局和分层阶段，效率会高于重排。重排必定会引发重绘，但重绘不一定会引发重排。 JS引擎线程(1)解析Javascript脚本，单线程执行(2)与GUI互斥，GUI ON then JS Suspend.等待着任务队列中任务的到来，然后加以处理，JS执行的时间过长会导致页面渲染加载阻塞 事件触发线程(1)归属于浏览器而不是JS引擎，用来控制事件循环(2)当JS引擎执行代码块如click事件时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件待处理队列的队尾，等待JS引擎的处理 定时触发器线程(1)setInterval与setTimeout所在线程(2)浏览器定时计数器并不是由JS引擎计数的,因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确(3)计时完毕后，将事件添加到事件队列中，等待JS引擎空闲后执行 异步http请求线程(1)在XMLHttpRequest在连接后是通过浏览器新开一个线程请求(2)将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 实现hover等鼠标操作 使用performance分析页面性能 使用network调试 preserve log 保留之前的请求","categories":[],"tags":[]},{"title":"使用hexo相关","slug":"3-about-use-hexo","date":"2022-03-26T13:14:29.000Z","updated":"2023-08-03T02:58:34.087Z","comments":true,"path":"2022/03/26/3-about-use-hexo/","link":"","permalink":"https://sunjinkang.github.io/2022/03/26/3-about-use-hexo/","excerpt":"一些使用hexo搭建博客时遇到的问题1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：’hexo’ 不是内部或外部命令，也不是可运行的程序或批处理文件 或 bash: hexo: command not found解决办法：重新运行命令：npm install hexo-cli -g 2、生成的图片路径不正确，有/.io//等一些奇怪的前缀原因：使用的hexo-asset-image插件存在bug解决办法：手动修改node_modules/hexo-asset-image中index.js文件的处理方式","text":"一些使用hexo搭建博客时遇到的问题1、一段时间为使用hexo，重新打开，生成新页面时，终端报错：’hexo’ 不是内部或外部命令，也不是可运行的程序或批处理文件 或 bash: hexo: command not found解决办法：重新运行命令：npm install hexo-cli -g 2、生成的图片路径不正确，有/.io//等一些奇怪的前缀原因：使用的hexo-asset-image插件存在bug解决办法：手动修改node_modules/hexo-asset-image中index.js文件的处理方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);function getPosition(str, m, i) &#123;return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123;var config = hexo.config;if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); // 以下生成图片路径的处理可根据自身需要进行修改 if (link == &#x27;nodejs/&#x27;) &#123; src = `images/$&#123;src&#125;`; &#125; $(this).attr(&#x27;src&#x27;, config.root + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125; &#125;);","categories":[],"tags":[]},{"title":"var、const、let区别","slug":"2-var-const-let","date":"2022-03-26T13:04:12.000Z","updated":"2023-08-03T02:54:42.123Z","comments":true,"path":"2022/03/26/2-var-const-let/","link":"","permalink":"https://sunjinkang.github.io/2022/03/26/2-var-const-let/","excerpt":"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会123456var a = 100;console.log(a,window.a); // 100 100let b = 10;console.log(b,window.b); // 10 undefinedconst c = 1;console.log(c,window.c); // 1 undefined let声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章let和const声明的变量到底去哪里了？","text":"1、挂载节点不同：var声明的变量挂载在window上，const与let声明的变量不会123456var a = 100;console.log(a,window.a); // 100 100let b = 10;console.log(b,window.b); // 10 undefinedconst c = 1;console.log(c,window.c); // 1 undefined let声明的变量或const声明的常量会挂载到Script下，var会挂载到Global下（window类似于Global的代理）。可查看文章let和const声明的变量到底去哪里了？ 2、","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"blog, giscus","slug":"blog-giscus","permalink":"https://sunjinkang.github.io/tags/blog-giscus/"},{"name":"docker","slug":"docker","permalink":"https://sunjinkang.github.io/tags/docker/"}]}